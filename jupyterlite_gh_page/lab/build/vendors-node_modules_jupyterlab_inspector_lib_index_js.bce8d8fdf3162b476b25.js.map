{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/handler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/inspector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/kernelconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/tokens.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC6C;AACM;AACP;AACD;AAC3C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,4BAA4B,qDAAM;AAClC,6BAA6B,qDAAM;AACnC;AACA,8BAA8B,qDAAM;AACpC;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C,wBAAwB;AACxB;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,kCAAkC,6DAAS,EAAE,OAAO;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACE;AACM;AACT;AACzB,iC;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACgD;AACS;AACT;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,kDAAK;AACzC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,gDAAgD,mEAAc;AAC9D;AACA,8CAA8C,mDAAM;AACpD;AACA;AACA;AACA,wEAAwE,uBAAuB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAe;AACpB,qBAAqB,sEAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;ACvHA;AACA;AACoD;AACpD;AACA;AACA;AACO,8BAA8B,8DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA,2C;;;;;;;;;;;;;;;;;ACzCA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACO,uBAAuB,oDAAK;AACnC,kC","file":"vendors-node_modules_jupyterlab_inspector_lib_index_js.bce8d8fdf3162b476b25.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Text } from '@jupyterlab/coreutils';\nimport { MimeModel } from '@jupyterlab/rendermime';\nimport { Debouncer } from '@lumino/polling';\nimport { Signal } from '@lumino/signaling';\n/**\n * An object that handles code inspection.\n */\nexport class InspectionHandler {\n    /**\n     * Construct a new inspection handler for a widget.\n     */\n    constructor(options) {\n        this._cleared = new Signal(this);\n        this._disposed = new Signal(this);\n        this._editor = null;\n        this._inspected = new Signal(this);\n        this._isDisposed = false;\n        this._pending = 0;\n        this._standby = true;\n        this._connector = options.connector;\n        this._rendermime = options.rendermime;\n        this._debouncer = new Debouncer(this.onEditorChange.bind(this), 250);\n    }\n    /**\n     * A signal emitted when the inspector should clear all items.\n     */\n    get cleared() {\n        return this._cleared;\n    }\n    /**\n     * A signal emitted when the handler is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * A signal emitted when an inspector value is generated.\n     */\n    get inspected() {\n        return this._inspected;\n    }\n    /**\n     * The editor widget used by the inspection handler.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        if (newValue === this._editor) {\n            return;\n        }\n        // Remove all of our listeners.\n        Signal.disconnectReceiver(this);\n        const editor = (this._editor = newValue);\n        if (editor) {\n            // Clear the inspector in preparation for a new editor.\n            this._cleared.emit(void 0);\n            // Call onEditorChange to cover the case where the user changes\n            // the active cell\n            this.onEditorChange();\n            editor.model.selections.changed.connect(this._onChange, this);\n            editor.model.value.changed.connect(this._onChange, this);\n        }\n    }\n    /**\n     * Indicates whether the handler makes API inspection requests or stands by.\n     *\n     * #### Notes\n     * The use case for this attribute is to limit the API traffic when no\n     * inspector is visible.\n     */\n    get standby() {\n        return this._standby;\n    }\n    set standby(value) {\n        this._standby = value;\n    }\n    /**\n     * Get whether the inspection handler is disposed.\n     *\n     * #### Notes\n     * This is a read-only property.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n        Signal.clearData(this);\n    }\n    /**\n     * Handle a text changed signal from an editor.\n     *\n     * #### Notes\n     * Update the hints inspector based on a text change.\n     */\n    onEditorChange(customText) {\n        // If the handler is in standby mode, bail.\n        if (this._standby) {\n            return;\n        }\n        const editor = this.editor;\n        if (!editor) {\n            return;\n        }\n        const text = customText ? customText : editor.model.value.text;\n        const position = editor.getCursorPosition();\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n        const update = { content: null };\n        const pending = ++this._pending;\n        void this._connector\n            .fetch({ offset, text })\n            .then(reply => {\n            // If handler has been disposed or a newer request is pending, bail.\n            if (!reply || this.isDisposed || pending !== this._pending) {\n                this._inspected.emit(update);\n                return;\n            }\n            const { data } = reply;\n            const mimeType = this._rendermime.preferredMimeType(data);\n            if (mimeType) {\n                const widget = this._rendermime.createRenderer(mimeType);\n                const model = new MimeModel({ data });\n                void widget.renderModel(model);\n                update.content = widget;\n            }\n            this._inspected.emit(update);\n        })\n            .catch(reason => {\n            // Since almost all failures are benign, fail silently.\n            this._inspected.emit(update);\n        });\n    }\n    /**\n     * Handle changes to the editor state, debouncing.\n     */\n    _onChange() {\n        void this._debouncer.invoke();\n    }\n}\n//# sourceMappingURL=handler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module inspector\n */\nexport * from './handler';\nexport * from './inspector';\nexport * from './kernelconnector';\nexport * from './tokens';\n//# sourceMappingURL=index.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Printing } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Panel, Widget } from '@lumino/widgets';\n/**\n * The class name added to inspector panels.\n */\nconst PANEL_CLASS = 'jp-Inspector';\n/**\n * The class name added to inspector content.\n */\nconst CONTENT_CLASS = 'jp-Inspector-content';\n/**\n * The class name added to default inspector content.\n */\nconst DEFAULT_CONTENT_CLASS = 'jp-Inspector-default-content';\n/**\n * A panel which contains a set of inspectors.\n */\nexport class InspectorPanel extends Panel {\n    /**\n     * Construct an inspector.\n     */\n    constructor(options = {}) {\n        super();\n        this._source = null;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        if (options.initialContent instanceof Widget) {\n            this._content = options.initialContent;\n        }\n        else if (typeof options.initialContent === 'string') {\n            this._content = InspectorPanel._generateContentWidget(`<p>${options.initialContent}</p>`);\n        }\n        else {\n            this._content = InspectorPanel._generateContentWidget('<p>' +\n                this._trans.__('Click on a function to see documentation.') +\n                '</p>');\n        }\n        this.addClass(PANEL_CLASS);\n        this.layout.addWidget(this._content);\n    }\n    /**\n     * Print in iframe\n     */\n    [Printing.symbol]() {\n        return () => Printing.printWidget(this);\n    }\n    /**\n     * The source of events the inspector panel listens for.\n     */\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // Disconnect old signal handler.\n        if (this._source) {\n            this._source.standby = true;\n            this._source.inspected.disconnect(this.onInspectorUpdate, this);\n            this._source.disposed.disconnect(this.onSourceDisposed, this);\n        }\n        // Reject a source that is already disposed.\n        if (source && source.isDisposed) {\n            source = null;\n        }\n        // Update source.\n        this._source = source;\n        // Connect new signal handler.\n        if (this._source) {\n            this._source.standby = false;\n            this._source.inspected.connect(this.onInspectorUpdate, this);\n            this._source.disposed.connect(this.onSourceDisposed, this);\n        }\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.source = null;\n        super.dispose();\n    }\n    /**\n     * Handle inspector update signals.\n     */\n    onInspectorUpdate(sender, args) {\n        const { content } = args;\n        // Update the content of the inspector widget.\n        if (!content || content === this._content) {\n            return;\n        }\n        this._content.dispose();\n        this._content = content;\n        content.addClass(CONTENT_CLASS);\n        this.layout.addWidget(content);\n    }\n    /**\n     * Handle source disposed signals.\n     */\n    onSourceDisposed(sender, args) {\n        this.source = null;\n    }\n    /**\n     * Generate content widget from string\n     */\n    static _generateContentWidget(message) {\n        const widget = new Widget();\n        widget.node.innerHTML = message;\n        widget.addClass(CONTENT_CLASS);\n        widget.addClass(DEFAULT_CONTENT_CLASS);\n        return widget;\n    }\n}\n//# sourceMappingURL=inspector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * The default connector for making inspection requests from the Jupyter API.\n */\nexport class KernelConnector extends DataConnector {\n    /**\n     * Create a new kernel connector for inspection requests.\n     *\n     * @param options - The instantiation options for the kernel connector.\n     */\n    constructor(options) {\n        super();\n        this._sessionContext = options.sessionContext;\n    }\n    /**\n     * Fetch inspection requests.\n     *\n     * @param request - The inspection request text and details.\n     */\n    fetch(request) {\n        var _a;\n        const kernel = (_a = this._sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            return Promise.reject(new Error('Inspection fetch requires a kernel.'));\n        }\n        const contents = {\n            code: request.text,\n            cursor_pos: request.offset,\n            detail_level: 1\n        };\n        return kernel.requestInspect(contents).then(msg => {\n            const response = msg.content;\n            if (response.status !== 'ok' || !response.found) {\n                throw new Error('Inspection fetch failed to return successfully.');\n            }\n            return { data: response.data, metadata: response.metadata };\n        });\n    }\n}\n//# sourceMappingURL=kernelconnector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The inspector panel token.\n */\nexport const IInspector = new Token('@jupyterlab/inspector:IInspector');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}