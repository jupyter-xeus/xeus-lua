{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/array.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/broadcastchannel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/function.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/math.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/mutex.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/object.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/y-protocols/awareness.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/y-protocols/sync.js"],"names":["last","arr","length","appendTo","dest","src","i","push","from","Array","equalFlat","a","b","f","item","index","every","channels","Map","BC","BroadcastChannel","constructor","room","this","onmessage","e","key","data","newValue","postMessage","buf","getChannel","subs","Set","bc","forEach","sub","subscribe","add","unsubscribe","delete","publish","c","callAll","fs","args","nop","equalityFlat","equalityDeep","equalityStrict","ArrayBuffer","Uint8Array","byteLength","size","value","has","keys","get","Object","floor","Math","abs","ceil","log10","imul","round","log2","log","sqrt","min","max","isNegativeZero","Number","isNaN","pow","sign","n","createMutex","token","g","undefined","assign","map","obj","results","hasProperty","prototype","hasOwnProperty","call","val","Awareness","doc","super","clientID","states","meta","_checkInterval","setInterval","now","getLocalState","outdatedTimeout","lastUpdated","setLocalState","remove","clientid","removeAwarenessStates","on","destroy","emit","clearInterval","state","currLocalMeta","clock","prevState","set","added","updated","filteredUpdated","removed","setLocalStateField","field","getStates","awareness","clients","origin","curMeta","encodeAwarenessUpdate","len","encoder","JSON","stringify","applyAwarenessUpdate","update","decoder","timestamp","parse","clientMeta","currClock","messageYjsSyncStep1","messageYjsSyncStep2","writeSyncStep1","sv","writeSyncStep2","encodedStateVector","readSyncStep2","transactionOrigin","error","console","writeUpdate","readUpdate","readSyncMessage","messageType","readSyncStep1","Error"],"mappings":"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","file":"3100.81595bb924fa1948dadb.js","sourcesContent":["/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => arr.every(f)\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => arr.some(f)\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n","/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\nimport * as map from './map.js'\nimport * as buffer from './buffer.js'\nimport * as storage from './storage.js'\n\n/**\n * @typedef {Object} Channel\n * @property {Set<Function>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    storage.onChange(e => e.key === room && this.onmessage !== null && this.onmessage({ data: buffer.fromBase64(e.newValue || '') }))\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    storage.varStorage.setItem(this.room, buffer.toBase64(buffer.createUint8ArrayFromArrayBuffer(buf)))\n  }\n}\n\n// Use BroadcastChannel or Polyfill\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  map.setIfUndefined(channels, room, () => {\n    const subs = new Set()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nexport const subscribe = (room, f) => getChannel(room).subs.add(f)\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nexport const unsubscribe = (room, f) => getChannel(room).subs.delete(f)\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n */\nexport const publish = (room, data) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data))\n}\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nexport const createMutex = () => {\n  let token = true\n  return (f, g) => {\n    if (token) {\n      token = false\n      try {\n        f()\n      } finally {\n        token = true\n      }\n    } else if (g !== undefined) {\n      g()\n    }\n  }\n}\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n","/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n","/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as Y from 'yjs'\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0\nexport const messageYjsSyncStep2 = 1\nexport const messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = Y.encodeStateVector(doc)\n  encoding.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2)\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate)\n  encoding.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n}\n"],"sourceRoot":""}