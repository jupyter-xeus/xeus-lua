{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/shortcuts-extension/lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACgF;AAC1B;AACV;AACO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAgB,EAAE,gEAAW;AAC5C;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2FAAkC;AACjE;AACA,+BAA+B;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,+DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qCAAqC,aAAa;AAClD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,MAAM,6DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,iC","file":"node_modules_jupyterlab_shortcuts-extension_lib_index_js.b8e551cb759e434207b8.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module shortcuts-extension\n */\nimport { ISettingRegistry, SettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { JSONExt } from '@lumino/coreutils';\nimport { DisposableSet } from '@lumino/disposable';\n/**\n * The default shortcuts extension.\n *\n * #### Notes\n * Shortcut values are stored in the setting system. The default values for each\n * shortcut are preset in the settings schema file of this extension.\n * Additionally, each shortcut can be individually set by the end user by\n * modifying its setting (either in the text editor or by modifying its\n * underlying JSON schema file).\n *\n * When setting shortcut selectors, there are two concepts to consider:\n * specificity and matchability. These two interact in sometimes\n * counterintuitive ways. Keyboard events are triggered from an element and\n * they propagate up the DOM until they reach the `documentElement` (`<body>`).\n *\n * When a registered shortcut sequence is fired, the shortcut manager checks\n * the node that fired the event and each of its ancestors until a node matches\n * one or more registered selectors. The *first* matching selector in the\n * chain of ancestors will invoke the shortcut handler and the traversal will\n * end at that point. If a node matches more than one selector, the handler for\n * whichever selector is more *specific* fires.\n * @see https://www.w3.org/TR/css3-selectors/#specificity\n *\n * The practical consequence of this is that a very broadly matching selector,\n * e.g. `'*'` or `'div'` may match and therefore invoke a handler *before* a\n * more specific selector. The most common pitfall is to use the universal\n * (`'*'`) selector. For almost any use case where a global keyboard shortcut is\n * required, using the `'body'` selector is more appropriate.\n */\nconst shortcuts = {\n    id: '@jupyterlab/shortcuts-extension:shortcuts',\n    requires: [ISettingRegistry, ITranslator],\n    activate: async (app, registry, translator) => {\n        const trans = translator.load('jupyterlab');\n        const { commands } = app;\n        let canonical;\n        let loaded = {};\n        /**\n         * Populate the plugin's schema defaults.\n         */\n        function populate(schema) {\n            const commands = app.commands.listCommands().join('\\n');\n            loaded = {};\n            schema.properties.shortcuts.default = Object.keys(registry.plugins)\n                .map(plugin => {\n                const shortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                loaded[plugin] = shortcuts;\n                return shortcuts;\n            })\n                .concat([schema.properties.shortcuts.default])\n                .reduce((acc, val) => acc.concat(val), []) // flatten one level\n                .sort((a, b) => a.command.localeCompare(b.command));\n            schema.properties.shortcuts.description = trans.__(`Note: To disable a system default shortcut,\ncopy it to User Preferences and add the\n\"disabled\" key, for example:\n{\n    \"command\": \"application:activate-next-tab\",\n    \"keys\": [\n        \"Ctrl Shift ]\"\n    ],\n    \"selector\": \"body\",\n    \"disabled\": true\n}\n\nList of commands followed by keyboard shortcuts:\n%1\n\nList of keyboard shortcuts:`, commands);\n        }\n        registry.pluginChanged.connect(async (sender, plugin) => {\n            if (plugin !== shortcuts.id) {\n                // If the plugin changed its shortcuts, reload everything.\n                const oldShortcuts = loaded[plugin];\n                const newShortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                if (oldShortcuts === undefined ||\n                    !JSONExt.deepEqual(oldShortcuts, newShortcuts)) {\n                    canonical = null;\n                    await registry.reload(shortcuts.id);\n                }\n            }\n        });\n        // Transform the plugin object to return different schema than the default.\n        registry.transform(shortcuts.id, {\n            compose: plugin => {\n                var _a, _b, _c, _d;\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                const defaults = (_c = (_b = (_a = canonical.properties) === null || _a === void 0 ? void 0 : _a.shortcuts) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : [];\n                const user = {\n                    shortcuts: (_d = plugin.data.user.shortcuts) !== null && _d !== void 0 ? _d : []\n                };\n                const composite = {\n                    shortcuts: SettingRegistry.reconcileShortcuts(defaults, user.shortcuts)\n                };\n                plugin.data = { composite, user };\n                return plugin;\n            },\n            fetch: plugin => {\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                return {\n                    data: plugin.data,\n                    id: plugin.id,\n                    raw: plugin.raw,\n                    schema: canonical,\n                    version: plugin.version\n                };\n            }\n        });\n        try {\n            // Repopulate the canonical variable after the setting registry has\n            // preloaded all initial plugins.\n            canonical = null;\n            const settings = await registry.load(shortcuts.id);\n            Private.loadShortcuts(commands, settings.composite);\n            settings.changed.connect(() => {\n                Private.loadShortcuts(commands, settings.composite);\n            });\n        }\n        catch (error) {\n            console.error(`Loading ${shortcuts.id} failed.`, error);\n        }\n    },\n    autoStart: true\n};\n/**\n * Export the shortcut plugin as default.\n */\nexport default shortcuts;\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The internal collection of currently loaded shortcuts.\n     */\n    let disposables;\n    /**\n     * Load the keyboard shortcuts from settings.\n     */\n    function loadShortcuts(commands, composite) {\n        var _a;\n        const shortcuts = ((_a = composite === null || composite === void 0 ? void 0 : composite.shortcuts) !== null && _a !== void 0 ? _a : []);\n        if (disposables) {\n            disposables.dispose();\n        }\n        disposables = shortcuts.reduce((acc, val) => {\n            const options = normalizeOptions(val);\n            if (options) {\n                acc.add(commands.addKeyBinding(options));\n            }\n            return acc;\n        }, new DisposableSet());\n    }\n    Private.loadShortcuts = loadShortcuts;\n    /**\n     * Normalize potential keyboard shortcut options.\n     */\n    function normalizeOptions(value) {\n        if (!value || typeof value !== 'object') {\n            return undefined;\n        }\n        const { isArray } = Array;\n        const valid = 'command' in value &&\n            'keys' in value &&\n            'selector' in value &&\n            isArray(value.keys);\n        return valid ? value : undefined;\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}