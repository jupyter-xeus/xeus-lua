{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/handler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/inspector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/kernelconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector/lib/tokens.js"],"names":["InspectionHandler","constructor","options","this","_cleared","Signal","_disposed","_editor","_inspected","_isDisposed","_pending","_standby","_connector","connector","_rendermime","rendermime","_debouncer","Debouncer","onEditorChange","bind","newValue","editor","emit","model","selections","changed","connect","_onChange","value","dispose","isDisposed","customText","text","position","getCursorPosition","offset","Text","getOffsetAt","update","content","pending","fetch","then","reply","data","mimeType","preferredMimeType","widget","createRenderer","MimeModel","renderModel","catch","reason","invoke","CONTENT_CLASS","InspectorPanel","Panel","super","_source","translator","nullTranslator","_trans","load","initialContent","Widget","_content","_generateContentWidget","__","addClass","layout","addWidget","Printing","source","standby","inspected","disconnect","onInspectorUpdate","disposed","onSourceDisposed","sender","args","message","node","innerHTML","KernelConnector","DataConnector","_sessionContext","sessionContext","request","_a","kernel","session","Promise","reject","Error","contents","code","cursor_pos","detail_level","requestInspect","msg","response","status","found","metadata","IInspector","Token"],"mappings":"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","file":"1978.7dfa41920fd069125b8b.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Text } from '@jupyterlab/coreutils';\nimport { MimeModel } from '@jupyterlab/rendermime';\nimport { Debouncer } from '@lumino/polling';\nimport { Signal } from '@lumino/signaling';\n/**\n * An object that handles code inspection.\n */\nexport class InspectionHandler {\n    /**\n     * Construct a new inspection handler for a widget.\n     */\n    constructor(options) {\n        this._cleared = new Signal(this);\n        this._disposed = new Signal(this);\n        this._editor = null;\n        this._inspected = new Signal(this);\n        this._isDisposed = false;\n        this._pending = 0;\n        this._standby = true;\n        this._connector = options.connector;\n        this._rendermime = options.rendermime;\n        this._debouncer = new Debouncer(this.onEditorChange.bind(this), 250);\n    }\n    /**\n     * A signal emitted when the inspector should clear all items.\n     */\n    get cleared() {\n        return this._cleared;\n    }\n    /**\n     * A signal emitted when the handler is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * A signal emitted when an inspector value is generated.\n     */\n    get inspected() {\n        return this._inspected;\n    }\n    /**\n     * The editor widget used by the inspection handler.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        if (newValue === this._editor) {\n            return;\n        }\n        // Remove all of our listeners.\n        Signal.disconnectReceiver(this);\n        const editor = (this._editor = newValue);\n        if (editor) {\n            // Clear the inspector in preparation for a new editor.\n            this._cleared.emit(void 0);\n            // Call onEditorChange to cover the case where the user changes\n            // the active cell\n            this.onEditorChange();\n            editor.model.selections.changed.connect(this._onChange, this);\n            editor.model.value.changed.connect(this._onChange, this);\n        }\n    }\n    /**\n     * Indicates whether the handler makes API inspection requests or stands by.\n     *\n     * #### Notes\n     * The use case for this attribute is to limit the API traffic when no\n     * inspector is visible.\n     */\n    get standby() {\n        return this._standby;\n    }\n    set standby(value) {\n        this._standby = value;\n    }\n    /**\n     * Get whether the inspection handler is disposed.\n     *\n     * #### Notes\n     * This is a read-only property.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n        Signal.clearData(this);\n    }\n    /**\n     * Handle a text changed signal from an editor.\n     *\n     * #### Notes\n     * Update the hints inspector based on a text change.\n     */\n    onEditorChange(customText) {\n        // If the handler is in standby mode, bail.\n        if (this._standby) {\n            return;\n        }\n        const editor = this.editor;\n        if (!editor) {\n            return;\n        }\n        const text = customText ? customText : editor.model.value.text;\n        const position = editor.getCursorPosition();\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n        const update = { content: null };\n        const pending = ++this._pending;\n        void this._connector\n            .fetch({ offset, text })\n            .then(reply => {\n            // If handler has been disposed or a newer request is pending, bail.\n            if (!reply || this.isDisposed || pending !== this._pending) {\n                this._inspected.emit(update);\n                return;\n            }\n            const { data } = reply;\n            const mimeType = this._rendermime.preferredMimeType(data);\n            if (mimeType) {\n                const widget = this._rendermime.createRenderer(mimeType);\n                const model = new MimeModel({ data });\n                void widget.renderModel(model);\n                update.content = widget;\n            }\n            this._inspected.emit(update);\n        })\n            .catch(reason => {\n            // Since almost all failures are benign, fail silently.\n            this._inspected.emit(update);\n        });\n    }\n    /**\n     * Handle changes to the editor state, debouncing.\n     */\n    _onChange() {\n        void this._debouncer.invoke();\n    }\n}\n//# sourceMappingURL=handler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Printing } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Panel, Widget } from '@lumino/widgets';\n/**\n * The class name added to inspector panels.\n */\nconst PANEL_CLASS = 'jp-Inspector';\n/**\n * The class name added to inspector content.\n */\nconst CONTENT_CLASS = 'jp-Inspector-content';\n/**\n * The class name added to default inspector content.\n */\nconst DEFAULT_CONTENT_CLASS = 'jp-Inspector-default-content';\n/**\n * A panel which contains a set of inspectors.\n */\nexport class InspectorPanel extends Panel {\n    /**\n     * Construct an inspector.\n     */\n    constructor(options = {}) {\n        super();\n        this._source = null;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        if (options.initialContent instanceof Widget) {\n            this._content = options.initialContent;\n        }\n        else if (typeof options.initialContent === 'string') {\n            this._content = InspectorPanel._generateContentWidget(`<p>${options.initialContent}</p>`);\n        }\n        else {\n            this._content = InspectorPanel._generateContentWidget('<p>' +\n                this._trans.__('Click on a function to see documentation.') +\n                '</p>');\n        }\n        this.addClass(PANEL_CLASS);\n        this.layout.addWidget(this._content);\n    }\n    /**\n     * Print in iframe\n     */\n    [Printing.symbol]() {\n        return () => Printing.printWidget(this);\n    }\n    /**\n     * The source of events the inspector panel listens for.\n     */\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // Disconnect old signal handler.\n        if (this._source) {\n            this._source.standby = true;\n            this._source.inspected.disconnect(this.onInspectorUpdate, this);\n            this._source.disposed.disconnect(this.onSourceDisposed, this);\n        }\n        // Reject a source that is already disposed.\n        if (source && source.isDisposed) {\n            source = null;\n        }\n        // Update source.\n        this._source = source;\n        // Connect new signal handler.\n        if (this._source) {\n            this._source.standby = false;\n            this._source.inspected.connect(this.onInspectorUpdate, this);\n            this._source.disposed.connect(this.onSourceDisposed, this);\n        }\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.source = null;\n        super.dispose();\n    }\n    /**\n     * Handle inspector update signals.\n     */\n    onInspectorUpdate(sender, args) {\n        const { content } = args;\n        // Update the content of the inspector widget.\n        if (!content || content === this._content) {\n            return;\n        }\n        this._content.dispose();\n        this._content = content;\n        content.addClass(CONTENT_CLASS);\n        this.layout.addWidget(content);\n    }\n    /**\n     * Handle source disposed signals.\n     */\n    onSourceDisposed(sender, args) {\n        this.source = null;\n    }\n    /**\n     * Generate content widget from string\n     */\n    static _generateContentWidget(message) {\n        const widget = new Widget();\n        widget.node.innerHTML = message;\n        widget.addClass(CONTENT_CLASS);\n        widget.addClass(DEFAULT_CONTENT_CLASS);\n        return widget;\n    }\n}\n//# sourceMappingURL=inspector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * The default connector for making inspection requests from the Jupyter API.\n */\nexport class KernelConnector extends DataConnector {\n    /**\n     * Create a new kernel connector for inspection requests.\n     *\n     * @param options - The instantiation options for the kernel connector.\n     */\n    constructor(options) {\n        super();\n        this._sessionContext = options.sessionContext;\n    }\n    /**\n     * Fetch inspection requests.\n     *\n     * @param request - The inspection request text and details.\n     */\n    fetch(request) {\n        var _a;\n        const kernel = (_a = this._sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            return Promise.reject(new Error('Inspection fetch requires a kernel.'));\n        }\n        const contents = {\n            code: request.text,\n            cursor_pos: request.offset,\n            detail_level: 1\n        };\n        return kernel.requestInspect(contents).then(msg => {\n            const response = msg.content;\n            if (response.status !== 'ok' || !response.found) {\n                throw new Error('Inspection fetch failed to return successfully.');\n            }\n            return { data: response.data, metadata: response.metadata };\n        });\n    }\n}\n//# sourceMappingURL=kernelconnector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The inspector panel token.\n */\nexport const IInspector = new Token('@jupyterlab/inspector:IInspector');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}