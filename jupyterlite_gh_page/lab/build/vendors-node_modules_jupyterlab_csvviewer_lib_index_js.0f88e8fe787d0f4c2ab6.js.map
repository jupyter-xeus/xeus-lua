{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/csvviewer/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/csvviewer/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/csvviewer/lib/parse.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/csvviewer/lib/toolbar.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/csvviewer/lib/widget.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACwB;AACA;AACE;AACD;AACzB,iC;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACoD;AACP;AACQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAQ;AACpB,cAAc,oDAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,uDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC,aAAa,0HAA0H;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA,iC;;;;;;;;;;;;;;;;AClkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,iHAAiH;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB;AACA,WAAW,uEAAuE;AAClF,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE,WAAW,MAAM,WAAW,IAAI,iEAAiE,uBAAuB;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE,WAAW,MAAM,WAAW,IAAI;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,EAAE,WAAW,MAAM,WAAW,IAAI;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE,WAAW,MAAM,WAAW,IAAI,iEAAiE,uBAAuB;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE,WAAW,MAAM,WAAW,IAAI;AACpF;AACA;AACA;AACA,8CAA8C,EAAE,WAAW,MAAM,WAAW,IAAI;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE,WAAW,MAAM,WAAW,IAAI,iEAAiE,uBAAuB;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE,WAAW,MAAM,WAAW,IAAI;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,EAAE,WAAW,MAAM,WAAW,IAAI;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,oGAAoG;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;;AC3XA;AACA;AAC+C;AACU;AAChB;AACE;AACF;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,mDAAM;AACxC;AACA;AACA;AACA;AACA,eAAe,iEAAiE;AAChF,qCAAqC,qDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,oEAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,mC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjHA;AACA;AACA,cAAc,SAAI,IAAI,SAAI;AAC1B;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACwD;AACmB;AACvB;AAC+D;AACxE;AACW;AACnB;AACM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,4BAA4B,qDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qCAAqC;AACtE,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,mDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAe;AAC5C;AACA;AACA,0CAA0C,wDAAW;AACrD;AACA,yBAAyB,sDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC,6DAAe;AACnD,sCAAsC,+DAAiB;AACvD;AACA;AACA,oBAAoB,wEAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAe;AAC/C;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4CAAQ;AAC9D;AACA;AACA,SAAS;AACT,wCAAwC,iEAAmB,EAAE,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO,gCAAgC,mEAAc;AACrD;AACA,aAAa,sCAAsC;AACnD;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA,iCAAiC,kDAAY,EAAE,8BAA8B;AAC7E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACO,+BAA+B,qEAAgB;AACtD;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACO,+BAA+B,qEAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kC","file":"vendors-node_modules_jupyterlab_csvviewer_lib_index_js.0f88e8fe787d0f4c2ab6.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module csvviewer\n */\nexport * from './model';\nexport * from './parse';\nexport * from './toolbar';\nexport * from './widget';\n//# sourceMappingURL=index.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { DataModel } from '@lumino/datagrid';\nimport { parseDSV, parseDSVNoQuotes } from './parse';\n/*\nPossible ideas for further implementation:\n\n- Show a spinner or something visible when we are doing delayed parsing.\n- The cache right now handles scrolling down great - it gets the next several hundred rows. However, scrolling up causes lots of cache misses - each new row causes a flush of the cache. When invalidating an entire cache, we should put the requested row in middle of the cache (adjusting for rows at the beginning or end). When populating a cache, we should retrieve rows both above and below the requested row.\n- When we have a header, and we are guessing the parser to use, try checking just the part of the file *after* the header row for quotes. I think often a first header row is quoted, but the rest of the file is not and can be parsed much faster.\n- autdetect the delimiter (look for comma, tab, semicolon in first line. If more than one found, parse first row with comma, tab, semicolon delimiters. One with most fields wins).\n- Toolbar buttons to control the row delimiter, the parsing engine (quoted/not quoted), the quote character, etc.\n- Investigate incremental loading strategies in the parseAsync function. In initial investigations, setting the chunk size to 100k in parseAsync seems cause instability with large files in Chrome (such as 8-million row files). Perhaps this is because we are recycling the row offset and column offset arrays quickly? It doesn't seem that there is a memory leak. On this theory, perhaps we just need to keep the offsets list an actual list, and pass it into the parsing function to extend without copying, and finalize it into an array buffer only when we are done parsing. Or perhaps we double the size of the array buffer each time, which may be wasteful, but at the end we trim it down if it's too wasteful (perhaps we have our own object that is backed by an array buffer, but has a push method that will automatically double the array buffer size as needed, and a trim function to finalize the array to exactly the size needed)? Or perhaps we don't use array buffers at all - compare the memory cost and speed of keeping the offsets as lists instead of memory buffers.\n- Investigate a time-based incremental parsing strategy, rather than a row-based one. The parser could take a maximum time to parse (say 300ms), and will parse up to that duration, in which case the parser probably also needs a way to notify when it has reached the end of a file.\n- For very large files, where we are only storing a small cache, scrolling is very laggy in Safari. It would be good to profile it.\n*/\n/**\n * Possible delimiter-separated data parsers.\n */\nconst PARSERS = {\n    quotes: parseDSV,\n    noquotes: parseDSVNoQuotes\n};\n/**\n * A data model implementation for in-memory delimiter-separated data.\n *\n * #### Notes\n * This model handles data with up to 2**32 characters.\n */\nexport class DSVModel extends DataModel {\n    /**\n     * Create a data model with static CSV data.\n     *\n     * @param options - The options for initializing the data model.\n     */\n    constructor(options) {\n        super();\n        this._rowCount = 0;\n        // Cache information\n        /**\n         * The header strings.\n         */\n        this._header = [];\n        /**\n         * The column offset cache, starting with row _columnOffsetsStartingRow\n         *\n         * #### Notes\n         * The index of the first character in the data string for row r, column c is\n         * _columnOffsets[(r-this._columnOffsetsStartingRow)*numColumns+c]\n         */\n        this._columnOffsets = new Uint32Array(0);\n        /**\n         * The row that _columnOffsets[0] represents.\n         */\n        this._columnOffsetsStartingRow = 0;\n        /**\n         * The maximum number of rows to parse when there is a cache miss.\n         */\n        this._maxCacheGet = 1000;\n        /**\n         * The index for the start of each row.\n         */\n        this._rowOffsets = new Uint32Array(0);\n        // Bookkeeping variables.\n        this._delayedParse = null;\n        this._startedParsing = false;\n        this._doneParsing = false;\n        this._isDisposed = false;\n        this._ready = new PromiseDelegate();\n        let { data, delimiter = ',', rowDelimiter = undefined, quote = '\"', quoteParser = undefined, header = true, initialRows = 500 } = options;\n        this._rawData = data;\n        this._delimiter = delimiter;\n        this._quote = quote;\n        this._quoteEscaped = new RegExp(quote + quote, 'g');\n        this._initialRows = initialRows;\n        // Guess the row delimiter if it was not supplied. This will be fooled if a\n        // different line delimiter possibility appears in the first row.\n        if (rowDelimiter === undefined) {\n            const i = data.slice(0, 5000).indexOf('\\r');\n            if (i === -1) {\n                rowDelimiter = '\\n';\n            }\n            else if (data[i + 1] === '\\n') {\n                rowDelimiter = '\\r\\n';\n            }\n            else {\n                rowDelimiter = '\\r';\n            }\n        }\n        this._rowDelimiter = rowDelimiter;\n        if (quoteParser === undefined) {\n            // Check for the existence of quotes if the quoteParser is not set.\n            quoteParser = data.indexOf(quote) >= 0;\n        }\n        this._parser = quoteParser ? 'quotes' : 'noquotes';\n        // Parse the data.\n        this.parseAsync();\n        // Cache the header row.\n        if (header === true && this._columnCount > 0) {\n            const h = [];\n            for (let c = 0; c < this._columnCount; c++) {\n                h.push(this._getField(0, c));\n            }\n            this._header = h;\n        }\n    }\n    /**\n     * Whether this model has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A promise that resolves when the model has parsed all of its data.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * The string representation of the data.\n     */\n    get rawData() {\n        return this._rawData;\n    }\n    set rawData(value) {\n        this._rawData = value;\n    }\n    /**\n     * The initial chunk of rows to parse.\n     */\n    get initialRows() {\n        return this._initialRows;\n    }\n    set initialRows(value) {\n        this._initialRows = value;\n    }\n    /**\n     * The header strings.\n     */\n    get header() {\n        return this._header;\n    }\n    set header(value) {\n        this._header = value;\n    }\n    /**\n     * The delimiter between entries on the same row.\n     */\n    get delimiter() {\n        return this._delimiter;\n    }\n    /**\n     * The delimiter between rows.\n     */\n    get rowDelimiter() {\n        return this._rowDelimiter;\n    }\n    /**\n     * A boolean determined by whether parsing has completed.\n     */\n    get doneParsing() {\n        return this._doneParsing;\n    }\n    /**\n     * Get the row count for a region in the data model.\n     *\n     * @param region - The row region of interest.\n     *\n     * @returns - The row count for the region.\n     */\n    rowCount(region) {\n        if (region === 'body') {\n            if (this._header.length === 0) {\n                return this._rowCount;\n            }\n            else {\n                return this._rowCount - 1;\n            }\n        }\n        return 1;\n    }\n    /**\n     * Get the column count for a region in the data model.\n     *\n     * @param region - The column region of interest.\n     *\n     * @returns - The column count for the region.\n     */\n    columnCount(region) {\n        if (region === 'body') {\n            return this._columnCount;\n        }\n        return 1;\n    }\n    /**\n     * Get the data value for a cell in the data model.\n     *\n     * @param region - The cell region of interest.\n     *\n     * @param row - The row index of the cell of interest.\n     *\n     * @param column - The column index of the cell of interest.\n     *\n     * @param returns - The data value for the specified cell.\n     */\n    data(region, row, column) {\n        let value;\n        // Look up the field and value for the region.\n        switch (region) {\n            case 'body':\n                if (this._header.length === 0) {\n                    value = this._getField(row, column);\n                }\n                else {\n                    value = this._getField(row + 1, column);\n                }\n                break;\n            case 'column-header':\n                if (this._header.length === 0) {\n                    value = (column + 1).toString();\n                }\n                else {\n                    value = this._header[column];\n                }\n                break;\n            case 'row-header':\n                value = (row + 1).toString();\n                break;\n            case 'corner-header':\n                value = '';\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Return the final value.\n        return value;\n    }\n    /**\n     * Dispose the resources held by this model.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._columnCount = undefined;\n        this._rowCount = undefined;\n        this._rowOffsets = null;\n        this._columnOffsets = null;\n        this._rawData = null;\n        // Clear out state associated with the asynchronous parsing.\n        if (this._doneParsing === false) {\n            // Explicitly catch this rejection at least once so an error is not thrown\n            // to the console.\n            this.ready.catch(() => {\n                return;\n            });\n            this._ready.reject(undefined);\n        }\n        if (this._delayedParse !== null) {\n            window.clearTimeout(this._delayedParse);\n        }\n    }\n    /**\n     * Get the index in the data string for the first character of a row and\n     * column.\n     *\n     * @param row - The row of the data item.\n     * @param column - The column of the data item.\n     * @returns - The index into the data string where the data item starts.\n     */\n    getOffsetIndex(row, column) {\n        // Declare local variables.\n        const ncols = this._columnCount;\n        // Check to see if row *should* be in the cache, based on the cache size.\n        let rowIndex = (row - this._columnOffsetsStartingRow) * ncols;\n        if (rowIndex < 0 || rowIndex > this._columnOffsets.length) {\n            // Row isn't in the cache, so we invalidate the entire cache and set up\n            // the cache to hold the requested row.\n            this._columnOffsets.fill(0xffffffff);\n            this._columnOffsetsStartingRow = row;\n            rowIndex = 0;\n        }\n        // Check to see if we need to fetch the row data into the cache.\n        if (this._columnOffsets[rowIndex] === 0xffffffff) {\n            // Figure out how many rows below us also need to be fetched.\n            let maxRows = 1;\n            while (maxRows <= this._maxCacheGet &&\n                this._columnOffsets[rowIndex + maxRows * ncols] === 0xffffff) {\n                maxRows++;\n            }\n            // Parse the data to get the column offsets.\n            const { offsets } = PARSERS[this._parser]({\n                data: this._rawData,\n                delimiter: this._delimiter,\n                rowDelimiter: this._rowDelimiter,\n                quote: this._quote,\n                columnOffsets: true,\n                maxRows: maxRows,\n                ncols: ncols,\n                startIndex: this._rowOffsets[row]\n            });\n            // Copy results to the cache.\n            for (let i = 0; i < offsets.length; i++) {\n                this._columnOffsets[rowIndex + i] = offsets[i];\n            }\n        }\n        // Return the offset index from cache.\n        return this._columnOffsets[rowIndex + column];\n    }\n    /**\n     * Parse the data string asynchronously.\n     *\n     * #### Notes\n     * It can take several seconds to parse a several hundred megabyte string, so\n     * we parse the first 500 rows to get something up on the screen, then we\n     * parse the full data string asynchronously.\n     */\n    parseAsync() {\n        // Number of rows to get initially.\n        let currentRows = this._initialRows;\n        // Number of rows to get in each chunk thereafter. We set this high to just\n        // get the rest of the rows for now.\n        let chunkRows = Math.pow(2, 32) - 1;\n        // We give the UI a chance to draw by delaying the chunk parsing.\n        const delay = 30; // milliseconds\n        // Define a function to parse a chunk up to and including endRow.\n        const parseChunk = (endRow) => {\n            try {\n                this._computeRowOffsets(endRow);\n            }\n            catch (e) {\n                // Sometimes the data string cannot be parsed with the full parser (for\n                // example, we may have the wrong delimiter). In these cases, fall back to\n                // the simpler parser so we can show something.\n                if (this._parser === 'quotes') {\n                    console.warn(e);\n                    this._parser = 'noquotes';\n                    this._resetParser();\n                    this._computeRowOffsets(endRow);\n                }\n                else {\n                    throw e;\n                }\n            }\n            return this._doneParsing;\n        };\n        // Reset the parser to its initial state.\n        this._resetParser();\n        // Parse the first rows to give us the start of the data right away.\n        const done = parseChunk(currentRows);\n        // If we are done, return early.\n        if (done) {\n            return;\n        }\n        // Define a function to recursively parse the next chunk after a delay.\n        const delayedParse = () => {\n            // Parse up to the new end row.\n            const done = parseChunk(currentRows + chunkRows);\n            currentRows += chunkRows;\n            // Gradually double the chunk size until we reach a million rows, if we\n            // start below a million-row chunk size.\n            if (chunkRows < 1000000) {\n                chunkRows *= 2;\n            }\n            // If we aren't done, the schedule another parse.\n            if (done) {\n                this._delayedParse = null;\n            }\n            else {\n                this._delayedParse = window.setTimeout(delayedParse, delay);\n            }\n        };\n        // Parse full data string in chunks, delayed by a few milliseconds to give the UI a chance to draw.\n        this._delayedParse = window.setTimeout(delayedParse, delay);\n    }\n    /**\n     * Compute the row offsets and initialize the column offset cache.\n     *\n     * @param endRow - The last row to parse, from the start of the data (first\n     * row is row 1).\n     *\n     * #### Notes\n     * This method supports parsing the data incrementally by calling it with\n     * incrementally higher endRow. Rows that have already been parsed will not be\n     * parsed again.\n     */\n    _computeRowOffsets(endRow = 4294967295) {\n        var _a;\n        // If we've already parsed up to endRow, or if we've already parsed the\n        // entire data set, return early.\n        if (this._rowCount >= endRow || this._doneParsing === true) {\n            return;\n        }\n        // Compute the column count if we don't already have it.\n        if (this._columnCount === undefined) {\n            // Get number of columns in first row\n            this._columnCount = PARSERS[this._parser]({\n                data: this._rawData,\n                delimiter: this._delimiter,\n                rowDelimiter: this._rowDelimiter,\n                quote: this._quote,\n                columnOffsets: true,\n                maxRows: 1\n            }).ncols;\n        }\n        // `reparse` is the number of rows we are requesting to parse over again.\n        // We generally start at the beginning of the last row offset, so that the\n        // first row offset returned is the same as the last row offset we already\n        // have. We parse the data up to and including the requested row.\n        const reparse = this._rowCount > 0 ? 1 : 0;\n        const { nrows, offsets } = PARSERS[this._parser]({\n            data: this._rawData,\n            startIndex: (_a = this._rowOffsets[this._rowCount - reparse]) !== null && _a !== void 0 ? _a : 0,\n            delimiter: this._delimiter,\n            rowDelimiter: this._rowDelimiter,\n            quote: this._quote,\n            columnOffsets: false,\n            maxRows: endRow - this._rowCount + reparse\n        });\n        // If we have already set up our initial bookkeeping, return early if we\n        // did not get any new rows beyond the last row that we've parsed, i.e.,\n        // nrows===1.\n        if (this._startedParsing && nrows <= reparse) {\n            this._doneParsing = true;\n            this._ready.resolve(undefined);\n            return;\n        }\n        this._startedParsing = true;\n        // Update the row count, accounting for how many rows were reparsed.\n        const oldRowCount = this._rowCount;\n        const duplicateRows = Math.min(nrows, reparse);\n        this._rowCount = oldRowCount + nrows - duplicateRows;\n        // If we didn't reach the requested row, we must be done.\n        if (this._rowCount < endRow) {\n            this._doneParsing = true;\n            this._ready.resolve(undefined);\n        }\n        // Copy the new offsets into a new row offset array if needed.\n        if (this._rowCount > oldRowCount) {\n            const oldRowOffsets = this._rowOffsets;\n            this._rowOffsets = new Uint32Array(this._rowCount);\n            this._rowOffsets.set(oldRowOffsets);\n            this._rowOffsets.set(offsets, oldRowCount - duplicateRows);\n        }\n        // Expand the column offsets array if needed\n        // If the full column offsets array is small enough, build a cache big\n        // enough for all column offsets. We allocate up to 128 megabytes:\n        // 128*(2**20 bytes/M)/(4 bytes/entry) = 33554432 entries.\n        const maxColumnOffsetsRows = Math.floor(33554432 / this._columnCount);\n        // We need to expand the column offset array if we were storing all column\n        // offsets before. Check to see if the previous size was small enough that\n        // we stored all column offsets.\n        if (oldRowCount <= maxColumnOffsetsRows) {\n            // Check to see if the new column offsets array is small enough to still\n            // store, or if we should cut over to a small cache.\n            if (this._rowCount <= maxColumnOffsetsRows) {\n                // Expand the existing column offset array for new column offsets.\n                const oldColumnOffsets = this._columnOffsets;\n                this._columnOffsets = new Uint32Array(this._rowCount * this._columnCount);\n                this._columnOffsets.set(oldColumnOffsets);\n                this._columnOffsets.fill(0xffffffff, oldColumnOffsets.length);\n            }\n            else {\n                // If not, then our cache size is at most the maximum number of rows we\n                // fill in the cache at a time.\n                const oldColumnOffsets = this._columnOffsets;\n                this._columnOffsets = new Uint32Array(Math.min(this._maxCacheGet, maxColumnOffsetsRows) * this._columnCount);\n                // Fill in the entries we already have.\n                this._columnOffsets.set(oldColumnOffsets.subarray(0, this._columnOffsets.length));\n                // Invalidate the rest of the entries.\n                this._columnOffsets.fill(0xffffffff, oldColumnOffsets.length);\n                this._columnOffsetsStartingRow = 0;\n            }\n        }\n        // We have more rows than before, so emit the rows-inserted change signal.\n        let firstIndex = oldRowCount;\n        if (this._header.length > 0) {\n            firstIndex -= 1;\n        }\n        this.emitChanged({\n            type: 'rows-inserted',\n            region: 'body',\n            index: firstIndex,\n            span: this._rowCount - oldRowCount\n        });\n    }\n    /**\n     * Get the parsed string field for a row and column.\n     *\n     * @param row - The row number of the data item.\n     * @param column - The column number of the data item.\n     * @returns The parsed string for the data item.\n     */\n    _getField(row, column) {\n        // Declare local variables.\n        let value;\n        let nextIndex;\n        // Find the index for the first character in the field.\n        const index = this.getOffsetIndex(row, column);\n        // Initialize the trim adjustments.\n        let trimRight = 0;\n        let trimLeft = 0;\n        // Find the end of the slice (the start of the next field), and how much we\n        // should adjust to trim off a trailing field or row delimiter. First check\n        // if we are getting the last column.\n        if (column === this._columnCount - 1) {\n            // Check if we are getting any row but the last.\n            if (row < this._rowCount - 1) {\n                // Set the next offset to the next row, column 0.\n                nextIndex = this.getOffsetIndex(row + 1, 0);\n                // Since we are not at the last row, we need to trim off the row\n                // delimiter.\n                trimRight += this._rowDelimiter.length;\n            }\n            else {\n                // We are getting the last data item, so the slice end is the end of the\n                // data string.\n                nextIndex = this._rawData.length;\n                // The string may or may not end in a row delimiter (RFC 4180 2.2), so\n                // we explicitly check if we should trim off a row delimiter.\n                if (this._rawData[nextIndex - 1] ===\n                    this._rowDelimiter[this._rowDelimiter.length - 1]) {\n                    trimRight += this._rowDelimiter.length;\n                }\n            }\n        }\n        else {\n            // The next field starts at the next column offset.\n            nextIndex = this.getOffsetIndex(row, column + 1);\n            // Trim off the delimiter if it exists at the end of the field\n            if (index < nextIndex &&\n                this._rawData[nextIndex - 1] === this._delimiter) {\n                trimRight += 1;\n            }\n        }\n        // Check to see if the field begins with a quote. If it does, trim a quote on either side.\n        if (this._rawData[index] === this._quote) {\n            trimLeft += 1;\n            trimRight += 1;\n        }\n        // Slice the actual value out of the data string.\n        value = this._rawData.slice(index + trimLeft, nextIndex - trimRight);\n        // If we have a quoted field and we have an escaped quote inside it, unescape it.\n        if (trimLeft === 1 && value.indexOf(this._quote) !== -1) {\n            value = value.replace(this._quoteEscaped, this._quote);\n        }\n        // Return the value.\n        return value;\n    }\n    /**\n     * Reset the parser state.\n     */\n    _resetParser() {\n        this._columnCount = undefined;\n        this._rowOffsets = new Uint32Array(0);\n        this._rowCount = 0;\n        this._startedParsing = false;\n        this._columnOffsets = new Uint32Array(0);\n        // Clear out state associated with the asynchronous parsing.\n        if (this._doneParsing === false) {\n            // Explicitly catch this rejection at least once so an error is not thrown\n            // to the console.\n            this.ready.catch(() => {\n                return;\n            });\n            this._ready.reject(undefined);\n        }\n        this._doneParsing = false;\n        this._ready = new PromiseDelegate();\n        if (this._delayedParse !== null) {\n            window.clearTimeout(this._delayedParse);\n            this._delayedParse = null;\n        }\n        this.emitChanged({ type: 'model-reset' });\n    }\n}\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * Possible parser states.\n */\nvar STATE;\n(function (STATE) {\n    STATE[STATE[\"QUOTED_FIELD\"] = 0] = \"QUOTED_FIELD\";\n    STATE[STATE[\"QUOTED_FIELD_QUOTE\"] = 1] = \"QUOTED_FIELD_QUOTE\";\n    STATE[STATE[\"UNQUOTED_FIELD\"] = 2] = \"UNQUOTED_FIELD\";\n    STATE[STATE[\"NEW_FIELD\"] = 3] = \"NEW_FIELD\";\n    STATE[STATE[\"NEW_ROW\"] = 4] = \"NEW_ROW\";\n})(STATE || (STATE = {}));\n/**\n * Possible row delimiters for the parser.\n */\nvar ROW_DELIMITER;\n(function (ROW_DELIMITER) {\n    ROW_DELIMITER[ROW_DELIMITER[\"CR\"] = 0] = \"CR\";\n    ROW_DELIMITER[ROW_DELIMITER[\"CRLF\"] = 1] = \"CRLF\";\n    ROW_DELIMITER[ROW_DELIMITER[\"LF\"] = 2] = \"LF\";\n})(ROW_DELIMITER || (ROW_DELIMITER = {}));\n/**\n * Parse delimiter-separated data.\n *\n * @param options: The parser options\n * @returns An object giving the offsets for the rows or columns parsed.\n *\n * #### Notes\n * This implementation is based on [RFC 4180](https://tools.ietf.org/html/rfc4180).\n */\nexport function parseDSV(options) {\n    const { data, columnOffsets, delimiter = ',', startIndex = 0, maxRows = 0xffffffff, rowDelimiter = '\\r\\n', quote = '\"' } = options;\n    // ncols will be set automatically if it is undefined.\n    let ncols = options.ncols;\n    // The number of rows we've already parsed.\n    let nrows = 0;\n    // The row or column offsets we return.\n    const offsets = [];\n    // Set up some useful local variables.\n    const CH_DELIMITER = delimiter.charCodeAt(0);\n    const CH_QUOTE = quote.charCodeAt(0);\n    const CH_LF = 10; // \\n\n    const CH_CR = 13; // \\r\n    const endIndex = data.length;\n    const { QUOTED_FIELD, QUOTED_FIELD_QUOTE, UNQUOTED_FIELD, NEW_FIELD, NEW_ROW } = STATE;\n    const { CR, LF, CRLF } = ROW_DELIMITER;\n    const [rowDelimiterCode, rowDelimiterLength] = rowDelimiter === '\\r\\n'\n        ? [CRLF, 2]\n        : rowDelimiter === '\\r'\n            ? [CR, 1]\n            : [LF, 1];\n    // Always start off at the beginning of a row.\n    let state = NEW_ROW;\n    // Set up the starting index.\n    let i = startIndex;\n    // We initialize to 0 just in case we are asked to parse past the end of the\n    // string. In that case, we want the number of columns to be 0.\n    let col = 0;\n    // Declare some useful temporaries\n    let char;\n    // Loop through the data string\n    while (i < endIndex) {\n        // i is the index of a character in the state.\n        // If we just hit a new row, and there are still characters left, push a new\n        // offset on and reset the column counter. We want this logic at the top of\n        // the while loop rather than the bottom because we don't want a trailing\n        // row delimiter at the end of the data to trigger a new row offset.\n        if (state === NEW_ROW) {\n            // Start a new row and reset the column counter.\n            offsets.push(i);\n            col = 1;\n        }\n        // Below, we handle this character, modify the parser state and increment the index to be consistent.\n        // Get the integer code for the current character, so the comparisons below\n        // are faster.\n        char = data.charCodeAt(i);\n        // Update the parser state. This switch statement is responsible for\n        // updating the state to be consistent with the index i+1 (we increment i\n        // after the switch statement). In some situations, we may increment i\n        // inside this loop to skip over indices as a shortcut.\n        switch (state) {\n            // At the beginning of a row or field, we can have a quote, row delimiter, or field delimiter.\n            case NEW_ROW:\n            case NEW_FIELD:\n                switch (char) {\n                    // If we have a quote, we are starting an escaped field.\n                    case CH_QUOTE:\n                        state = QUOTED_FIELD;\n                        break;\n                    // A field delimiter means we are starting a new field.\n                    case CH_DELIMITER:\n                        state = NEW_FIELD;\n                        break;\n                    // A row delimiter means we are starting a new row.\n                    case CH_CR:\n                        if (rowDelimiterCode === CR) {\n                            state = NEW_ROW;\n                        }\n                        else if (rowDelimiterCode === CRLF &&\n                            data.charCodeAt(i + 1) === CH_LF) {\n                            // If we see an expected \\r\\n, then increment to the end of the delimiter.\n                            i++;\n                            state = NEW_ROW;\n                        }\n                        else {\n                            throw `string index ${i} (in row ${nrows}, column ${col}): carriage return found, but not as part of a row delimiter C ${data.charCodeAt(i + 1)}`;\n                        }\n                        break;\n                    case CH_LF:\n                        if (rowDelimiterCode === LF) {\n                            state = NEW_ROW;\n                        }\n                        else {\n                            throw `string index ${i} (in row ${nrows}, column ${col}): line feed found, but row delimiter starts with a carriage return`;\n                        }\n                        break;\n                    // Otherwise, we are starting an unquoted field.\n                    default:\n                        state = UNQUOTED_FIELD;\n                        break;\n                }\n                break;\n            // We are in a quoted field.\n            case QUOTED_FIELD:\n                // Skip ahead until we see another quote, which either ends the quoted\n                // field or starts an escaped quote.\n                i = data.indexOf(quote, i);\n                if (i < 0) {\n                    throw `string index ${i} (in row ${nrows}, column ${col}): mismatched quote`;\n                }\n                state = QUOTED_FIELD_QUOTE;\n                break;\n            // We just saw a quote in a quoted field. This could be the end of the\n            // field, or it could be a repeated quote (i.e., an escaped quote according\n            // to RFC 4180).\n            case QUOTED_FIELD_QUOTE:\n                switch (char) {\n                    // Another quote means we just saw an escaped quote, so we are still in\n                    // the quoted field.\n                    case CH_QUOTE:\n                        state = QUOTED_FIELD;\n                        break;\n                    // A field or row delimiter means the quoted field just ended and we are\n                    // going into a new field or new row.\n                    case CH_DELIMITER:\n                        state = NEW_FIELD;\n                        break;\n                    // A row delimiter means we are starting a new row in the next index.\n                    case CH_CR:\n                        if (rowDelimiterCode === CR) {\n                            state = NEW_ROW;\n                        }\n                        else if (rowDelimiterCode === CRLF &&\n                            data.charCodeAt(i + 1) === CH_LF) {\n                            // If we see an expected \\r\\n, then increment to the end of the delimiter.\n                            i++;\n                            state = NEW_ROW;\n                        }\n                        else {\n                            throw `string index ${i} (in row ${nrows}, column ${col}): carriage return found, but not as part of a row delimiter C ${data.charCodeAt(i + 1)}`;\n                        }\n                        break;\n                    case CH_LF:\n                        if (rowDelimiterCode === LF) {\n                            state = NEW_ROW;\n                        }\n                        else {\n                            throw `string index ${i} (in row ${nrows}, column ${col}): line feed found, but row delimiter starts with a carriage return`;\n                        }\n                        break;\n                    default:\n                        throw `string index ${i} (in row ${nrows}, column ${col}): quote in escaped field not followed by quote, delimiter, or row delimiter`;\n                }\n                break;\n            // We are in an unquoted field, so the only thing we look for is the next\n            // row or field delimiter.\n            case UNQUOTED_FIELD:\n                // Skip ahead to either the next field delimiter or possible start of a\n                // row delimiter (CR or LF).\n                while (i < endIndex) {\n                    char = data.charCodeAt(i);\n                    if (char === CH_DELIMITER || char === CH_LF || char === CH_CR) {\n                        break;\n                    }\n                    i++;\n                }\n                // Process the character we're seeing in an unquoted field.\n                switch (char) {\n                    // A field delimiter means we are starting a new field.\n                    case CH_DELIMITER:\n                        state = NEW_FIELD;\n                        break;\n                    // A row delimiter means we are starting a new row in the next index.\n                    case CH_CR:\n                        if (rowDelimiterCode === CR) {\n                            state = NEW_ROW;\n                        }\n                        else if (rowDelimiterCode === CRLF &&\n                            data.charCodeAt(i + 1) === CH_LF) {\n                            // If we see an expected \\r\\n, then increment to the end of the delimiter.\n                            i++;\n                            state = NEW_ROW;\n                        }\n                        else {\n                            throw `string index ${i} (in row ${nrows}, column ${col}): carriage return found, but not as part of a row delimiter C ${data.charCodeAt(i + 1)}`;\n                        }\n                        break;\n                    case CH_LF:\n                        if (rowDelimiterCode === LF) {\n                            state = NEW_ROW;\n                        }\n                        else {\n                            throw `string index ${i} (in row ${nrows}, column ${col}): line feed found, but row delimiter starts with a carriage return`;\n                        }\n                        break;\n                    // Otherwise, we continue on in the unquoted field.\n                    default:\n                        continue;\n                }\n                break;\n            // We should never reach this point since the parser state is handled above,\n            // so throw an error if we do.\n            default:\n                throw `string index ${i} (in row ${nrows}, column ${col}): state not recognized`;\n        }\n        // Increment i to the next character index\n        i++;\n        // Update return values based on state.\n        switch (state) {\n            case NEW_ROW:\n                nrows++;\n                // If ncols is undefined, set it to the number of columns in this row (first row implied).\n                if (ncols === undefined) {\n                    if (nrows !== 1) {\n                        throw new Error('Error parsing default number of columns');\n                    }\n                    ncols = col;\n                }\n                // Pad or truncate the column offsets in the previous row if we are\n                // returning them.\n                if (columnOffsets === true) {\n                    if (col < ncols) {\n                        // We didn't have enough columns, so add some more column offsets that\n                        // point to just before the row delimiter we just saw.\n                        for (; col < ncols; col++) {\n                            offsets.push(i - rowDelimiterLength);\n                        }\n                    }\n                    else if (col > ncols) {\n                        // We had too many columns, so truncate them.\n                        offsets.length = offsets.length - (col - ncols);\n                    }\n                }\n                // Shortcut return if nrows reaches the maximum rows we are to parse.\n                if (nrows === maxRows) {\n                    return { nrows, ncols: columnOffsets ? ncols : 0, offsets };\n                }\n                break;\n            case NEW_FIELD:\n                // If we are returning column offsets, log the current index.\n                if (columnOffsets === true) {\n                    offsets.push(i);\n                }\n                // Update the column counter.\n                col++;\n                break;\n            default:\n                break;\n        }\n    }\n    // If we finished parsing and we are *not* in the NEW_ROW state, then do the\n    // column padding/truncation for the last row. Also make sure ncols is\n    // defined.\n    if (state !== NEW_ROW) {\n        nrows++;\n        if (columnOffsets === true) {\n            // If ncols is *still* undefined, then we only parsed one row and didn't\n            // have a newline, so set it to the number of columns we found.\n            if (ncols === undefined) {\n                ncols = col;\n            }\n            if (col < ncols) {\n                // We didn't have enough columns, so add some more column offsets that\n                // point to just before the row delimiter we just saw.\n                for (; col < ncols; col++) {\n                    offsets.push(i - (rowDelimiterLength - 1));\n                }\n            }\n            else if (col > ncols) {\n                // We had too many columns, so truncate them.\n                offsets.length = offsets.length - (col - ncols);\n            }\n        }\n    }\n    return { nrows, ncols: columnOffsets ? ncols !== null && ncols !== void 0 ? ncols : 0 : 0, offsets };\n}\n/**\n * Parse delimiter-separated data where no delimiter is quoted.\n *\n * @param options: The parser options\n * @returns An object giving the offsets for the rows or columns parsed.\n *\n * #### Notes\n * This function is an optimized parser for cases where there are no field or\n * row delimiters in quotes. Note that the data can have quotes, but they are\n * not interpreted in any special way. This implementation is based on [RFC\n * 4180](https://tools.ietf.org/html/rfc4180), but disregards quotes.\n */\nexport function parseDSVNoQuotes(options) {\n    // Set option defaults.\n    const { data, columnOffsets, delimiter = ',', rowDelimiter = '\\r\\n', startIndex = 0, maxRows = 0xffffffff } = options;\n    // ncols will be set automatically if it is undefined.\n    let ncols = options.ncols;\n    // Set up our return variables.\n    const offsets = [];\n    let nrows = 0;\n    // Set up various state variables.\n    const rowDelimiterLength = rowDelimiter.length;\n    let currRow = startIndex;\n    const len = data.length;\n    let nextRow;\n    let col;\n    let rowString;\n    let colIndex;\n    // The end of the current row.\n    let rowEnd;\n    // Start parsing at the start index.\n    nextRow = startIndex;\n    // Loop through rows until we run out of data or we've reached maxRows.\n    while (nextRow !== -1 && nrows < maxRows && currRow < len) {\n        // Store the offset for the beginning of the row and increment the rows.\n        offsets.push(currRow);\n        nrows++;\n        // Find the next row delimiter.\n        nextRow = data.indexOf(rowDelimiter, currRow);\n        // If the next row delimiter is not found, set the end of the row to the\n        // end of the data string.\n        rowEnd = nextRow === -1 ? len : nextRow;\n        // If we are returning column offsets, push them onto the array.\n        if (columnOffsets === true) {\n            // Find the next field delimiter. We slice the current row out so that\n            // the indexOf will stop at the end of the row. It may possibly be faster\n            // to just use a loop to check each character.\n            col = 1;\n            rowString = data.slice(currRow, rowEnd);\n            colIndex = rowString.indexOf(delimiter);\n            if (ncols === undefined) {\n                // If we don't know how many columns we need, loop through and find all\n                // of the field delimiters in this row.\n                while (colIndex !== -1) {\n                    offsets.push(currRow + colIndex + 1);\n                    col++;\n                    colIndex = rowString.indexOf(delimiter, colIndex + 1);\n                }\n                // Set ncols to the number of fields we found.\n                ncols = col;\n            }\n            else {\n                // If we know the number of columns we expect, find the field delimiters\n                // up to that many columns.\n                while (colIndex !== -1 && col < ncols) {\n                    offsets.push(currRow + colIndex + 1);\n                    col++;\n                    colIndex = rowString.indexOf(delimiter, colIndex + 1);\n                }\n                // If we didn't reach the number of columns we expected, pad the offsets\n                // with the offset just before the row delimiter.\n                while (col < ncols) {\n                    offsets.push(rowEnd);\n                    col++;\n                }\n            }\n        }\n        // Skip past the row delimiter at the end of the row.\n        currRow = rowEnd + rowDelimiterLength;\n    }\n    return { nrows, ncols: columnOffsets ? ncols !== null && ncols !== void 0 ? ncols : 0 : 0, offsets };\n}\n//# sourceMappingURL=parse.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Styling } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { each } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\n/**\n * The class name added to a csv toolbar widget.\n */\nconst CSV_DELIMITER_CLASS = 'jp-CSVDelimiter';\nconst CSV_DELIMITER_LABEL_CLASS = 'jp-CSVDelimiter-label';\n/**\n * The class name added to a csv toolbar's dropdown element.\n */\nconst CSV_DELIMITER_DROPDOWN_CLASS = 'jp-CSVDelimiter-dropdown';\n/**\n * A widget for selecting a delimiter.\n */\nexport class CSVDelimiter extends Widget {\n    /**\n     * Construct a new csv table widget.\n     */\n    constructor(options) {\n        super({ node: Private.createNode(options.selected, options.translator) });\n        this._delimiterChanged = new Signal(this);\n        this.addClass(CSV_DELIMITER_CLASS);\n    }\n    /**\n     * A signal emitted when the delimiter selection has changed.\n     */\n    get delimiterChanged() {\n        return this._delimiterChanged;\n    }\n    /**\n     * The delimiter dropdown menu.\n     */\n    get selectNode() {\n        return this.node.getElementsByTagName('select')[0];\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'change':\n                this._delimiterChanged.emit(this.selectNode.value);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        this.selectNode.addEventListener('change', this);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        this.selectNode.removeEventListener('change', this);\n    }\n}\n/**\n * A namespace for private toolbar methods.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Create the node for the delimiter switcher.\n     */\n    function createNode(selected, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator === null || translator === void 0 ? void 0 : translator.load('jupyterlab');\n        // The supported parsing delimiters and labels.\n        const delimiters = [\n            [',', ','],\n            [';', ';'],\n            ['\\t', trans.__('tab')],\n            ['|', trans.__('pipe')],\n            ['#', trans.__('hash')]\n        ];\n        const div = document.createElement('div');\n        const label = document.createElement('span');\n        const select = document.createElement('select');\n        label.textContent = trans.__('Delimiter: ');\n        label.className = CSV_DELIMITER_LABEL_CLASS;\n        each(delimiters, ([delimiter, label]) => {\n            const option = document.createElement('option');\n            option.value = delimiter;\n            option.textContent = label;\n            if (delimiter === selected) {\n                option.selected = true;\n            }\n            select.appendChild(option);\n        });\n        div.appendChild(label);\n        const node = Styling.wrapSelect(select);\n        node.classList.add(CSV_DELIMITER_DROPDOWN_CLASS);\n        div.appendChild(node);\n        return div;\n    }\n    Private.createNode = createNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=toolbar.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ActivityMonitor } from '@jupyterlab/coreutils';\nimport { ABCWidgetFactory, DocumentWidget } from '@jupyterlab/docregistry';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { BasicKeyHandler, BasicMouseHandler, BasicSelectionModel, DataGrid, TextRenderer } from '@lumino/datagrid';\nimport { Signal } from '@lumino/signaling';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { DSVModel } from './model';\nimport { CSVDelimiter } from './toolbar';\n/**\n * The class name added to a CSV viewer.\n */\nconst CSV_CLASS = 'jp-CSVViewer';\n/**\n * The class name added to a CSV viewer datagrid.\n */\nconst CSV_GRID_CLASS = 'jp-CSVViewer-grid';\n/**\n * The timeout to wait for change activity to have ceased before rendering.\n */\nconst RENDER_TIMEOUT = 1000;\n/**\n * Configuration for cells textrenderer.\n */\nexport class TextRenderConfig {\n}\n/**\n * Search service remembers the search state and the location of the last\n * match, for incremental searching.\n * Search service is also responsible of providing a cell renderer function\n * to set the background color of cells matching the search text.\n */\nexport class GridSearchService {\n    constructor(grid) {\n        this._looping = true;\n        this._changed = new Signal(this);\n        this._grid = grid;\n        this._query = null;\n        this._row = 0;\n        this._column = -1;\n    }\n    /**\n     * A signal fired when the grid changes.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Returns a cellrenderer config function to render each cell background.\n     * If cell match, background is matchBackgroundColor, if it's the current\n     * match, background is currentMatchBackgroundColor.\n     */\n    cellBackgroundColorRendererFunc(config) {\n        return ({ value, row, column }) => {\n            if (this._query) {\n                if (value.match(this._query)) {\n                    if (this._row === row && this._column === column) {\n                        return config.currentMatchBackgroundColor;\n                    }\n                    return config.matchBackgroundColor;\n                }\n            }\n            return '';\n        };\n    }\n    /**\n     * Clear the search.\n     */\n    clear() {\n        this._query = null;\n        this._row = 0;\n        this._column = -1;\n        this._changed.emit(undefined);\n    }\n    /**\n     * incrementally look for searchText.\n     */\n    find(query, reverse = false) {\n        const model = this._grid.dataModel;\n        const rowCount = model.rowCount('body');\n        const columnCount = model.columnCount('body');\n        if (this._query !== query) {\n            // reset search\n            this._row = 0;\n            this._column = -1;\n        }\n        this._query = query;\n        // check if the match is in current viewport\n        const minRow = this._grid.scrollY / this._grid.defaultSizes.rowHeight;\n        const maxRow = (this._grid.scrollY + this._grid.pageHeight) /\n            this._grid.defaultSizes.rowHeight;\n        const minColumn = this._grid.scrollX / this._grid.defaultSizes.columnHeaderHeight;\n        const maxColumn = (this._grid.scrollX + this._grid.pageWidth) /\n            this._grid.defaultSizes.columnHeaderHeight;\n        const isInViewport = (row, column) => {\n            return (row >= minRow &&\n                row <= maxRow &&\n                column >= minColumn &&\n                column <= maxColumn);\n        };\n        const increment = reverse ? -1 : 1;\n        this._column += increment;\n        for (let row = this._row; reverse ? row >= 0 : row < rowCount; row += increment) {\n            for (let col = this._column; reverse ? col >= 0 : col < columnCount; col += increment) {\n                const cellData = model.data('body', row, col);\n                if (cellData.match(query)) {\n                    // to update the background of matching cells.\n                    // TODO: we only really need to invalidate the previous and current\n                    // cell rects, not the entire grid.\n                    this._changed.emit(undefined);\n                    if (!isInViewport(row, col)) {\n                        this._grid.scrollToRow(row);\n                    }\n                    this._row = row;\n                    this._column = col;\n                    return true;\n                }\n            }\n            this._column = reverse ? columnCount - 1 : 0;\n        }\n        // We've finished searching all the way to the limits of the grid. If this\n        // is the first time through (looping is true), wrap the indices and search\n        // again. Otherwise, give up.\n        if (this._looping) {\n            this._looping = false;\n            this._row = reverse ? 0 : rowCount - 1;\n            this._wrapRows(reverse);\n            try {\n                return this.find(query, reverse);\n            }\n            finally {\n                this._looping = true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Wrap indices if needed to just before the start or just after the end.\n     */\n    _wrapRows(reverse = false) {\n        const model = this._grid.dataModel;\n        const rowCount = model.rowCount('body');\n        const columnCount = model.columnCount('body');\n        if (reverse && this._row <= 0) {\n            // if we are at the front, wrap to just past the end.\n            this._row = rowCount - 1;\n            this._column = columnCount;\n        }\n        else if (!reverse && this._row >= rowCount - 1) {\n            // if we are at the end, wrap to just before the front.\n            this._row = 0;\n            this._column = -1;\n        }\n    }\n    get query() {\n        return this._query;\n    }\n}\n/**\n * A viewer for CSV tables.\n */\nexport class CSVViewer extends Widget {\n    /**\n     * Construct a new CSV viewer.\n     */\n    constructor(options) {\n        super();\n        this._monitor = null;\n        this._delimiter = ',';\n        this._revealed = new PromiseDelegate();\n        this._baseRenderer = null;\n        const context = (this._context = options.context);\n        const layout = (this.layout = new PanelLayout());\n        this.addClass(CSV_CLASS);\n        this._grid = new DataGrid({\n            defaultSizes: {\n                rowHeight: 24,\n                columnWidth: 144,\n                rowHeaderWidth: 64,\n                columnHeaderHeight: 36\n            }\n        });\n        this._grid.addClass(CSV_GRID_CLASS);\n        this._grid.headerVisibility = 'all';\n        this._grid.keyHandler = new BasicKeyHandler();\n        this._grid.mouseHandler = new BasicMouseHandler();\n        this._grid.copyConfig = {\n            separator: '\\t',\n            format: DataGrid.copyFormatGeneric,\n            headers: 'all',\n            warningThreshold: 1e6\n        };\n        layout.addWidget(this._grid);\n        this._searchService = new GridSearchService(this._grid);\n        this._searchService.changed.connect(this._updateRenderer, this);\n        void this._context.ready.then(() => {\n            this._updateGrid();\n            this._revealed.resolve(undefined);\n            // Throttle the rendering rate of the widget.\n            this._monitor = new ActivityMonitor({\n                signal: context.model.contentChanged,\n                timeout: RENDER_TIMEOUT\n            });\n            this._monitor.activityStopped.connect(this._updateGrid, this);\n        });\n    }\n    /**\n     * The CSV widget's context.\n     */\n    get context() {\n        return this._context;\n    }\n    /**\n     * A promise that resolves when the csv viewer is ready to be revealed.\n     */\n    get revealed() {\n        return this._revealed.promise;\n    }\n    /**\n     * The delimiter for the file.\n     */\n    get delimiter() {\n        return this._delimiter;\n    }\n    set delimiter(value) {\n        if (value === this._delimiter) {\n            return;\n        }\n        this._delimiter = value;\n        this._updateGrid();\n    }\n    /**\n     * The style used by the data grid.\n     */\n    get style() {\n        return this._grid.style;\n    }\n    set style(value) {\n        this._grid.style = value;\n    }\n    /**\n     * The config used to create text renderer.\n     */\n    set rendererConfig(rendererConfig) {\n        this._baseRenderer = rendererConfig;\n        this._updateRenderer();\n    }\n    /**\n     * The search service\n     */\n    get searchService() {\n        return this._searchService;\n    }\n    /**\n     * Dispose of the resources used by the widget.\n     */\n    dispose() {\n        if (this._monitor) {\n            this._monitor.dispose();\n        }\n        super.dispose();\n    }\n    /**\n     * Go to line\n     */\n    goToLine(lineNumber) {\n        this._grid.scrollToRow(lineNumber);\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this.node.tabIndex = -1;\n        this.node.focus();\n    }\n    /**\n     * Create the model for the grid.\n     */\n    _updateGrid() {\n        const data = this._context.model.toString();\n        const delimiter = this._delimiter;\n        const oldModel = this._grid.dataModel;\n        const dataModel = (this._grid.dataModel = new DSVModel({\n            data,\n            delimiter\n        }));\n        this._grid.selectionModel = new BasicSelectionModel({ dataModel });\n        if (oldModel) {\n            oldModel.dispose();\n        }\n    }\n    /**\n     * Update the renderer for the grid.\n     */\n    _updateRenderer() {\n        if (this._baseRenderer === null) {\n            return;\n        }\n        const rendererConfig = this._baseRenderer;\n        const renderer = new TextRenderer({\n            textColor: rendererConfig.textColor,\n            horizontalAlignment: rendererConfig.horizontalAlignment,\n            backgroundColor: this._searchService.cellBackgroundColorRendererFunc(rendererConfig)\n        });\n        this._grid.cellRenderers.update({\n            body: renderer,\n            'column-header': renderer,\n            'corner-header': renderer,\n            'row-header': renderer\n        });\n    }\n}\n/**\n * A document widget for CSV content widgets.\n */\nexport class CSVDocumentWidget extends DocumentWidget {\n    constructor(options) {\n        let { content, context, delimiter, reveal } = options, other = __rest(options, [\"content\", \"context\", \"delimiter\", \"reveal\"]);\n        content = content || Private.createContent(context);\n        reveal = Promise.all([reveal, content.revealed]);\n        super(Object.assign({ content, context, reveal }, other));\n        if (delimiter) {\n            content.delimiter = delimiter;\n        }\n        const csvDelimiter = new CSVDelimiter({ selected: content.delimiter });\n        this.toolbar.addItem('delimiter', csvDelimiter);\n        csvDelimiter.delimiterChanged.connect((sender, delimiter) => {\n            content.delimiter = delimiter;\n        });\n    }\n    /**\n     * Set URI fragment identifier for rows\n     */\n    setFragment(fragment) {\n        const parseFragments = fragment.split('=');\n        // TODO: expand to allow columns and cells to be selected\n        // reference: https://tools.ietf.org/html/rfc7111#section-3\n        if (parseFragments[0] !== '#row') {\n            return;\n        }\n        // multiple rows, separated by semi-colons can be provided, we will just\n        // go to the top one\n        let topRow = parseFragments[1].split(';')[0];\n        // a range of rows can be provided, we will take the first value\n        topRow = topRow.split('-')[0];\n        // go to that row\n        void this.context.ready.then(() => {\n            this.content.goToLine(Number(topRow));\n        });\n    }\n}\nvar Private;\n(function (Private) {\n    function createContent(context) {\n        return new CSVViewer({ context });\n    }\n    Private.createContent = createContent;\n})(Private || (Private = {}));\n/**\n * A widget factory for CSV widgets.\n */\nexport class CSVViewerFactory extends ABCWidgetFactory {\n    /**\n     * Create a new widget given a context.\n     */\n    createNewWidget(context) {\n        const translator = this.translator;\n        return new CSVDocumentWidget({ context, translator });\n    }\n}\n/**\n * A widget factory for TSV widgets.\n */\nexport class TSVViewerFactory extends ABCWidgetFactory {\n    /**\n     * Create a new widget given a context.\n     */\n    createNewWidget(context) {\n        const delimiter = '\\t';\n        return new CSVDocumentWidget({\n            context,\n            delimiter,\n            translator: this.translator\n        });\n    }\n}\n//# sourceMappingURL=widget.js.map"],"sourceRoot":""}