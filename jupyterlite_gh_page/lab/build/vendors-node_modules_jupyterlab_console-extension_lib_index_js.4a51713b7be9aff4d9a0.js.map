{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console-extension/lib/foreign.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console-extension/lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACuD;AACe;AACP;AACT;AACA;AACtD;AACA;AACA;AACO;AACP;AACA,eAAe,gEAAe,EAAE,yEAAgB,EAAE,gEAAW;AAC7D,eAAe,iEAAe;AAC9B;AACA;AACA;AACA,iEAAe,OAAO,EAAC;AACvB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,4BAA4B,+DAAc;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAgB;AACzD;AACA;AACA,KAAK;AACL,CAAC,0BAA0B;AAC3B,mC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACsE;AACmE;AAChF;AACW;AACT;AACG;AACb;AACA;AACY;AACE;AACT;AACE;AACf;AACS;AACC;AACnB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,cAAc,gEAAe;AAC7B;AACA,QAAQ,6EAA4B;AACpC,QAAQ,mEAAe;AACvB,QAAQ,uEAAmB;AAC3B,QAAQ,yEAAgB;AACxB,QAAQ,iEAAW;AACnB;AACA;AACA,QAAQ,oEAAe;AACvB,QAAQ,wEAAmB;AAC3B,QAAQ,2DAAS;AACjB,QAAQ,iEAAe;AACvB,QAAQ,2DAAS;AACjB,QAAQ,+DAAU;AAClB,QAAQ,wEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6EAA4B;AAC1C,eAAe,mEAAe;AAC9B;AACA;AACA;AACA,mBAAmB,4EAA2B,EAAE,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAO;AAC1C,iEAAe,OAAO,EAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,6FAA6F,uEAAqB;AAClH;AACA,wBAAwB,+DAAa;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA,sDAAsD;AACtD;AACA,aAAa;AACb,6BAA6B,QAAQ,mFAAmF,0DAAU,GAAG,EAAE;AACvI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAa;AAC/C,gCAAgC,wEAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAW;AACnD;AACA;AACA;AACA,+BAA+B,sCAAsC,OAAO,EAAE;AAC9E;AACA;AACA;AACA;AACA,oCAAoC,gEAAgB,oBAAoB;AACxE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAY,gBAAgB;AACtD;AACA,yHAAyH;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAI;AACtC;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iFAAiF,KAAK;AACtF,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uDAAuD,mEAAW;AAClE;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAU;AAC7B;AACA;AACA,0BAA0B,qEAAmB,IAAI,mEAAiB;AAClE,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B,kBAAkB,EAAE;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAU;AACjC;AACA;AACA,8BAA8B,qEAAmB,IAAI,mEAAiB;AACtE,iBAAiB;AACjB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS,GAAG,IAAI,KAAK,eAAe;AACnF;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mCAAmC,QAAQ,6FAA6F;AACxI,SAAS;AACT;AACA;AACA;AACA,iC","file":"vendors-node_modules_jupyterlab_console-extension_lib_index_js.4a51713b7be9aff4d9a0.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ICommandPalette } from '@jupyterlab/apputils';\nimport { ForeignHandler, IConsoleTracker } from '@jupyterlab/console';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { AttachedProperty } from '@lumino/properties';\n/**\n * The console widget tracker provider.\n */\nexport const foreign = {\n    id: '@jupyterlab/console-extension:foreign',\n    requires: [IConsoleTracker, ISettingRegistry, ITranslator],\n    optional: [ICommandPalette],\n    activate: activateForeign,\n    autoStart: true\n};\nexport default foreign;\nfunction activateForeign(app, tracker, settingRegistry, translator, palette) {\n    const trans = translator.load('jupyterlab');\n    const { shell } = app;\n    tracker.widgetAdded.connect((sender, widget) => {\n        const console = widget.console;\n        const handler = new ForeignHandler({\n            sessionContext: console.sessionContext,\n            parent: console\n        });\n        Private.foreignHandlerProperty.set(console, handler);\n        // Property showAllKernelActivity configures foreign handler enabled on start.\n        void settingRegistry\n            .get('@jupyterlab/console-extension:tracker', 'showAllKernelActivity')\n            .then(({ composite }) => {\n            const showAllKernelActivity = composite;\n            handler.enabled = showAllKernelActivity;\n        });\n        console.disposed.connect(() => {\n            handler.dispose();\n        });\n    });\n    const { commands } = app;\n    const category = trans.__('Console');\n    const toggleShowAllActivity = 'console:toggle-show-all-kernel-activity';\n    // Get the current widget and activate unless the args specify otherwise.\n    function getCurrent(args) {\n        const widget = tracker.currentWidget;\n        const activate = args['activate'] !== false;\n        if (activate && widget) {\n            shell.activateById(widget.id);\n        }\n        return widget;\n    }\n    commands.addCommand(toggleShowAllActivity, {\n        label: args => trans.__('Show All Kernel Activity'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            const handler = Private.foreignHandlerProperty.get(current.console);\n            if (handler) {\n                handler.enabled = !handler.enabled;\n            }\n        },\n        isToggled: () => {\n            var _a;\n            return tracker.currentWidget !== null &&\n                !!((_a = Private.foreignHandlerProperty.get(tracker.currentWidget.console)) === null || _a === void 0 ? void 0 : _a.enabled);\n        },\n        isEnabled: () => tracker.currentWidget !== null &&\n            tracker.currentWidget === shell.currentWidget\n    });\n    if (palette) {\n        palette.addItem({\n            command: toggleShowAllActivity,\n            category,\n            args: { isPalette: true }\n        });\n    }\n}\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a console's foreign handler.\n     */\n    Private.foreignHandlerProperty = new AttachedProperty({\n        name: 'foreignHandler',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=foreign.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module console-extension\n */\nimport { ILabStatus, ILayoutRestorer } from '@jupyterlab/application';\nimport { Dialog, ICommandPalette, ISessionContextDialogs, sessionContextDialogs, showDialog, WidgetTracker } from '@jupyterlab/apputils';\nimport { IEditorServices } from '@jupyterlab/codeeditor';\nimport { ConsolePanel, IConsoleTracker } from '@jupyterlab/console';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { IFileBrowserFactory } from '@jupyterlab/filebrowser';\nimport { ILauncher } from '@jupyterlab/launcher';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { consoleIcon } from '@jupyterlab/ui-components';\nimport { find } from '@lumino/algorithm';\nimport { JSONExt, UUID } from '@lumino/coreutils';\nimport { DisposableSet } from '@lumino/disposable';\nimport foreign from './foreign';\n/**\n * The command IDs used by the console plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.autoClosingBrackets = 'console:toggle-autoclosing-brackets';\n    CommandIDs.create = 'console:create';\n    CommandIDs.clear = 'console:clear';\n    CommandIDs.runUnforced = 'console:run-unforced';\n    CommandIDs.runForced = 'console:run-forced';\n    CommandIDs.linebreak = 'console:linebreak';\n    CommandIDs.interrupt = 'console:interrupt-kernel';\n    CommandIDs.restart = 'console:restart-kernel';\n    CommandIDs.closeAndShutdown = 'console:close-and-shutdown';\n    CommandIDs.open = 'console:open';\n    CommandIDs.inject = 'console:inject';\n    CommandIDs.changeKernel = 'console:change-kernel';\n    CommandIDs.enterToExecute = 'console:enter-to-execute';\n    CommandIDs.shiftEnterToExecute = 'console:shift-enter-to-execute';\n    CommandIDs.interactionMode = 'console:interaction-mode';\n    CommandIDs.replaceSelection = 'console:replace-selection';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The console widget tracker provider.\n */\nconst tracker = {\n    id: '@jupyterlab/console-extension:tracker',\n    provides: IConsoleTracker,\n    requires: [\n        ConsolePanel.IContentFactory,\n        IEditorServices,\n        IRenderMimeRegistry,\n        ISettingRegistry,\n        ITranslator\n    ],\n    optional: [\n        ILayoutRestorer,\n        IFileBrowserFactory,\n        IMainMenu,\n        ICommandPalette,\n        ILauncher,\n        ILabStatus,\n        ISessionContextDialogs\n    ],\n    activate: activateConsole,\n    autoStart: true\n};\n/**\n * The console widget content factory.\n */\nconst factory = {\n    id: '@jupyterlab/console-extension:factory',\n    provides: ConsolePanel.IContentFactory,\n    requires: [IEditorServices],\n    autoStart: true,\n    activate: (app, editorServices) => {\n        const editorFactory = editorServices.factoryService.newInlineEditor;\n        return new ConsolePanel.ContentFactory({ editorFactory });\n    }\n};\n/**\n * Export the plugins as the default.\n */\nconst plugins = [factory, tracker, foreign];\nexport default plugins;\n/**\n * Activate the console extension.\n */\nasync function activateConsole(app, contentFactory, editorServices, rendermime, settingRegistry, translator, restorer, browserFactory, mainMenu, palette, launcher, status, sessionDialogs) {\n    const trans = translator.load('jupyterlab');\n    const manager = app.serviceManager;\n    const { commands, shell } = app;\n    const category = trans.__('Console');\n    sessionDialogs = sessionDialogs !== null && sessionDialogs !== void 0 ? sessionDialogs : sessionContextDialogs;\n    // Create a widget tracker for all console panels.\n    const tracker = new WidgetTracker({\n        namespace: 'console'\n    });\n    // Handle state restoration.\n    if (restorer) {\n        void restorer.restore(tracker, {\n            command: CommandIDs.create,\n            args: widget => {\n                const { path, name, kernelPreference } = widget.console.sessionContext;\n                return {\n                    path,\n                    name,\n                    kernelPreference: Object.assign({}, kernelPreference)\n                };\n            },\n            name: widget => { var _a; return (_a = widget.console.sessionContext.path) !== null && _a !== void 0 ? _a : UUID.uuid4(); },\n            when: manager.ready\n        });\n    }\n    // Add a launcher item if the launcher is available.\n    if (launcher) {\n        void manager.ready.then(() => {\n            let disposables = null;\n            const onSpecsChanged = () => {\n                if (disposables) {\n                    disposables.dispose();\n                    disposables = null;\n                }\n                const specs = manager.kernelspecs.specs;\n                if (!specs) {\n                    return;\n                }\n                disposables = new DisposableSet();\n                const baseUrl = PageConfig.getBaseUrl();\n                for (const name in specs.kernelspecs) {\n                    const rank = name === specs.default ? 0 : Infinity;\n                    const spec = specs.kernelspecs[name];\n                    let kernelIconUrl = spec.resources['logo-64x64'];\n                    if (kernelIconUrl) {\n                        const index = kernelIconUrl.indexOf('kernelspecs');\n                        kernelIconUrl = URLExt.join(baseUrl, kernelIconUrl.slice(index));\n                    }\n                    disposables.add(launcher.add({\n                        command: CommandIDs.create,\n                        args: { isLauncher: true, kernelPreference: { name } },\n                        category: trans.__('Console'),\n                        rank,\n                        kernelIconUrl,\n                        metadata: {\n                            kernel: JSONExt.deepCopy(spec.metadata || {})\n                        }\n                    }));\n                }\n            };\n            onSpecsChanged();\n            manager.kernelspecs.specsChanged.connect(onSpecsChanged);\n        });\n    }\n    /**\n     * Create a console for a given path.\n     */\n    async function createConsole(options) {\n        var _a;\n        await manager.ready;\n        const panel = new ConsolePanel(Object.assign({ manager,\n            contentFactory, mimeTypeService: editorServices.mimeTypeService, rendermime,\n            translator, setBusy: (_a = (status && (() => status.setBusy()))) !== null && _a !== void 0 ? _a : undefined }, options));\n        const interactionMode = (await settingRegistry.get('@jupyterlab/console-extension:tracker', 'interactionMode')).composite;\n        panel.console.node.dataset.jpInteractionMode = interactionMode;\n        // Add the console panel to the tracker. We want the panel to show up before\n        // any kernel selection dialog, so we do not await panel.session.ready;\n        await tracker.add(panel);\n        panel.sessionContext.propertyChanged.connect(() => {\n            void tracker.save(panel);\n        });\n        shell.add(panel, 'main', {\n            ref: options.ref,\n            mode: options.insertMode,\n            activate: options.activate !== false\n        });\n        return panel;\n    }\n    const mapOption = (editor, config, option) => {\n        if (config[option] === undefined) {\n            return;\n        }\n        switch (option) {\n            case 'autoClosingBrackets':\n                editor.setOption('autoClosingBrackets', config['autoClosingBrackets']);\n                break;\n            case 'cursorBlinkRate':\n                editor.setOption('cursorBlinkRate', config['cursorBlinkRate']);\n                break;\n            case 'fontFamily':\n                editor.setOption('fontFamily', config['fontFamily']);\n                break;\n            case 'fontSize':\n                editor.setOption('fontSize', config['fontSize']);\n                break;\n            case 'lineHeight':\n                editor.setOption('lineHeight', config['lineHeight']);\n                break;\n            case 'lineNumbers':\n                editor.setOption('lineNumbers', config['lineNumbers']);\n                break;\n            case 'lineWrap':\n                editor.setOption('lineWrap', config['lineWrap']);\n                break;\n            case 'matchBrackets':\n                editor.setOption('matchBrackets', config['matchBrackets']);\n                break;\n            case 'readOnly':\n                editor.setOption('readOnly', config['readOnly']);\n                break;\n            case 'insertSpaces':\n                editor.setOption('insertSpaces', config['insertSpaces']);\n                break;\n            case 'tabSize':\n                editor.setOption('tabSize', config['tabSize']);\n                break;\n            case 'wordWrapColumn':\n                editor.setOption('wordWrapColumn', config['wordWrapColumn']);\n                break;\n            case 'rulers':\n                editor.setOption('rulers', config['rulers']);\n                break;\n            case 'codeFolding':\n                editor.setOption('codeFolding', config['codeFolding']);\n                break;\n        }\n    };\n    const setOption = (editor, config) => {\n        if (editor === undefined) {\n            return;\n        }\n        mapOption(editor, config, 'autoClosingBrackets');\n        mapOption(editor, config, 'cursorBlinkRate');\n        mapOption(editor, config, 'fontFamily');\n        mapOption(editor, config, 'fontSize');\n        mapOption(editor, config, 'lineHeight');\n        mapOption(editor, config, 'lineNumbers');\n        mapOption(editor, config, 'lineWrap');\n        mapOption(editor, config, 'matchBrackets');\n        mapOption(editor, config, 'readOnly');\n        mapOption(editor, config, 'insertSpaces');\n        mapOption(editor, config, 'tabSize');\n        mapOption(editor, config, 'wordWrapColumn');\n        mapOption(editor, config, 'rulers');\n        mapOption(editor, config, 'codeFolding');\n    };\n    const pluginId = '@jupyterlab/console-extension:tracker';\n    let interactionMode;\n    let promptCellConfig;\n    async function updateSettings() {\n        interactionMode = (await settingRegistry.get(pluginId, 'interactionMode'))\n            .composite;\n        promptCellConfig = (await settingRegistry.get(pluginId, 'promptCellConfig'))\n            .composite;\n        tracker.forEach(widget => {\n            var _a;\n            widget.console.node.dataset.jpInteractionMode = interactionMode;\n            setOption((_a = widget.console.promptCell) === null || _a === void 0 ? void 0 : _a.editor, promptCellConfig);\n        });\n    }\n    settingRegistry.pluginChanged.connect((sender, plugin) => {\n        if (plugin === pluginId) {\n            void updateSettings();\n        }\n    });\n    await updateSettings();\n    commands.addCommand(CommandIDs.autoClosingBrackets, {\n        execute: async (args) => {\n            var _a;\n            promptCellConfig.autoClosingBrackets = !!((_a = args['force']) !== null && _a !== void 0 ? _a : !promptCellConfig.autoClosingBrackets);\n            await settingRegistry.set(pluginId, 'promptCellConfig', promptCellConfig);\n        },\n        label: trans.__('Auto Close Brackets for Code Console Prompt'),\n        isToggled: () => promptCellConfig.autoClosingBrackets\n    });\n    /**\n     * Whether there is an active console.\n     */\n    function isEnabled() {\n        return (tracker.currentWidget !== null &&\n            tracker.currentWidget === shell.currentWidget);\n    }\n    let command = CommandIDs.open;\n    commands.addCommand(command, {\n        execute: (args) => {\n            const path = args['path'];\n            const widget = tracker.find(value => {\n                var _a;\n                return ((_a = value.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path) === path;\n            });\n            if (widget) {\n                if (args.activate !== false) {\n                    shell.activateById(widget.id);\n                }\n                return widget;\n            }\n            else {\n                return manager.ready.then(() => {\n                    const model = find(manager.sessions.running(), item => {\n                        return item.path === path;\n                    });\n                    if (model) {\n                        return createConsole(args);\n                    }\n                    return Promise.reject(`No running kernel session for path: ${path}`);\n                });\n            }\n        }\n    });\n    command = CommandIDs.create;\n    commands.addCommand(command, {\n        label: args => {\n            var _a, _b, _c, _d;\n            if (args['isPalette']) {\n                return trans.__('New Console');\n            }\n            else if (args['isLauncher'] && args['kernelPreference']) {\n                const kernelPreference = args['kernelPreference'];\n                // TODO: Lumino command functions should probably be allowed to return undefined?\n                return ((_d = (_c = (_b = (_a = manager.kernelspecs) === null || _a === void 0 ? void 0 : _a.specs) === null || _b === void 0 ? void 0 : _b.kernelspecs[kernelPreference.name || '']) === null || _c === void 0 ? void 0 : _c.display_name) !== null && _d !== void 0 ? _d : '');\n            }\n            return trans.__('Console');\n        },\n        icon: args => (args['isPalette'] ? undefined : consoleIcon),\n        execute: args => {\n            var _a;\n            const basePath = (_a = (args['basePath'] ||\n                args['cwd'] || (browserFactory === null || browserFactory === void 0 ? void 0 : browserFactory.defaultBrowser.model.path))) !== null && _a !== void 0 ? _a : '';\n            return createConsole(Object.assign({ basePath }, args));\n        }\n    });\n    // Get the current widget and activate unless the args specify otherwise.\n    function getCurrent(args) {\n        const widget = tracker.currentWidget;\n        const activate = args['activate'] !== false;\n        if (activate && widget) {\n            shell.activateById(widget.id);\n        }\n        return widget !== null && widget !== void 0 ? widget : null;\n    }\n    commands.addCommand(CommandIDs.clear, {\n        label: trans.__('Clear Console Cells'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            current.console.clear();\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.runUnforced, {\n        label: trans.__('Run Cell (unforced)'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            return current.console.execute();\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.runForced, {\n        label: trans.__('Run Cell (forced)'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            return current.console.execute(true);\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.linebreak, {\n        label: trans.__('Insert Line Break'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            current.console.insertLinebreak();\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.replaceSelection, {\n        label: trans.__('Replace Selection in Console'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            const text = args['text'] || '';\n            current.console.replaceSelection(text);\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.interrupt, {\n        label: trans.__('Interrupt Kernel'),\n        execute: args => {\n            var _a;\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            const kernel = (_a = current.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n            if (kernel) {\n                return kernel.interrupt();\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.restart, {\n        label: trans.__('Restart Kernel…'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            return sessionDialogs.restart(current.console.sessionContext, translator);\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.closeAndShutdown, {\n        label: trans.__('Close and Shut Down…'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            return showDialog({\n                title: trans.__('Shut down the console?'),\n                body: trans.__('Are you sure you want to close \"%1\"?', current.title.label),\n                buttons: [Dialog.cancelButton(), Dialog.warnButton()]\n            }).then(result => {\n                if (result.button.accept) {\n                    return current.console.sessionContext.shutdown().then(() => {\n                        current.dispose();\n                        return true;\n                    });\n                }\n                else {\n                    return false;\n                }\n            });\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.inject, {\n        execute: args => {\n            const path = args['path'];\n            tracker.find(widget => {\n                var _a;\n                if (((_a = widget.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path) === path) {\n                    if (args['activate'] !== false) {\n                        shell.activateById(widget.id);\n                    }\n                    void widget.console.inject(args['code'], args['metadata']);\n                    return true;\n                }\n                return false;\n            });\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.changeKernel, {\n        label: trans.__('Change Kernel…'),\n        execute: args => {\n            const current = getCurrent(args);\n            if (!current) {\n                return;\n            }\n            return sessionDialogs.selectKernel(current.console.sessionContext, translator);\n        },\n        isEnabled\n    });\n    if (palette) {\n        // Add command palette items\n        [\n            CommandIDs.create,\n            CommandIDs.linebreak,\n            CommandIDs.clear,\n            CommandIDs.runUnforced,\n            CommandIDs.runForced,\n            CommandIDs.restart,\n            CommandIDs.interrupt,\n            CommandIDs.changeKernel,\n            CommandIDs.closeAndShutdown\n        ].forEach(command => {\n            palette.addItem({ command, category, args: { isPalette: true } });\n        });\n    }\n    if (mainMenu) {\n        // Add a close and shutdown command to the file menu.\n        mainMenu.fileMenu.closeAndCleaners.add({\n            tracker,\n            closeAndCleanupLabel: (n) => trans.__('Shutdown Console'),\n            closeAndCleanup: (current) => {\n                return showDialog({\n                    title: trans.__('Shut down the Console?'),\n                    body: trans.__('Are you sure you want to close \"%1\"?', current.title.label),\n                    buttons: [Dialog.cancelButton(), Dialog.warnButton()]\n                }).then(result => {\n                    if (result.button.accept) {\n                        return current.console.sessionContext.shutdown().then(() => {\n                            current.dispose();\n                        });\n                    }\n                    else {\n                        return void 0;\n                    }\n                });\n            }\n        });\n        // Add a kernel user to the Kernel menu\n        mainMenu.kernelMenu.kernelUsers.add({\n            tracker,\n            restartKernelAndClearLabel: n => trans.__('Restart Kernel and Clear Console'),\n            interruptKernel: current => {\n                var _a;\n                const kernel = (_a = current.console.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n                if (kernel) {\n                    return kernel.interrupt();\n                }\n                return Promise.resolve(void 0);\n            },\n            restartKernel: current => sessionDialogs.restart(current.console.sessionContext, translator),\n            restartKernelAndClear: current => {\n                return sessionDialogs\n                    .restart(current.console.sessionContext)\n                    .then(restarted => {\n                    if (restarted) {\n                        current.console.clear();\n                    }\n                    return restarted;\n                });\n            },\n            changeKernel: current => sessionDialogs.selectKernel(current.console.sessionContext, translator),\n            shutdownKernel: current => current.console.sessionContext.shutdown()\n        });\n        // Add a code runner to the Run menu.\n        mainMenu.runMenu.codeRunners.add({\n            tracker,\n            runLabel: (n) => trans.__('Run Cell'),\n            run: current => current.console.execute(true)\n        });\n        // Add a clearer to the edit menu\n        mainMenu.editMenu.clearers.add({\n            tracker,\n            clearCurrentLabel: (n) => trans.__('Clear Console Cell'),\n            clearCurrent: (current) => {\n                return current.console.clear();\n            }\n        });\n    }\n    // For backwards compatibility and clarity, we explicitly label the run\n    // keystroke with the actual effected change, rather than the generic\n    // \"notebook\" or \"terminal\" interaction mode. When this interaction mode\n    // affects more than just the run keystroke, we can make this menu title more\n    // generic.\n    const runShortcutTitles = {\n        notebook: trans.__('Execute with Shift+Enter'),\n        terminal: trans.__('Execute with Enter')\n    };\n    // Add the execute keystroke setting submenu.\n    commands.addCommand(CommandIDs.interactionMode, {\n        label: args => runShortcutTitles[args['interactionMode']] || '',\n        execute: async (args) => {\n            const key = 'keyMap';\n            try {\n                await settingRegistry.set(pluginId, 'interactionMode', args['interactionMode']);\n            }\n            catch (reason) {\n                console.error(`Failed to set ${pluginId}:${key} - ${reason.message}`);\n            }\n        },\n        isToggled: args => args['interactionMode'] === interactionMode\n    });\n    if (mainMenu) {\n        // Add kernel information to the application help menu.\n        mainMenu.helpMenu.kernelUsers.add({\n            tracker,\n            getKernel: current => { var _a; return (_a = current.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel; }\n        });\n    }\n    return tracker;\n}\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}