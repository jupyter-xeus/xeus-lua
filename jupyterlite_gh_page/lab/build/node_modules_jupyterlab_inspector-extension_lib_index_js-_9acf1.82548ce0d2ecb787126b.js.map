{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector-extension/lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACqE;AACiB;AAChC;AACiD;AACtD;AACO;AACF;AACI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B,eAAe,iEAAe,EAAE,2DAAS,EAAE,oEAAe;AAC1D,cAAc,6DAAU;AACxB;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,4BAA4B,+DAAa;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAc;AAC9C,iCAAiC,iEAAc,EAAE,aAAa;AAC9D,iBAAiB;AACjB;AACA;AACA,uCAAuC,oEAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uCAAuC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oEAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA,0BAA0B,iBAAiB,mBAAmB,EAAE;AAChE;AACA;AACA;AACA,4CAA4C,mCAAmC;AAC/E;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAU,EAAE,gEAAe,EAAE,8DAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAe,EAAE,iBAAiB;AACpE,gCAAgC,oEAAiB,EAAE,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAU,EAAE,kEAAgB,EAAE,8DAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAe,EAAE,iBAAiB;AACpE,gCAAgC,oEAAiB,EAAE,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;AACvB,iC","file":"node_modules_jupyterlab_inspector-extension_lib_index_js-_9acf1.82548ce0d2ecb787126b.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module inspector-extension\n */\nimport { ILabShell, ILayoutRestorer } from '@jupyterlab/application';\nimport { ICommandPalette, MainAreaWidget, WidgetTracker } from '@jupyterlab/apputils';\nimport { IConsoleTracker } from '@jupyterlab/console';\nimport { IInspector, InspectionHandler, InspectorPanel, KernelConnector } from '@jupyterlab/inspector';\nimport { ILauncher } from '@jupyterlab/launcher';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { inspectorIcon } from '@jupyterlab/ui-components';\n/**\n * The command IDs used by the inspector plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.open = 'inspector:open';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A service providing code introspection.\n */\nconst inspector = {\n    id: '@jupyterlab/inspector-extension:inspector',\n    requires: [ITranslator],\n    optional: [ICommandPalette, ILauncher, ILayoutRestorer],\n    provides: IInspector,\n    autoStart: true,\n    activate: (app, translator, palette, launcher, restorer) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const command = CommandIDs.open;\n        const label = trans.__('Show Contextual Help');\n        const namespace = 'inspector';\n        const tracker = new WidgetTracker({\n            namespace\n        });\n        function isInspectorOpen() {\n            return inspector && !inspector.isDisposed;\n        }\n        let source = null;\n        let inspector;\n        function openInspector(args) {\n            var _a;\n            if (!isInspectorOpen()) {\n                inspector = new MainAreaWidget({\n                    content: new InspectorPanel({ translator })\n                });\n                inspector.id = 'jp-inspector';\n                inspector.title.label = label;\n                inspector.title.icon = inspectorIcon;\n                void tracker.add(inspector);\n                source = source && !source.isDisposed ? source : null;\n                inspector.content.source = source;\n                (_a = inspector.content.source) === null || _a === void 0 ? void 0 : _a.onEditorChange(args);\n            }\n            if (!inspector.isAttached) {\n                shell.add(inspector, 'main', { activate: false, mode: 'split-right' });\n            }\n            shell.activateById(inspector.id);\n            return inspector;\n        }\n        // Add command to registry.\n        commands.addCommand(command, {\n            caption: trans.__('Live updating code documentation from the active kernel'),\n            isEnabled: () => !inspector ||\n                inspector.isDisposed ||\n                !inspector.isAttached ||\n                !inspector.isVisible,\n            label,\n            icon: args => (args.isLauncher ? inspectorIcon : undefined),\n            execute: args => {\n                var _a;\n                const text = args && args.text;\n                const refresh = args && args.refresh;\n                // if inspector is open, see if we need a refresh\n                if (isInspectorOpen() && refresh)\n                    (_a = inspector.content.source) === null || _a === void 0 ? void 0 : _a.onEditorChange(text);\n                else\n                    openInspector(text);\n            }\n        });\n        // Add command to UI where possible.\n        if (palette) {\n            palette.addItem({ command, category: label });\n        }\n        if (launcher) {\n            launcher.add({ command, args: { isLauncher: true } });\n        }\n        // Handle state restoration.\n        if (restorer) {\n            void restorer.restore(tracker, { command, name: () => 'inspector' });\n        }\n        // Create a proxy to pass the `source` to the current inspector.\n        const proxy = Object.defineProperty({}, 'source', {\n            get: () => !inspector || inspector.isDisposed ? null : inspector.content.source,\n            set: (src) => {\n                source = src && !src.isDisposed ? src : null;\n                if (inspector && !inspector.isDisposed) {\n                    inspector.content.source = source;\n                }\n            }\n        });\n        return proxy;\n    }\n};\n/**\n * An extension that registers consoles for inspection.\n */\nconst consoles = {\n    id: '@jupyterlab/inspector-extension:consoles',\n    requires: [IInspector, IConsoleTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, consoles, labShell, translator) => {\n        // Maintain association of new consoles with their respective handlers.\n        const handlers = {};\n        // Create a handler for each console that is created.\n        consoles.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.console.sessionContext;\n            const rendermime = parent.console.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.console.promptCell;\n            handler.editor = cell && cell.editor;\n            // Listen for prompt creation.\n            parent.console.promptCellCreated.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of console instances and set inspector source.\n        labShell.currentChanged.connect((_, args) => {\n            const widget = args.newValue;\n            if (!widget || !consoles.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n    }\n};\n/**\n * An extension that registers notebooks for inspection.\n */\nconst notebooks = {\n    id: '@jupyterlab/inspector-extension:notebooks',\n    requires: [IInspector, INotebookTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, notebooks, labShell) => {\n        // Maintain association of new notebooks with their respective handlers.\n        const handlers = {};\n        // Create a handler for each notebook that is created.\n        notebooks.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.sessionContext;\n            const rendermime = parent.content.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.content.activeCell;\n            handler.editor = cell && cell.editor;\n            // Listen for active cell changes.\n            parent.content.activeCellChanged.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of notebook instances and set inspector source.\n        labShell.currentChanged.connect((sender, args) => {\n            const widget = args.newValue;\n            if (!widget || !notebooks.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [inspector, consoles, notebooks];\nexport default plugins;\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}