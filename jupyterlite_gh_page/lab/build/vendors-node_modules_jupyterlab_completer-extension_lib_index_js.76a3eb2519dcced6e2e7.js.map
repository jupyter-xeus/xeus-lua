{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/completer-extension/lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACgJ;AAC1F;AACE;AACA;AACN;AACT;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qEAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+CAA+C,4EAAyB;AACxE,uBAAuB,4BAA4B;AACnD,kCAAkC,iEAAc;AAChD,sCAAsC,4DAAS,EAAE,0BAA0B;AAC3E,oCAAoC,oEAAiB;AACrD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAkB,EAAE,gEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAmB,EAAE,kBAAkB;AACzE,8CAA8C,oCAAoC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAAmB,EAAE,kBAAkB;AAC/E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAkB,EAAE,kEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAmB,EAAE,kBAAkB;AACzE,8CAA8C,mCAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAAmB,EAAE,kBAAkB;AAC/E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAkB,EAAE,kEAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAAgB,EAAE,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE,4CAA4C,sEAAmB,EAAE,kBAAkB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;AACvB,iC","file":"vendors-node_modules_jupyterlab_completer-extension_lib_index_js.76a3eb2519dcced6e2e7.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module completer-extension\n */\nimport { Completer, CompleterModel, CompletionConnector, CompletionHandler, ContextConnector, ICompletionManager } from '@jupyterlab/completer';\nimport { IConsoleTracker } from '@jupyterlab/console';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { find, toArray } from '@lumino/algorithm';\nimport { Widget } from '@lumino/widgets';\n/**\n * The command IDs used by the completer plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.invoke = 'completer:invoke';\n    CommandIDs.invokeConsole = 'completer:invoke-console';\n    CommandIDs.invokeNotebook = 'completer:invoke-notebook';\n    CommandIDs.invokeFile = 'completer:invoke-file';\n    CommandIDs.select = 'completer:select';\n    CommandIDs.selectConsole = 'completer:select-console';\n    CommandIDs.selectNotebook = 'completer:select-notebook';\n    CommandIDs.selectFile = 'completer:select-file';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A plugin providing code completion for editors.\n */\nconst manager = {\n    id: '@jupyterlab/completer-extension:manager',\n    autoStart: true,\n    provides: ICompletionManager,\n    activate: (app) => {\n        const handlers = {};\n        app.commands.addCommand(CommandIDs.invoke, {\n            execute: args => {\n                const id = args && args['id'];\n                if (!id) {\n                    return;\n                }\n                const handler = handlers[id];\n                if (handler) {\n                    handler.invoke();\n                }\n            }\n        });\n        app.commands.addCommand(CommandIDs.select, {\n            execute: args => {\n                const id = args && args['id'];\n                if (!id) {\n                    return;\n                }\n                const handler = handlers[id];\n                if (handler) {\n                    handler.completer.selectActive();\n                }\n            }\n        });\n        return {\n            register: (completable, renderer = Completer.defaultRenderer) => {\n                const { connector, editor, parent } = completable;\n                const model = new CompleterModel();\n                const completer = new Completer({ editor, model, renderer });\n                const handler = new CompletionHandler({\n                    completer,\n                    connector\n                });\n                const id = parent.id;\n                // Hide the widget when it first loads.\n                completer.hide();\n                // Associate the handler with the parent widget.\n                handlers[id] = handler;\n                // Set the handler's editor.\n                handler.editor = editor;\n                // Attach the completer widget.\n                Widget.attach(completer, document.body);\n                // Listen for parent disposal.\n                parent.disposed.connect(() => {\n                    delete handlers[id];\n                    model.dispose();\n                    completer.dispose();\n                    handler.dispose();\n                });\n                return handler;\n            }\n        };\n    }\n};\n/**\n * An extension that registers consoles for code completion.\n */\nconst consoles = {\n    id: '@jupyterlab/completer-extension:consoles',\n    requires: [ICompletionManager, IConsoleTracker],\n    autoStart: true,\n    activate: (app, manager, consoles) => {\n        // Create a handler for each console that is created.\n        consoles.widgetAdded.connect((sender, widget) => {\n            var _a, _b;\n            const anchor = widget.console;\n            const editor = (_b = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n            const session = anchor.sessionContext.session;\n            // TODO: CompletionConnector assumes editor and session are not null\n            const connector = new CompletionConnector({ session, editor });\n            const handler = manager.register({ connector, editor, parent: widget });\n            const updateConnector = () => {\n                var _a, _b;\n                const editor = (_b = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                const session = anchor.sessionContext.session;\n                handler.editor = editor;\n                // TODO: CompletionConnector assumes editor and session are not null\n                handler.connector = new CompletionConnector({ session, editor });\n            };\n            // Update the handler whenever the prompt or session changes\n            anchor.promptCellCreated.connect(updateConnector);\n            anchor.sessionContext.sessionChanged.connect(updateConnector);\n        });\n        // Add console completer invoke command.\n        app.commands.addCommand(CommandIDs.invokeConsole, {\n            execute: () => {\n                const id = consoles.currentWidget && consoles.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.invoke, { id });\n                }\n            }\n        });\n        // Add console completer select command.\n        app.commands.addCommand(CommandIDs.selectConsole, {\n            execute: () => {\n                const id = consoles.currentWidget && consoles.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for console completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectConsole,\n            keys: ['Enter'],\n            selector: `.jp-ConsolePanel .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * An extension that registers notebooks for code completion.\n */\nconst notebooks = {\n    id: '@jupyterlab/completer-extension:notebooks',\n    requires: [ICompletionManager, INotebookTracker],\n    autoStart: true,\n    activate: (app, manager, notebooks) => {\n        // Create a handler for each notebook that is created.\n        notebooks.widgetAdded.connect((sender, panel) => {\n            var _a, _b;\n            const editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n            const session = panel.sessionContext.session;\n            // TODO: CompletionConnector assumes editor and session are not null\n            const connector = new CompletionConnector({ session, editor });\n            const handler = manager.register({ connector, editor, parent: panel });\n            const updateConnector = () => {\n                var _a, _b;\n                const editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                const session = panel.sessionContext.session;\n                handler.editor = editor;\n                // TODO: CompletionConnector assumes editor and session are not null\n                handler.connector = new CompletionConnector({ session, editor });\n            };\n            // Update the handler whenever the prompt or session changes\n            panel.content.activeCellChanged.connect(updateConnector);\n            panel.sessionContext.sessionChanged.connect(updateConnector);\n        });\n        // Add notebook completer command.\n        app.commands.addCommand(CommandIDs.invokeNotebook, {\n            execute: () => {\n                var _a;\n                const panel = notebooks.currentWidget;\n                if (panel && ((_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.type) === 'code') {\n                    return app.commands.execute(CommandIDs.invoke, { id: panel.id });\n                }\n            }\n        });\n        // Add notebook completer select command.\n        app.commands.addCommand(CommandIDs.selectNotebook, {\n            execute: () => {\n                const id = notebooks.currentWidget && notebooks.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for notebook completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectNotebook,\n            keys: ['Enter'],\n            selector: `.jp-Notebook .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * An extension that registers file editors for completion.\n */\nconst files = {\n    id: '@jupyterlab/completer-extension:files',\n    requires: [ICompletionManager, IEditorTracker],\n    autoStart: true,\n    activate: (app, manager, editorTracker) => {\n        // Keep a list of active ISessions so that we can\n        // clean them up when they are no longer needed.\n        const activeSessions = {};\n        // When a new file editor is created, make the completer for it.\n        editorTracker.widgetAdded.connect((sender, widget) => {\n            const sessions = app.serviceManager.sessions;\n            const editor = widget.content.editor;\n            const contextConnector = new ContextConnector({ editor });\n            // Initially create the handler with the contextConnector.\n            // If a kernel session is found matching this file editor,\n            // it will be replaced in onRunningChanged().\n            const handler = manager.register({\n                connector: contextConnector,\n                editor,\n                parent: widget\n            });\n            // When the list of running sessions changes,\n            // check to see if there are any kernels with a\n            // matching path for this file editor.\n            const onRunningChanged = (sender, models) => {\n                const oldSession = activeSessions[widget.id];\n                // Search for a matching path.\n                const model = find(models, m => m.path === widget.context.path);\n                if (model) {\n                    // If there is a matching path, but it is the same\n                    // session as we previously had, do nothing.\n                    if (oldSession && oldSession.id === model.id) {\n                        return;\n                    }\n                    // Otherwise, dispose of the old session and reset to\n                    // a new CompletionConnector.\n                    if (oldSession) {\n                        delete activeSessions[widget.id];\n                        oldSession.dispose();\n                    }\n                    const session = sessions.connectTo({ model });\n                    handler.connector = new CompletionConnector({ session, editor });\n                    activeSessions[widget.id] = session;\n                }\n                else {\n                    // If we didn't find a match, make sure\n                    // the connector is the contextConnector and\n                    // dispose of any previous connection.\n                    handler.connector = contextConnector;\n                    if (oldSession) {\n                        delete activeSessions[widget.id];\n                        oldSession.dispose();\n                    }\n                }\n            };\n            onRunningChanged(sessions, toArray(sessions.running()));\n            sessions.runningChanged.connect(onRunningChanged);\n            // When the widget is disposed, do some cleanup.\n            widget.disposed.connect(() => {\n                sessions.runningChanged.disconnect(onRunningChanged);\n                const session = activeSessions[widget.id];\n                if (session) {\n                    delete activeSessions[widget.id];\n                    session.dispose();\n                }\n            });\n        });\n        // Add console completer invoke command.\n        app.commands.addCommand(CommandIDs.invokeFile, {\n            execute: () => {\n                const id = editorTracker.currentWidget && editorTracker.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.invoke, { id });\n                }\n            }\n        });\n        // Add console completer select command.\n        app.commands.addCommand(CommandIDs.selectFile, {\n            execute: () => {\n                const id = editorTracker.currentWidget && editorTracker.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for console completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectFile,\n            keys: ['Enter'],\n            selector: `.jp-FileEditor .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    manager,\n    consoles,\n    notebooks,\n    files\n];\nexport default plugins;\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}