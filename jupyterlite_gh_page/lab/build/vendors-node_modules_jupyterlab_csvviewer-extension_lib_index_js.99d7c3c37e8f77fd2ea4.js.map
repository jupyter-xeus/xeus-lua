{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/csvviewer-extension/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/csvviewer-extension/lib/searchprovider.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACuB;AACN;AACN;AACpB;AACK;AACV;AACS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B;AACA,QAAQ,oEAAe;AACvB,QAAQ,+DAAa;AACrB,QAAQ,2DAAS;AACjB,QAAQ,+EAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B;AACA,QAAQ,oEAAe;AACvB,QAAQ,+DAAa;AACrB,QAAQ,2DAAS;AACjB,QAAQ,+EAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAqB;AACxC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,+DAAa;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAkD;AAChF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,+DAAa;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAkD;AAChF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE,mEAAqB,IAAI,yOAAyO;AAC5T;AACA;AACA;AACA,uDAAuD,EAAE,mEAAqB,IAAI,iPAAiP;AACnU;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,iC;;;;;;;;;;;;;;;;;;;;;AChPA;AACA;AACkD;AACO;AACd;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAc,8BAA8B,4DAAS;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C","file":"vendors-node_modules_jupyterlab_csvviewer-extension_lib_index_js.99d7c3c37e8f77fd2ea4.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module csvviewer-extension\n */\nimport { ILayoutRestorer } from '@jupyterlab/application';\nimport { InputDialog, IThemeManager, WidgetTracker } from '@jupyterlab/apputils';\nimport { CSVViewerFactory, TSVViewerFactory } from '@jupyterlab/csvviewer';\nimport { ISearchProviderRegistry } from '@jupyterlab/documentsearch';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { DataGrid } from '@lumino/datagrid';\nimport { CSVSearchProvider } from './searchprovider';\n/**\n * The name of the factories that creates widgets.\n */\nconst FACTORY_CSV = 'CSVTable';\nconst FACTORY_TSV = 'TSVTable';\n/**\n * The CSV file handler extension.\n */\nconst csv = {\n    activate: activateCsv,\n    id: '@jupyterlab/csvviewer-extension:csv',\n    requires: [ITranslator],\n    optional: [\n        ILayoutRestorer,\n        IThemeManager,\n        IMainMenu,\n        ISearchProviderRegistry\n    ],\n    autoStart: true\n};\n/**\n * The TSV file handler extension.\n */\nconst tsv = {\n    activate: activateTsv,\n    id: '@jupyterlab/csvviewer-extension:tsv',\n    requires: [ITranslator],\n    optional: [\n        ILayoutRestorer,\n        IThemeManager,\n        IMainMenu,\n        ISearchProviderRegistry\n    ],\n    autoStart: true\n};\n/**\n * Connect menu entries for find and go to line.\n */\nfunction addMenuEntries(mainMenu, tracker, translator) {\n    const trans = translator.load('jupyterlab');\n    // Add go to line capability to the edit menu.\n    mainMenu.editMenu.goToLiners.add({\n        tracker,\n        goToLine: (widget) => {\n            return InputDialog.getNumber({\n                title: trans.__('Go to Line'),\n                value: 0\n            }).then(value => {\n                if (value.button.accept && value.value !== null) {\n                    widget.content.goToLine(value.value);\n                }\n            });\n        }\n    });\n}\n/**\n * Activate cssviewer extension for CSV files\n */\nfunction activateCsv(app, translator, restorer, themeManager, mainMenu, searchregistry) {\n    const factory = new CSVViewerFactory({\n        name: FACTORY_CSV,\n        fileTypes: ['csv'],\n        defaultFor: ['csv'],\n        readOnly: true,\n        translator\n    });\n    const tracker = new WidgetTracker({\n        namespace: 'csvviewer'\n    });\n    // The current styles for the data grids.\n    let style = Private.LIGHT_STYLE;\n    let rendererConfig = Private.LIGHT_TEXT_CONFIG;\n    if (restorer) {\n        // Handle state restoration.\n        void restorer.restore(tracker, {\n            command: 'docmanager:open',\n            args: widget => ({ path: widget.context.path, factory: FACTORY_CSV }),\n            name: widget => widget.context.path\n        });\n    }\n    app.docRegistry.addWidgetFactory(factory);\n    const ft = app.docRegistry.getFileType('csv');\n    factory.widgetCreated.connect((sender, widget) => {\n        // Track the widget.\n        void tracker.add(widget);\n        // Notify the widget tracker if restore data needs to update.\n        widget.context.pathChanged.connect(() => {\n            void tracker.save(widget);\n        });\n        if (ft) {\n            widget.title.icon = ft.icon;\n            widget.title.iconClass = ft.iconClass;\n            widget.title.iconLabel = ft.iconLabel;\n        }\n        // Set the theme for the new widget.\n        widget.content.style = style;\n        widget.content.rendererConfig = rendererConfig;\n    });\n    // Keep the themes up-to-date.\n    const updateThemes = () => {\n        const isLight = themeManager && themeManager.theme\n            ? themeManager.isLight(themeManager.theme)\n            : true;\n        style = isLight ? Private.LIGHT_STYLE : Private.DARK_STYLE;\n        rendererConfig = isLight\n            ? Private.LIGHT_TEXT_CONFIG\n            : Private.DARK_TEXT_CONFIG;\n        tracker.forEach(grid => {\n            grid.content.style = style;\n            grid.content.rendererConfig = rendererConfig;\n        });\n    };\n    if (themeManager) {\n        themeManager.themeChanged.connect(updateThemes);\n    }\n    if (mainMenu) {\n        addMenuEntries(mainMenu, tracker, translator);\n    }\n    if (searchregistry) {\n        searchregistry.register('csv', CSVSearchProvider);\n    }\n}\n/**\n * Activate cssviewer extension for TSV files\n */\nfunction activateTsv(app, translator, restorer, themeManager, mainMenu, searchregistry) {\n    const factory = new TSVViewerFactory({\n        name: FACTORY_TSV,\n        fileTypes: ['tsv'],\n        defaultFor: ['tsv'],\n        readOnly: true,\n        translator\n    });\n    const tracker = new WidgetTracker({\n        namespace: 'tsvviewer'\n    });\n    // The current styles for the data grids.\n    let style = Private.LIGHT_STYLE;\n    let rendererConfig = Private.LIGHT_TEXT_CONFIG;\n    if (restorer) {\n        // Handle state restoration.\n        void restorer.restore(tracker, {\n            command: 'docmanager:open',\n            args: widget => ({ path: widget.context.path, factory: FACTORY_TSV }),\n            name: widget => widget.context.path\n        });\n    }\n    app.docRegistry.addWidgetFactory(factory);\n    const ft = app.docRegistry.getFileType('tsv');\n    factory.widgetCreated.connect((sender, widget) => {\n        // Track the widget.\n        void tracker.add(widget);\n        // Notify the widget tracker if restore data needs to update.\n        widget.context.pathChanged.connect(() => {\n            void tracker.save(widget);\n        });\n        if (ft) {\n            widget.title.icon = ft.icon;\n            widget.title.iconClass = ft.iconClass;\n            widget.title.iconLabel = ft.iconLabel;\n        }\n        // Set the theme for the new widget.\n        widget.content.style = style;\n        widget.content.rendererConfig = rendererConfig;\n    });\n    // Keep the themes up-to-date.\n    const updateThemes = () => {\n        const isLight = themeManager && themeManager.theme\n            ? themeManager.isLight(themeManager.theme)\n            : true;\n        style = isLight ? Private.LIGHT_STYLE : Private.DARK_STYLE;\n        rendererConfig = isLight\n            ? Private.LIGHT_TEXT_CONFIG\n            : Private.DARK_TEXT_CONFIG;\n        tracker.forEach(grid => {\n            grid.content.style = style;\n            grid.content.rendererConfig = rendererConfig;\n        });\n    };\n    if (themeManager) {\n        themeManager.themeChanged.connect(updateThemes);\n    }\n    if (mainMenu) {\n        addMenuEntries(mainMenu, tracker, translator);\n    }\n    if (searchregistry) {\n        searchregistry.register('tsv', CSVSearchProvider);\n    }\n}\n/**\n * Export the plugins as default.\n */\nconst plugins = [csv, tsv];\nexport default plugins;\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The light theme for the data grid.\n     */\n    Private.LIGHT_STYLE = Object.assign(Object.assign({}, DataGrid.defaultStyle), { voidColor: '#F3F3F3', backgroundColor: 'white', headerBackgroundColor: '#EEEEEE', gridLineColor: 'rgba(20, 20, 20, 0.15)', headerGridLineColor: 'rgba(20, 20, 20, 0.25)', rowBackgroundColor: i => (i % 2 === 0 ? '#F5F5F5' : 'white') });\n    /**\n     * The dark theme for the data grid.\n     */\n    Private.DARK_STYLE = Object.assign(Object.assign({}, DataGrid.defaultStyle), { voidColor: 'black', backgroundColor: '#111111', headerBackgroundColor: '#424242', gridLineColor: 'rgba(235, 235, 235, 0.15)', headerGridLineColor: 'rgba(235, 235, 235, 0.25)', rowBackgroundColor: i => (i % 2 === 0 ? '#212121' : '#111111') });\n    /**\n     * The light config for the data grid renderer.\n     */\n    Private.LIGHT_TEXT_CONFIG = {\n        textColor: '#111111',\n        matchBackgroundColor: '#FFFFE0',\n        currentMatchBackgroundColor: '#FFFF00',\n        horizontalAlignment: 'right'\n    };\n    /**\n     * The dark config for the data grid renderer.\n     */\n    Private.DARK_TEXT_CONFIG = {\n        textColor: '#F5F5F5',\n        matchBackgroundColor: '#838423',\n        currentMatchBackgroundColor: '#A3807A',\n        horizontalAlignment: 'right'\n    };\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CSVViewer } from '@jupyterlab/csvviewer';\nimport { DocumentWidget } from '@jupyterlab/docregistry';\nimport { Signal } from '@lumino/signaling';\nexport class CSVSearchProvider {\n    constructor() {\n        /**\n         * The same list of matches provided by the startQuery promise resolution\n         */\n        this.matches = [];\n        /**\n         * The current index of the selected match.\n         */\n        this.currentMatchIndex = null;\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = true;\n        this._changed = new Signal(this);\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        // check to see if the CSVSearchProvider can search on the\n        // first cell, false indicates another editor is present\n        return (domain instanceof DocumentWidget && domain.content instanceof CSVViewer);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        // CSV Viewer does not support selection\n        return null;\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget) {\n        this._target = searchTarget;\n        this._query = query;\n        searchTarget.content.searchService.find(query);\n        return this.matches;\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery() {\n        this._target.content.searchService.clear();\n    }\n    /**\n     * Resets UI state as it was before the search process began.  Cleans up and\n     * disposes of all internal state.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        this._target.content.searchService.clear();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        this._target.content.searchService.find(this._query);\n        return undefined;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        this._target.content.searchService.find(this._query, true);\n        return undefined;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     * Not implemented in the CSV viewer as it is read-only.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async replaceCurrentMatch(newText) {\n        return false;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     * Not implemented in the CSV viewer as it is read-only.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async replaceAllMatches(newText) {\n        return false;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n}\n//# sourceMappingURL=searchprovider.js.map"],"sourceRoot":""}