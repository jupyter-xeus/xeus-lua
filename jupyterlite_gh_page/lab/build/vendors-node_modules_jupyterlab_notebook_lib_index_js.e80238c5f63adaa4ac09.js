(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_notebook_lib_index_js"],{

/***/ 49508:
/*!**************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/actions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KernelError": () => (/* binding */ KernelError),
/* harmony export */   "NotebookActions": () => (/* binding */ NotebookActions)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/cells */ 96462);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/algorithm */ 62867);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/coreutils */ 9727);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/domutils */ 33513);
/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/signaling */ 75138);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ 2411);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * The mimetype used for Jupyter cell data.
 */
const JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';
class KernelError extends Error {
    /**
     * Construct the kernel error.
     */
    constructor(content) {
        const errorContent = content;
        const errorName = errorContent.ename;
        const errorValue = errorContent.evalue;
        super(`KernelReplyNotOK: ${errorName} ${errorValue}`);
        this.errorName = errorName;
        this.errorValue = errorValue;
        this.traceback = errorContent.traceback;
        Object.setPrototypeOf(this, KernelError.prototype);
    }
}
/**
 * A collection of actions that run against notebooks.
 *
 * #### Notes
 * All of the actions are a no-op if there is no model on the notebook.
 * The actions set the widget `mode` to `'command'` unless otherwise specified.
 * The actions will preserve the selection on the notebook widget unless
 * otherwise specified.
 */
class NotebookActions {
    /**
     * A signal that emits whenever a cell completes execution.
     */
    static get executed() {
        return Private.executed;
    }
    /**
     * A signal that emits whenever a cell execution is scheduled.
     */
    static get executionScheduled() {
        return Private.executionScheduled;
    }
    /**
     * A signal that emits whenever a cell execution is scheduled.
     */
    static get selectionExecuted() {
        return Private.selectionExecuted;
    }
    /**
     * A private constructor for the `NotebookActions` class.
     *
     * #### Notes
     * This class can never be instantiated. Its static member `executed` will be
     * merged with the `NotebookActions` namespace. The reason it exists as a
     * standalone class is because at run time, the `Private.executed` variable
     * does not yet exist, so it needs to be referenced via a getter.
     */
    constructor() {
        // Intentionally empty.
    }
}
/**
 * A namespace for `NotebookActions` static methods.
 */
(function (NotebookActions) {
    /**
     * Split the active cell into two or more cells.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * It will preserve the existing mode.
     * The last cell will be activated if no selection is found.
     * If text was selected, the cell containing the selection will
       be activated.
     * The existing selection will be cleared.
     * The activated cell will have focus and the cursor will move
       to the end of the cell.
     * The leading whitespace in the second cell will be removed.
     * If there is no content, two empty cells will be created.
     * Both cells will have the same type as the original cell.
     * This action can be undone.
     */
    function splitCell(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.deselectAll();
        const nbModel = notebook.model;
        const index = notebook.activeCellIndex;
        const child = notebook.widgets[index];
        const editor = child.editor;
        const selections = editor.getSelections();
        const orig = child.model.value.text;
        const offsets = [0];
        let start = -1;
        let end = -1;
        for (let i = 0; i < selections.length; i++) {
            // append start and end to handle selections
            // cursors will have same start and end
            start = editor.getOffsetAt(selections[i].start);
            end = editor.getOffsetAt(selections[i].end);
            if (start < end) {
                offsets.push(start);
                offsets.push(end);
            }
            else if (end < start) {
                offsets.push(end);
                offsets.push(start);
            }
            else {
                offsets.push(start);
            }
        }
        offsets.push(orig.length);
        const clones = [];
        for (let i = 0; i + 1 < offsets.length; i++) {
            const clone = Private.cloneCell(nbModel, child.model);
            clones.push(clone);
        }
        for (let i = 0; i < clones.length; i++) {
            if (i !== clones.length - 1 && clones[i].type === 'code') {
                clones[i].outputs.clear();
            }
            clones[i].value.text = orig
                .slice(offsets[i], offsets[i + 1])
                .replace(/^\n+/, '')
                .replace(/\n+$/, '');
        }
        const cells = nbModel.cells;
        cells.beginCompoundOperation();
        for (let i = 0; i < clones.length; i++) {
            if (i === 0) {
                cells.set(index, clones[i]);
            }
            else {
                cells.insert(index + i, clones[i]);
            }
        }
        cells.endCompoundOperation();
        // If there is a selection the selected cell will be activated
        const activeCellDelta = start !== end ? 2 : 1;
        notebook.activeCellIndex = index + clones.length - activeCellDelta;
        const focusedEditor = notebook.activeCell.editor;
        focusedEditor.focus();
        // Move to the end of the cell that now contains the cursor
        focusedEditor.setCursorPosition({ line: editor.lineCount, column: 0 });
        Private.handleState(notebook, state);
    }
    NotebookActions.splitCell = splitCell;
    /**
     * Merge the selected cells.
     *
     * @param notebook - The target notebook widget.
     *
     * @param mergeAbove - If only one cell is selected, indicates whether to merge it
     *    with the cell above (true) or below (false, default).
     *
     * #### Notes
     * The widget mode will be preserved.
     * If only one cell is selected and `mergeAbove` is true, the above cell will be selected.
     * If only one cell is selected and `mergeAbove` is false, the below cell will be selected.
     * If the active cell is a code cell, its outputs will be cleared.
     * This action can be undone.
     * The final cell will have the same type as the active cell.
     * If the active cell is a markdown cell, it will be unrendered.
     */
    function mergeCells(notebook, mergeAbove = false) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        const toMerge = [];
        const toDelete = [];
        const model = notebook.model;
        const cells = model.cells;
        const primary = notebook.activeCell;
        const active = notebook.activeCellIndex;
        const attachments = {};
        // Get the cells to merge.
        notebook.widgets.forEach((child, index) => {
            if (notebook.isSelectedOrActive(child)) {
                toMerge.push(child.model.value.text);
                if (index !== active) {
                    toDelete.push(child.model);
                }
                // Collect attachments if the cell is a markdown cell or a raw cell
                const model = child.model;
                if ((0,_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.isRawCellModel)(model) || (0,_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.isMarkdownCellModel)(model)) {
                    for (const key of model.attachments.keys) {
                        attachments[key] = model.attachments.get(key).toJSON();
                    }
                }
            }
        });
        // Check for only a single cell selected.
        if (toMerge.length === 1) {
            // Merge with the cell above when mergeAbove is true
            if (mergeAbove === true) {
                // Bail if it is the first cell.
                if (active === 0) {
                    return;
                }
                // Otherwise merge with the previous cell.
                const cellModel = cells.get(active - 1);
                toMerge.unshift(cellModel.value.text);
                toDelete.push(cellModel);
            }
            else if (mergeAbove === false) {
                // Bail if it is the last cell.
                if (active === cells.length - 1) {
                    return;
                }
                // Otherwise merge with the next cell.
                const cellModel = cells.get(active + 1);
                toMerge.push(cellModel.value.text);
                toDelete.push(cellModel);
            }
        }
        notebook.deselectAll();
        // Create a new cell for the source to preserve history.
        const newModel = Private.cloneCell(model, primary.model);
        newModel.value.text = toMerge.join('\n\n');
        if ((0,_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.isCodeCellModel)(newModel)) {
            newModel.outputs.clear();
        }
        else if ((0,_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.isMarkdownCellModel)(newModel) || (0,_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.isRawCellModel)(newModel)) {
            newModel.attachments.fromJSON(attachments);
        }
        // Make the changes while preserving history.
        cells.beginCompoundOperation();
        cells.set(active, newModel);
        toDelete.forEach(cell => {
            cells.removeValue(cell);
        });
        cells.endCompoundOperation();
        // If the original cell is a markdown cell, make sure
        // the new cell is unrendered.
        if (primary instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.MarkdownCell) {
            notebook.activeCell.rendered = false;
        }
        Private.handleState(notebook, state);
    }
    NotebookActions.mergeCells = mergeCells;
    /**
     * Delete the selected cells.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The cell after the last selected cell will be activated.
     * It will add a code cell if all cells are deleted.
     * This action can be undone.
     */
    function deleteCells(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        Private.deleteCells(notebook);
        Private.handleState(notebook, state, true);
    }
    NotebookActions.deleteCells = deleteCells;
    /**
     * Insert a new code cell above the active cell.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This action can be undone.
     * The existing selection will be cleared.
     * The new cell will the active cell.
     */
    function insertAbove(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        const model = notebook.model;
        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});
        const active = notebook.activeCellIndex;
        model.cells.insert(active, cell);
        // Make the newly inserted cell active.
        notebook.activeCellIndex = active;
        notebook.deselectAll();
        Private.handleState(notebook, state, true);
    }
    NotebookActions.insertAbove = insertAbove;
    /**
     * Insert a new code cell below the active cell.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This action can be undone.
     * The existing selection will be cleared.
     * The new cell will be the active cell.
     */
    function insertBelow(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        const model = notebook.model;
        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});
        model.cells.insert(notebook.activeCellIndex + 1, cell);
        // Make the newly inserted cell active.
        notebook.activeCellIndex++;
        notebook.deselectAll();
        Private.handleState(notebook, state, true);
    }
    NotebookActions.insertBelow = insertBelow;
    /**
     * Move the selected cell(s) down.
     *
     * @param notebook = The target notebook widget.
     */
    function moveDown(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        const cells = notebook.model.cells;
        const widgets = notebook.widgets;
        cells.beginCompoundOperation();
        for (let i = cells.length - 2; i > -1; i--) {
            if (notebook.isSelectedOrActive(widgets[i])) {
                if (!notebook.isSelectedOrActive(widgets[i + 1])) {
                    cells.move(i, i + 1);
                    if (notebook.activeCellIndex === i) {
                        notebook.activeCellIndex++;
                    }
                    notebook.select(widgets[i + 1]);
                    notebook.deselect(widgets[i]);
                }
            }
        }
        cells.endCompoundOperation();
        Private.handleState(notebook, state, true);
    }
    NotebookActions.moveDown = moveDown;
    /**
     * Move the selected cell(s) up.
     *
     * @param widget - The target notebook widget.
     */
    function moveUp(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        const cells = notebook.model.cells;
        const widgets = notebook.widgets;
        cells.beginCompoundOperation();
        for (let i = 1; i < cells.length; i++) {
            if (notebook.isSelectedOrActive(widgets[i])) {
                if (!notebook.isSelectedOrActive(widgets[i - 1])) {
                    cells.move(i, i - 1);
                    if (notebook.activeCellIndex === i) {
                        notebook.activeCellIndex--;
                    }
                    notebook.select(widgets[i - 1]);
                    notebook.deselect(widgets[i]);
                }
            }
        }
        cells.endCompoundOperation();
        Private.handleState(notebook, state, true);
    }
    NotebookActions.moveUp = moveUp;
    /**
     * Change the selected cell type(s).
     *
     * @param notebook - The target notebook widget.
     *
     * @param value - The target cell type.
     *
     * #### Notes
     * It should preserve the widget mode.
     * This action can be undone.
     * The existing selection will be cleared.
     * Any cells converted to markdown will be unrendered.
     */
    function changeCellType(notebook, value) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        Private.changeCellType(notebook, value);
        Private.handleState(notebook, state);
    }
    NotebookActions.changeCellType = changeCellType;
    /**
     * Run the selected cell(s).
     *
     * @param notebook - The target notebook widget.
     *
     * @param sessionContext - The optional client session object.
     *
     * #### Notes
     * The last selected cell will be activated, but not scrolled into view.
     * The existing selection will be cleared.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     */
    function run(notebook, sessionContext) {
        if (!notebook.model || !notebook.activeCell) {
            return Promise.resolve(false);
        }
        const state = Private.getState(notebook);
        const promise = Private.runSelected(notebook, sessionContext);
        Private.handleRunState(notebook, state, false);
        return promise;
    }
    NotebookActions.run = run;
    /**
     * Run the selected cell(s) and advance to the next cell.
     *
     * @param notebook - The target notebook widget.
     *
     * @param sessionContext - The optional client session object.
     *
     * #### Notes
     * The existing selection will be cleared.
     * The cell after the last selected cell will be activated and scrolled into view.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * If the last selected cell is the last cell, a new code cell
     * will be created in `'edit'` mode.  The new cell creation can be undone.
     */
    function runAndAdvance(notebook, sessionContext) {
        if (!notebook.model || !notebook.activeCell) {
            return Promise.resolve(false);
        }
        const state = Private.getState(notebook);
        const promise = Private.runSelected(notebook, sessionContext);
        const model = notebook.model;
        if (notebook.activeCellIndex === notebook.widgets.length - 1) {
            const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});
            // Do not use push here, as we want an widget insertion
            // to make sure no placeholder widget is rendered.
            model.cells.insert(notebook.widgets.length, cell);
            notebook.activeCellIndex++;
            notebook.mode = 'edit';
        }
        else {
            notebook.activeCellIndex++;
        }
        Private.handleRunState(notebook, state, true);
        return promise;
    }
    NotebookActions.runAndAdvance = runAndAdvance;
    /**
     * Run the selected cell(s) and insert a new code cell.
     *
     * @param notebook - The target notebook widget.
     *
     * @param sessionContext - The optional client session object.
     *
     * #### Notes
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * The widget mode will be set to `'edit'` after running.
     * The existing selection will be cleared.
     * The cell insert can be undone.
     * The new cell will be scrolled into view.
     */
    function runAndInsert(notebook, sessionContext) {
        if (!notebook.model || !notebook.activeCell) {
            return Promise.resolve(false);
        }
        const state = Private.getState(notebook);
        const promise = Private.runSelected(notebook, sessionContext);
        const model = notebook.model;
        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});
        model.cells.insert(notebook.activeCellIndex + 1, cell);
        notebook.activeCellIndex++;
        notebook.mode = 'edit';
        Private.handleRunState(notebook, state, true);
        return promise;
    }
    NotebookActions.runAndInsert = runAndInsert;
    /**
     * Run all of the cells in the notebook.
     *
     * @param notebook - The target notebook widget.
     *
     * @param sessionContext - The optional client session object.
     *
     * #### Notes
     * The existing selection will be cleared.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * The last cell in the notebook will be activated and scrolled into view.
     */
    function runAll(notebook, sessionContext) {
        if (!notebook.model || !notebook.activeCell) {
            return Promise.resolve(false);
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(child => {
            notebook.select(child);
        });
        const promise = Private.runSelected(notebook, sessionContext);
        Private.handleRunState(notebook, state, true);
        return promise;
    }
    NotebookActions.runAll = runAll;
    function renderAllMarkdown(notebook, sessionContext) {
        if (!notebook.model || !notebook.activeCell) {
            return Promise.resolve(false);
        }
        const previousIndex = notebook.activeCellIndex;
        const state = Private.getState(notebook);
        notebook.widgets.forEach((child, index) => {
            if (child.model.type === 'markdown') {
                notebook.select(child);
                // This is to make sure that the activeCell
                // does not get executed
                notebook.activeCellIndex = index;
            }
        });
        if (notebook.activeCell.model.type !== 'markdown') {
            return Promise.resolve(true);
        }
        const promise = Private.runSelected(notebook, sessionContext);
        notebook.activeCellIndex = previousIndex;
        Private.handleRunState(notebook, state, true);
        return promise;
    }
    NotebookActions.renderAllMarkdown = renderAllMarkdown;
    /**
     * Run all of the cells before the currently active cell (exclusive).
     *
     * @param notebook - The target notebook widget.
     *
     * @param sessionContext - The optional client session object.
     *
     * #### Notes
     * The existing selection will be cleared.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * The currently active cell will remain selected.
     */
    function runAllAbove(notebook, sessionContext) {
        const { activeCell, activeCellIndex, model } = notebook;
        if (!model || !activeCell || activeCellIndex < 1) {
            return Promise.resolve(false);
        }
        const state = Private.getState(notebook);
        notebook.activeCellIndex--;
        notebook.deselectAll();
        for (let i = 0; i < notebook.activeCellIndex; ++i) {
            notebook.select(notebook.widgets[i]);
        }
        const promise = Private.runSelected(notebook, sessionContext);
        notebook.activeCellIndex++;
        Private.handleRunState(notebook, state, true);
        return promise;
    }
    NotebookActions.runAllAbove = runAllAbove;
    /**
     * Run all of the cells after the currently active cell (inclusive).
     *
     * @param notebook - The target notebook widget.
     *
     * @param sessionContext - The optional client session object.
     *
     * #### Notes
     * The existing selection will be cleared.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * The last cell in the notebook will be activated and scrolled into view.
     */
    function runAllBelow(notebook, sessionContext) {
        if (!notebook.model || !notebook.activeCell) {
            return Promise.resolve(false);
        }
        const state = Private.getState(notebook);
        notebook.deselectAll();
        for (let i = notebook.activeCellIndex; i < notebook.widgets.length; ++i) {
            notebook.select(notebook.widgets[i]);
        }
        const promise = Private.runSelected(notebook, sessionContext);
        Private.handleRunState(notebook, state, true);
        return promise;
    }
    NotebookActions.runAllBelow = runAllBelow;
    /**
     * Replaces the selection in the active cell of the notebook.
     *
     * @param notebook - The target notebook widget.
     * @param text - The text to replace the selection.
     */
    function replaceSelection(notebook, text) {
        var _a, _b;
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        (_b = (_a = notebook.activeCell.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, text);
    }
    NotebookActions.replaceSelection = replaceSelection;
    /**
     * Select the above the active cell.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This is a no-op if the first cell is the active cell.
     * This will skip any collapsed cells.
     * The existing selection will be cleared.
     */
    function selectAbove(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        if (notebook.activeCellIndex === 0) {
            return;
        }
        let possibleNextCellIndex = notebook.activeCellIndex - 1;
        // find first non hidden cell above current cell
        while (possibleNextCellIndex >= 0) {
            const possibleNextCell = notebook.widgets[possibleNextCellIndex];
            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {
                break;
            }
            possibleNextCellIndex -= 1;
        }
        const state = Private.getState(notebook);
        notebook.activeCellIndex = possibleNextCellIndex;
        notebook.deselectAll();
        Private.handleState(notebook, state, true);
    }
    NotebookActions.selectAbove = selectAbove;
    /**
     * Select the cell below the active cell.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This is a no-op if the last cell is the active cell.
     * This will skip any collapsed cells.
     * The existing selection will be cleared.
     */
    function selectBelow(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        let maxCellIndex = notebook.widgets.length - 1;
        // Find last non-hidden cell
        while (notebook.widgets[maxCellIndex].isHidden ||
            notebook.widgets[maxCellIndex].inputHidden) {
            maxCellIndex -= 1;
        }
        if (notebook.activeCellIndex === maxCellIndex) {
            return;
        }
        let possibleNextCellIndex = notebook.activeCellIndex + 1;
        // find first non hidden cell below current cell
        while (possibleNextCellIndex < maxCellIndex) {
            let possibleNextCell = notebook.widgets[possibleNextCellIndex];
            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {
                break;
            }
            possibleNextCellIndex += 1;
        }
        const state = Private.getState(notebook);
        notebook.activeCellIndex = possibleNextCellIndex;
        notebook.deselectAll();
        Private.handleState(notebook, state, true);
    }
    NotebookActions.selectBelow = selectBelow;
    /**
     * Extend the selection to the cell above.
     *
     * @param notebook - The target notebook widget.
     * @param toTop - If true, denotes selection to extend to the top.
     *
     * #### Notes
     * This is a no-op if the first cell is the active cell.
     * The new cell will be activated.
     */
    function extendSelectionAbove(notebook, toTop = false) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        // Do not wrap around.
        if (notebook.activeCellIndex === 0) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.mode = 'command';
        // Check if toTop is true, if yes, selection is made to the top.
        if (toTop) {
            notebook.extendContiguousSelectionTo(0);
        }
        else {
            notebook.extendContiguousSelectionTo(notebook.activeCellIndex - 1);
        }
        Private.handleState(notebook, state, true);
    }
    NotebookActions.extendSelectionAbove = extendSelectionAbove;
    /**
     * Extend the selection to the cell below.
     *
     * @param notebook - The target notebook widget.
     * @param toBottom - If true, denotes selection to extend to the bottom.
     *
     * #### Notes
     * This is a no-op if the last cell is the active cell.
     * The new cell will be activated.
     */
    function extendSelectionBelow(notebook, toBottom = false) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        // Do not wrap around.
        if (notebook.activeCellIndex === notebook.widgets.length - 1) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.mode = 'command';
        // Check if toBottom is true, if yes selection is made to the bottom.
        if (toBottom) {
            notebook.extendContiguousSelectionTo(notebook.widgets.length - 1);
        }
        else {
            notebook.extendContiguousSelectionTo(notebook.activeCellIndex + 1);
        }
        Private.handleState(notebook, state, true);
    }
    NotebookActions.extendSelectionBelow = extendSelectionBelow;
    /**
     * Select all of the cells of the notebook.
     *
     * @param notebook - the target notebook widget.
     */
    function selectAll(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        notebook.widgets.forEach(child => {
            notebook.select(child);
        });
    }
    NotebookActions.selectAll = selectAll;
    /**
     * Deselect all of the cells of the notebook.
     *
     * @param notebook - the target notebook widget.
     */
    function deselectAll(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        notebook.deselectAll();
    }
    NotebookActions.deselectAll = deselectAll;
    /**
     * Copy the selected cell data to a clipboard.
     *
     * @param notebook - The target notebook widget.
     */
    function copy(notebook) {
        Private.copyOrCut(notebook, false);
    }
    NotebookActions.copy = copy;
    /**
     * Cut the selected cell data to a clipboard.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * This action can be undone.
     * A new code cell is added if all cells are cut.
     */
    function cut(notebook) {
        Private.copyOrCut(notebook, true);
    }
    NotebookActions.cut = cut;
    /**
     * Paste cells from the application clipboard.
     *
     * @param notebook - The target notebook widget.
     *
     * @param mode - the mode of the paste operation: 'below' pastes cells
     *   below the active cell, 'above' pastes cells above the active cell,
     *   and 'replace' removes the currently selected cells and pastes cells
     *   in their place.
     *
     * #### Notes
     * The last pasted cell becomes the active cell.
     * This is a no-op if there is no cell data on the clipboard.
     * This action can be undone.
     */
    function paste(notebook, mode = 'below') {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const clipboard = _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Clipboard.getInstance();
        if (!clipboard.hasData(JUPYTER_CELL_MIME)) {
            return;
        }
        const state = Private.getState(notebook);
        const values = clipboard.getData(JUPYTER_CELL_MIME);
        const model = notebook.model;
        notebook.mode = 'command';
        const newCells = values.map(cell => {
            switch (cell.cell_type) {
                case 'code':
                    return model.contentFactory.createCodeCell({ cell });
                case 'markdown':
                    return model.contentFactory.createMarkdownCell({ cell });
                default:
                    return model.contentFactory.createRawCell({ cell });
            }
        });
        const cells = notebook.model.cells;
        let index;
        cells.beginCompoundOperation();
        // Set the starting index of the paste operation depending upon the mode.
        switch (mode) {
            case 'below':
                index = notebook.activeCellIndex;
                break;
            case 'above':
                index = notebook.activeCellIndex - 1;
                break;
            case 'replace': {
                // Find the cells to delete.
                const toDelete = [];
                notebook.widgets.forEach((child, index) => {
                    const deletable = child.model.metadata.get('deletable') !== false;
                    if (notebook.isSelectedOrActive(child) && deletable) {
                        toDelete.push(index);
                    }
                });
                // If cells are not deletable, we may not have anything to delete.
                if (toDelete.length > 0) {
                    // Delete the cells as one undo event.
                    toDelete.reverse().forEach(i => {
                        cells.remove(i);
                    });
                }
                index = toDelete[0];
                break;
            }
            default:
                break;
        }
        newCells.forEach(cell => {
            cells.insert(++index, cell);
        });
        cells.endCompoundOperation();
        notebook.activeCellIndex += newCells.length;
        notebook.deselectAll();
        Private.handleState(notebook, state);
    }
    NotebookActions.paste = paste;
    /**
     * Undo a cell action.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * This is a no-op if if there are no cell actions to undo.
     */
    function undo(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.mode = 'command';
        notebook.model.sharedModel.undo();
        notebook.deselectAll();
        Private.handleState(notebook, state);
    }
    NotebookActions.undo = undo;
    /**
     * Redo a cell action.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * This is a no-op if there are no cell actions to redo.
     */
    function redo(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.mode = 'command';
        notebook.model.sharedModel.redo();
        notebook.deselectAll();
        Private.handleState(notebook, state);
    }
    NotebookActions.redo = redo;
    /**
     * Toggle the line number of all cells.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The original state is based on the state of the active cell.
     * The `mode` of the widget will be preserved.
     */
    function toggleAllLineNumbers(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        const config = notebook.editorConfig;
        const lineNumbers = !(config.code.lineNumbers &&
            config.markdown.lineNumbers &&
            config.raw.lineNumbers);
        const newConfig = {
            code: Object.assign(Object.assign({}, config.code), { lineNumbers }),
            markdown: Object.assign(Object.assign({}, config.markdown), { lineNumbers }),
            raw: Object.assign(Object.assign({}, config.raw), { lineNumbers })
        };
        notebook.editorConfig = newConfig;
        Private.handleState(notebook, state);
    }
    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;
    /**
     * Clear the code outputs of the selected cells.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The widget `mode` will be preserved.
     */
    function clearOutputs(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.each)(notebook.model.cells, (cell, index) => {
            const child = notebook.widgets[index];
            if (notebook.isSelectedOrActive(child) && cell.type === 'code') {
                cell.clearExecution();
                child.outputHidden = false;
            }
        });
        Private.handleState(notebook, state, true);
    }
    NotebookActions.clearOutputs = clearOutputs;
    /**
     * Clear all the code outputs on the widget.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The widget `mode` will be preserved.
     */
    function clearAllOutputs(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.each)(notebook.model.cells, (cell, index) => {
            const child = notebook.widgets[index];
            if (cell.type === 'code') {
                cell.clearExecution();
                child.outputHidden = false;
            }
        });
        Private.handleState(notebook, state, true);
    }
    NotebookActions.clearAllOutputs = clearAllOutputs;
    /**
     * Hide the code on selected code cells.
     *
     * @param notebook - The target notebook widget.
     */
    function hideCode(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
                cell.inputHidden = true;
            }
        });
        Private.handleState(notebook, state);
    }
    NotebookActions.hideCode = hideCode;
    /**
     * Show the code on selected code cells.
     *
     * @param notebook - The target notebook widget.
     */
    function showCode(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
                cell.inputHidden = false;
            }
        });
        Private.handleState(notebook, state);
    }
    NotebookActions.showCode = showCode;
    /**
     * Hide the code on all code cells.
     *
     * @param notebook - The target notebook widget.
     */
    function hideAllCode(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (cell.model.type === 'code') {
                cell.inputHidden = true;
            }
        });
        Private.handleState(notebook, state);
    }
    NotebookActions.hideAllCode = hideAllCode;
    /**
     * Show the code on all code cells.
     *
     * @param widget - The target notebook widget.
     */
    function showAllCode(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (cell.model.type === 'code') {
                cell.inputHidden = false;
            }
        });
        Private.handleState(notebook, state);
    }
    NotebookActions.showAllCode = showAllCode;
    /**
     * Hide the output on selected code cells.
     *
     * @param notebook - The target notebook widget.
     */
    function hideOutput(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
                cell.outputHidden = true;
            }
        });
        Private.handleState(notebook, state, true);
    }
    NotebookActions.hideOutput = hideOutput;
    /**
     * Show the output on selected code cells.
     *
     * @param notebook - The target notebook widget.
     */
    function showOutput(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
                cell.outputHidden = false;
            }
        });
        Private.handleState(notebook, state);
    }
    NotebookActions.showOutput = showOutput;
    /**
     * Hide the output on all code cells.
     *
     * @param notebook - The target notebook widget.
     */
    function hideAllOutputs(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (cell.model.type === 'code') {
                cell.outputHidden = true;
            }
        });
        Private.handleState(notebook, state, true);
    }
    NotebookActions.hideAllOutputs = hideAllOutputs;
    /**
     * Show the output on all code cells.
     *
     * @param notebook - The target notebook widget.
     */
    function showAllOutputs(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (cell.model.type === 'code') {
                cell.outputHidden = false;
            }
        });
        Private.handleState(notebook, state);
    }
    NotebookActions.showAllOutputs = showAllOutputs;
    /**
     * Enable output scrolling for all selected cells.
     *
     * @param notebook - The target notebook widget.
     */
    function enableOutputScrolling(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
                cell.outputsScrolled = true;
            }
        });
        Private.handleState(notebook, state, true);
    }
    NotebookActions.enableOutputScrolling = enableOutputScrolling;
    /**
     * Disable output scrolling for all selected cells.
     *
     * @param notebook - The target notebook widget.
     */
    function disableOutputScrolling(notebook) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        notebook.widgets.forEach(cell => {
            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
                cell.outputsScrolled = false;
            }
        });
        Private.handleState(notebook, state);
    }
    NotebookActions.disableOutputScrolling = disableOutputScrolling;
    /**
     * Go to the last cell that is run or current if it is running.
     *
     * Note: This requires execution timing to be toggled on or this will have
     * no effect.
     *
     * @param notebook - The target notebook widget.
     */
    function selectLastRunCell(notebook) {
        let latestTime = null;
        let latestCellIdx = null;
        notebook.widgets.forEach((cell, cellIndx) => {
            if (cell.model.type === 'code') {
                const execution = cell.model.metadata.get('execution');
                if (execution &&
                    _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.isObject(execution) &&
                    execution['iopub.status.busy'] !== undefined) {
                    // The busy status is used as soon as a request is received:
                    // https://jupyter-client.readthedocs.io/en/stable/messaging.html
                    const timestamp = execution['iopub.status.busy'].toString();
                    if (timestamp) {
                        const startTime = new Date(timestamp);
                        if (!latestTime || startTime >= latestTime) {
                            latestTime = startTime;
                            latestCellIdx = cellIndx;
                        }
                    }
                }
            }
        });
        if (latestCellIdx !== null) {
            notebook.activeCellIndex = latestCellIdx;
        }
    }
    NotebookActions.selectLastRunCell = selectLastRunCell;
    /**
     * Set the markdown header level.
     *
     * @param notebook - The target notebook widget.
     *
     * @param level - The header level.
     *
     * #### Notes
     * All selected cells will be switched to markdown.
     * The level will be clamped between 1 and 6.
     * If there is an existing header, it will be replaced.
     * There will always be one blank space after the header.
     * The cells will be unrendered.
     */
    function setMarkdownHeader(notebook, level) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = Private.getState(notebook);
        const cells = notebook.model.cells;
        level = Math.min(Math.max(level, 1), 6);
        notebook.widgets.forEach((child, index) => {
            if (notebook.isSelectedOrActive(child)) {
                Private.setMarkdownHeader(cells.get(index), level);
            }
        });
        Private.changeCellType(notebook, 'markdown');
        Private.handleState(notebook, state);
    }
    NotebookActions.setMarkdownHeader = setMarkdownHeader;
    /**
     * Collapse all cells in given notebook.
     *
     * @param notebook - The target notebook widget.
     */
    function collapseAll(notebook) {
        for (const cell of notebook.widgets) {
            if (NotebookActions.getHeadingInfo(cell).isHeading) {
                NotebookActions.setHeadingCollapse(cell, true, notebook);
                NotebookActions.setCellCollapse(cell, true);
            }
        }
    }
    NotebookActions.collapseAll = collapseAll;
    /**
     * Un-collapse all cells in given notebook.
     *
     * @param notebook - The target notebook widget.
     */
    function expandAllHeadings(notebook) {
        for (const cell of notebook.widgets) {
            if (NotebookActions.getHeadingInfo(cell).isHeading) {
                NotebookActions.setHeadingCollapse(cell, false, notebook);
                // similar to collapseAll.
                NotebookActions.setCellCollapse(cell, false);
            }
        }
    }
    NotebookActions.expandAllHeadings = expandAllHeadings;
    function findNearestParentHeader(cell, notebook) {
        const index = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.findIndex)(notebook.widgets, (possibleCell, index) => {
            return cell.model.id === possibleCell.model.id;
        });
        if (index === -1) {
            return;
        }
        // Finds the nearest header above the given cell. If the cell is a header itself, it does not return itself;
        // this can be checked directly by calling functions.
        if (index >= notebook.widgets.length) {
            return;
        }
        let childHeaderInfo = getHeadingInfo(notebook.widgets[index]);
        for (let cellN = index - 1; cellN >= 0; cellN--) {
            if (cellN < notebook.widgets.length) {
                let hInfo = getHeadingInfo(notebook.widgets[cellN]);
                if (hInfo.isHeading &&
                    hInfo.headingLevel < childHeaderInfo.headingLevel) {
                    return notebook.widgets[cellN];
                }
            }
        }
        // else no parent header found.
        return;
    }
    /**
     * Finds the "parent" heading of the given cell and expands.
     * Used for the case that a cell becomes active that is within a collapsed heading.
     * @param cell - "Child" cell that has become the active cell
     * @param notebook - The target notebook widget.
     */
    function expandParent(cell, notebook) {
        let nearestParentCell = findNearestParentHeader(cell, notebook);
        if (!nearestParentCell) {
            return;
        }
        if (!getHeadingInfo(nearestParentCell).collapsed &&
            !nearestParentCell.isHidden) {
            return;
        }
        if (nearestParentCell.isHidden) {
            expandParent(nearestParentCell, notebook);
        }
        if (getHeadingInfo(nearestParentCell).collapsed) {
            setHeadingCollapse(nearestParentCell, false, notebook);
        }
    }
    NotebookActions.expandParent = expandParent;
    /**
     * Finds the next heading that isn't a child of the given markdown heading.
     * @param cell - "Child" cell that has become the active cell
     * @param notebook - The target notebook widget.
     */
    function findNextParentHeading(cell, notebook) {
        let index = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.findIndex)(notebook.widgets, (possibleCell, index) => {
            return cell.model.id === possibleCell.model.id;
        });
        if (index === -1) {
            return -1;
        }
        let childHeaderInfo = getHeadingInfo(cell);
        for (index = index + 1; index < notebook.widgets.length; index++) {
            let hInfo = getHeadingInfo(notebook.widgets[index]);
            if (hInfo.isHeading &&
                hInfo.headingLevel <= childHeaderInfo.headingLevel) {
                return index;
            }
        }
        // else no parent header found. return the index of the last cell
        return notebook.widgets.length;
    }
    NotebookActions.findNextParentHeading = findNextParentHeading;
    /**
     * Set the given cell and ** all "child" cells **
     * to the given collapse / expand if cell is
     * a markdown header.
     *
     * @param cell - The cell
     * @param collapsing - Whether to collapse or expand the cell
     * @param notebook - The target notebook widget.
     */
    function setHeadingCollapse(cell, collapsing, notebook) {
        const which = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.findIndex)(notebook.widgets, (possibleCell, index) => {
            return cell.model.id === possibleCell.model.id;
        });
        if (which === -1) {
            return -1;
        }
        if (!notebook.widgets.length) {
            return which + 1;
        }
        let selectedHeadingInfo = NotebookActions.getHeadingInfo(cell);
        if (cell.isHidden ||
            !(cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.MarkdownCell) ||
            !selectedHeadingInfo.isHeading) {
            // otherwise collapsing and uncollapsing already hidden stuff can
            // cause some funny looking bugs.
            return which + 1;
        }
        let localCollapsed = false;
        let localCollapsedLevel = 0;
        // iterate through all cells after the active cell.
        let cellNum;
        for (cellNum = which + 1; cellNum < notebook.widgets.length; cellNum++) {
            let subCell = notebook.widgets[cellNum];
            let subCellHeadingInfo = NotebookActions.getHeadingInfo(subCell);
            if (subCellHeadingInfo.isHeading &&
                subCellHeadingInfo.headingLevel <= selectedHeadingInfo.headingLevel) {
                // then reached an equivalent or higher heading level than the
                // original the end of the collapse.
                cellNum -= 1;
                break;
            }
            if (localCollapsed &&
                subCellHeadingInfo.isHeading &&
                subCellHeadingInfo.headingLevel <= localCollapsedLevel) {
                // then reached the end of the local collapsed, so unset NotebookActions.
                localCollapsed = false;
            }
            if (collapsing || localCollapsed) {
                // then no extra handling is needed for further locally collapsed
                // headings.
                subCell.setHidden(true);
                continue;
            }
            if (subCellHeadingInfo.collapsed && subCellHeadingInfo.isHeading) {
                localCollapsed = true;
                localCollapsedLevel = subCellHeadingInfo.headingLevel;
                // but don't collapse the locally collapsed heading, so continue to
                // expand the heading. This will get noticed in the next round.
            }
            subCell.setHidden(false);
        }
        if (cellNum === notebook.widgets.length) {
            cell.numberChildNodes = cellNum - which - 1;
        }
        else {
            cell.numberChildNodes = cellNum - which;
        }
        NotebookActions.setCellCollapse(cell, collapsing);
        return cellNum + 1;
    }
    NotebookActions.setHeadingCollapse = setHeadingCollapse;
    /**
     * Toggles the collapse state of the active cell of the given notebook
     * and ** all of its "child" cells ** if the cell is a heading.
     *
     * @param notebook - The target notebook widget.
     */
    function toggleCurrentHeadingCollapse(notebook) {
        if (!notebook.activeCell || notebook.activeCellIndex === undefined) {
            return;
        }
        let headingInfo = NotebookActions.getHeadingInfo(notebook.activeCell);
        if (headingInfo.isHeading) {
            // Then toggle!
            NotebookActions.setHeadingCollapse(notebook.activeCell, !headingInfo.collapsed, notebook);
        }
        _lumino_domutils__WEBPACK_IMPORTED_MODULE_5__.ElementExt.scrollIntoViewIfNeeded(notebook.node, notebook.activeCell.node);
    }
    NotebookActions.toggleCurrentHeadingCollapse = toggleCurrentHeadingCollapse;
    /**
     * If cell is a markdown heading, sets the headingCollapsed field,
     * and otherwise hides the cell.
     *
     * @param cell - The cell to collapse / expand
     * @param collapsing - Whether to collapse or expand the given cell
     */
    function setCellCollapse(cell, collapsing) {
        if (cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.MarkdownCell) {
            cell.headingCollapsed = collapsing;
        }
        else {
            cell.setHidden(collapsing);
        }
    }
    NotebookActions.setCellCollapse = setCellCollapse;
    /**
     * If given cell is a markdown heading, returns the heading level.
     * If given cell is not markdown, returns 7 (there are only 6 levels of markdown headings)
     *
     * @param cell - The target cell widget.
     */
    function getHeadingInfo(cell) {
        if (!(cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.MarkdownCell)) {
            return { isHeading: false, headingLevel: 7 };
        }
        let level = cell.headingInfo.level;
        let collapsed = cell.headingCollapsed;
        return { isHeading: level > 0, headingLevel: level, collapsed: collapsed };
    }
    NotebookActions.getHeadingInfo = getHeadingInfo;
    /**
     * Trust the notebook after prompting the user.
     *
     * @param notebook - The target notebook widget.
     *
     * @returns a promise that resolves when the transaction is finished.
     *
     * #### Notes
     * No dialog will be presented if the notebook is already trusted.
     */
    function trust(notebook, translator) {
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.nullTranslator;
        const trans = translator.load('jupyterlab');
        if (!notebook.model) {
            return Promise.resolve();
        }
        // Do nothing if already trusted.
        const cells = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.toArray)(notebook.model.cells);
        const trusted = cells.every(cell => cell.trusted);
        // FIXME
        const trustMessage = (react__WEBPACK_IMPORTED_MODULE_7__.createElement("p", null,
            trans.__('A trusted Jupyter notebook may execute hidden malicious code when you open it.'),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement("br", null),
            trans.__('Selecting trust will re-render this notebook in a trusted state.'),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement("br", null),
            trans.__('For more information, see the <a href="https://jupyter-server.readthedocs.io/en/stable/operators/security.html">%1</a>', trans.__('Jupyter security documentation'))));
        if (trusted) {
            return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
                body: trans.__('Notebook is already trusted'),
                buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: trans.__('Ok') })]
            }).then(() => undefined);
        }
        return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
            body: trustMessage,
            title: trans.__('Trust this notebook?'),
            buttons: [
                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.cancelButton({ label: trans.__('Cancel') }),
                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.warnButton({ label: trans.__('Ok') })
            ] // FIXME?
        }).then(result => {
            if (result.button.accept) {
                cells.forEach(cell => {
                    cell.trusted = true;
                });
            }
        });
    }
    NotebookActions.trust = trust;
})(NotebookActions || (NotebookActions = {}));
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A signal that emits whenever a cell completes execution.
     */
    Private.executed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_6__.Signal({});
    /**
     * A signal that emits whenever a cell execution is scheduled.
     */
    Private.executionScheduled = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_6__.Signal({});
    /**
     * A signal that emits when one notebook's cells are all executed.
     */
    Private.selectionExecuted = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_6__.Signal({});
    /**
     * Get the state of a widget before running an action.
     */
    function getState(notebook) {
        return {
            wasFocused: notebook.node.contains(document.activeElement),
            activeCell: notebook.activeCell
        };
    }
    Private.getState = getState;
    /**
     * Handle the state of a widget after running an action.
     */
    function handleState(notebook, state, scrollIfNeeded = false) {
        const { activeCell, node } = notebook;
        if (state.wasFocused || notebook.mode === 'edit') {
            notebook.activate();
        }
        if (scrollIfNeeded && activeCell) {
            _lumino_domutils__WEBPACK_IMPORTED_MODULE_5__.ElementExt.scrollIntoViewIfNeeded(node, activeCell.node);
        }
    }
    Private.handleState = handleState;
    /**
     * Handle the state of a widget after running a run action.
     */
    function handleRunState(notebook, state, scroll = false) {
        if (state.wasFocused || notebook.mode === 'edit') {
            notebook.activate();
        }
        if (scroll && state.activeCell) {
            // Scroll to the top of the previous active cell output.
            const rect = state.activeCell.inputArea.node.getBoundingClientRect();
            notebook.scrollToPosition(rect.bottom, 45);
        }
    }
    Private.handleRunState = handleRunState;
    /**
     * Clone a cell model.
     */
    function cloneCell(model, cell) {
        switch (cell.type) {
            case 'code':
                // TODO why isn't modeldb or id passed here?
                return model.contentFactory.createCodeCell({ cell: cell.toJSON() });
            case 'markdown':
                // TODO why isn't modeldb or id passed here?
                return model.contentFactory.createMarkdownCell({ cell: cell.toJSON() });
            default:
                // TODO why isn't modeldb or id passed here?
                return model.contentFactory.createRawCell({ cell: cell.toJSON() });
        }
    }
    Private.cloneCell = cloneCell;
    /**
     * Run the selected cells.
     */
    function runSelected(notebook, sessionContext) {
        notebook.mode = 'command';
        let lastIndex = notebook.activeCellIndex;
        const selected = notebook.widgets.filter((child, index) => {
            const active = notebook.isSelectedOrActive(child);
            if (active) {
                lastIndex = index;
            }
            return active;
        });
        notebook.activeCellIndex = lastIndex;
        notebook.deselectAll();
        return Promise.all(selected.map(child => runCell(notebook, child, sessionContext)))
            .then(results => {
            if (notebook.isDisposed) {
                return false;
            }
            Private.selectionExecuted.emit({
                notebook,
                lastCell: notebook.widgets[lastIndex]
            });
            // Post an update request.
            notebook.update();
            return results.every(result => result);
        })
            .catch(reason => {
            if (reason.message.startsWith('KernelReplyNotOK')) {
                selected.map(cell => {
                    // Remove '*' prompt from cells that didn't execute
                    if (cell.model.type === 'code' &&
                        cell.model.executionCount == null) {
                        cell.setPrompt('');
                    }
                });
            }
            else {
                throw reason;
            }
            Private.selectionExecuted.emit({
                notebook,
                lastCell: notebook.widgets[lastIndex]
            });
            notebook.update();
            return false;
        });
    }
    Private.runSelected = runSelected;
    /**
     * Run a cell.
     */
    function runCell(notebook, cell, sessionContext, translator) {
        var _a, _b, _c;
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.nullTranslator;
        const trans = translator.load('jupyterlab');
        switch (cell.model.type) {
            case 'markdown':
                cell.rendered = true;
                cell.inputHidden = false;
                Private.executed.emit({ notebook, cell, success: true });
                break;
            case 'code':
                if (sessionContext) {
                    if (sessionContext.isTerminating) {
                        void (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
                            title: trans.__('Kernel Terminating'),
                            body: trans.__('The kernel for %1 appears to be terminating. You can not run any cell for now.', (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),
                            buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: trans.__('Ok') })]
                        });
                        break;
                    }
                    if (sessionContext.pendingInput) {
                        void (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
                            title: trans.__('Waiting on User Input'),
                            body: trans.__('Did not run selected cell because there is a cell waiting on input! Submit your input and try again.'),
                            buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: trans.__('Ok') })]
                        });
                        return Promise.resolve(false);
                    }
                    const deletedCells = (_c = (_b = notebook.model) === null || _b === void 0 ? void 0 : _b.deletedCells) !== null && _c !== void 0 ? _c : [];
                    Private.executionScheduled.emit({ notebook, cell });
                    return _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.CodeCell.execute(cell, sessionContext, {
                        deletedCells,
                        recordTiming: notebook.notebookConfig.recordTiming
                    })
                        .then(reply => {
                        deletedCells.splice(0, deletedCells.length);
                        if (cell.isDisposed) {
                            return false;
                        }
                        if (!reply) {
                            return true;
                        }
                        if (reply.content.status === 'ok') {
                            const content = reply.content;
                            if (content.payload && content.payload.length) {
                                handlePayload(content, notebook, cell);
                            }
                            return true;
                        }
                        else {
                            throw new KernelError(reply.content);
                        }
                    })
                        .catch(reason => {
                        if (cell.isDisposed || reason.message.startsWith('Canceled')) {
                            return false;
                        }
                        Private.executed.emit({ notebook, cell, success: false, error: reason });
                        throw reason;
                    })
                        .then(ran => {
                        if (ran) {
                            Private.executed.emit({ notebook, cell, success: true });
                        }
                        return ran;
                    });
                }
                cell.model.clearExecution();
                break;
            default:
                break;
        }
        return Promise.resolve(true);
    }
    /**
     * Handle payloads from an execute reply.
     *
     * #### Notes
     * Payloads are deprecated and there are no official interfaces for them in
     * the kernel type definitions.
     * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).
     */
    function handlePayload(content, notebook, cell) {
        var _a;
        const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter(i => {
            return i.source === 'set_next_input';
        })[0];
        if (!setNextInput) {
            return;
        }
        const text = setNextInput.text;
        const replace = setNextInput.replace;
        if (replace) {
            cell.model.value.text = text;
            return;
        }
        // Create a new code cell and add as the next cell.
        const newCell = notebook.model.contentFactory.createCodeCell({});
        const cells = notebook.model.cells;
        const index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.firstIndexOf((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.toArray)(cells), cell.model);
        newCell.value.text = text;
        if (index === -1) {
            cells.push(newCell);
        }
        else {
            cells.insert(index + 1, newCell);
        }
    }
    /**
     * Copy or cut the selected cell data to the application clipboard.
     *
     * @param notebook - The target notebook widget.
     *
     * @param cut - Whether to copy or cut.
     */
    function copyOrCut(notebook, cut) {
        if (!notebook.model || !notebook.activeCell) {
            return;
        }
        const state = getState(notebook);
        const clipboard = _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Clipboard.getInstance();
        notebook.mode = 'command';
        clipboard.clear();
        const data = notebook.widgets
            .filter(cell => notebook.isSelectedOrActive(cell))
            .map(cell => cell.model.toJSON())
            .map(cellJSON => {
            if (cellJSON.metadata.deletable !== undefined) {
                delete cellJSON.metadata.deletable;
            }
            return cellJSON;
        });
        clipboard.setData(JUPYTER_CELL_MIME, data);
        if (cut) {
            deleteCells(notebook);
        }
        else {
            notebook.deselectAll();
        }
        handleState(notebook, state);
    }
    Private.copyOrCut = copyOrCut;
    /**
     * Change the selected cell type(s).
     *
     * @param notebook - The target notebook widget.
     *
     * @param value - The target cell type.
     *
     * #### Notes
     * It should preserve the widget mode.
     * This action can be undone.
     * The existing selection will be cleared.
     * Any cells converted to markdown will be unrendered.
     */
    function changeCellType(notebook, value) {
        const model = notebook.model;
        const cells = model.cells;
        cells.beginCompoundOperation();
        notebook.widgets.forEach((child, index) => {
            if (!notebook.isSelectedOrActive(child)) {
                return;
            }
            if (child.model.type !== value) {
                const cell = child.model.toJSON();
                let newCell;
                switch (value) {
                    case 'code':
                        newCell = model.contentFactory.createCodeCell({ cell });
                        break;
                    case 'markdown':
                        newCell = model.contentFactory.createMarkdownCell({ cell });
                        if (child.model.type === 'code') {
                            newCell.trusted = false;
                        }
                        break;
                    default:
                        newCell = model.contentFactory.createRawCell({ cell });
                        if (child.model.type === 'code') {
                            newCell.trusted = false;
                        }
                }
                cells.set(index, newCell);
            }
            if (value === 'markdown') {
                // Fetch the new widget and unrender it.
                child = notebook.widgets[index];
                child.rendered = false;
            }
        });
        cells.endCompoundOperation();
        notebook.deselectAll();
    }
    Private.changeCellType = changeCellType;
    /**
     * Delete the selected cells.
     *
     * @param notebook - The target notebook widget.
     *
     * #### Notes
     * The cell after the last selected cell will be activated.
     * If the last cell is deleted, then the previous one will be activated.
     * It will add a code cell if all cells are deleted.
     * This action can be undone.
     */
    function deleteCells(notebook) {
        const model = notebook.model;
        const cells = model.cells;
        const toDelete = [];
        notebook.mode = 'command';
        // Find the cells to delete.
        notebook.widgets.forEach((child, index) => {
            const deletable = child.model.metadata.get('deletable') !== false;
            if (notebook.isSelectedOrActive(child) && deletable) {
                toDelete.push(index);
                model.deletedCells.push(child.model.id);
            }
        });
        // If cells are not deletable, we may not have anything to delete.
        if (toDelete.length > 0) {
            // Delete the cells as one undo event.
            cells.beginCompoundOperation();
            // Delete cells in reverse order to maintain the correct indices.
            toDelete.reverse().forEach(index => {
                cells.remove(index);
            });
            // Add a new cell if the notebook is empty. This is done
            // within the compound operation to make the deletion of
            // a notebook's last cell undoable.
            if (!cells.length) {
                cells.push(model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {}));
            }
            cells.endCompoundOperation();
            // Select the *first* interior cell not deleted or the cell
            // *after* the last selected cell.
            // Note: The activeCellIndex is clamped to the available cells,
            // so if the last cell is deleted the previous cell will be activated.
            // The *first* index is the index of the last cell in the initial
            // toDelete list due to the `reverse` operation above.
            notebook.activeCellIndex = toDelete[0] - toDelete.length + 1;
        }
        // Deselect any remaining, undeletable cells. Do this even if we don't
        // delete anything so that users are aware *something* happened.
        notebook.deselectAll();
    }
    Private.deleteCells = deleteCells;
    /**
     * Set the markdown header level of a cell.
     */
    function setMarkdownHeader(cell, level) {
        // Remove existing header or leading white space.
        let source = cell.value.text;
        const regex = /^(#+\s*)|^(\s*)/;
        const newHeader = Array(level + 1).join('#') + ' ';
        const matches = regex.exec(source);
        if (matches) {
            source = source.slice(matches[0].length);
        }
        cell.value.text = newHeader + source;
    }
    Private.setMarkdownHeader = setMarkdownHeader;
})(Private || (Private = {}));
//# sourceMappingURL=actions.js.map

/***/ }),

/***/ 23615:
/*!***************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/celllist.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellList": () => (/* binding */ CellList)
/* harmony export */ });
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/observables */ 86780);
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/shared-models */ 62621);
/* harmony import */ var _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/algorithm */ 62867);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/signaling */ 75138);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_3__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * A cell list object that supports undo/redo.
 */
class CellList {
    /**
     * Construct the cell list.
     */
    constructor(modelDB, factory, model) {
        /**
         * Prevents that the modeldb event handler is executed when the shared-model event handler is executed and vice-versa.
         */
        this._mutex = _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_1__.createMutex();
        this._isDisposed = false;
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_3__.Signal(this);
        this._factory = factory;
        this._cellOrder = modelDB.createList('cellOrder');
        this._cellMap = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__.ObservableMap();
        this._cellOrder.changed.connect(this._onOrderChanged, this);
        this.nbmodel = model;
        this.nbmodel.changed.connect(this.onSharedModelChanged, this);
        this.changed.connect(this.onModelDBChanged, this);
    }
    onModelDBChanged(self, change) {
        this._mutex(() => {
            const nbmodel = this.nbmodel;
            nbmodel.transact(() => {
                if (change.type === 'set' || change.type === 'remove') {
                    nbmodel.deleteCellRange(change.oldIndex, change.oldIndex + change.oldValues.length);
                }
                if (change.type === 'set' ||
                    change.type === 'add' ||
                    change.type === 'move') {
                    const cells = change.newValues.map(cell => {
                        return cell.sharedModel.clone();
                    });
                    let insertLocation = change.newIndex;
                    if (change.type === 'move' && insertLocation > change.oldIndex) {
                        insertLocation += change.oldValues.length;
                    }
                    nbmodel.insertCells(insertLocation, cells);
                    change.newValues.forEach((cell, index) => {
                        cell.switchSharedModel(cells[index], false);
                    });
                }
                if (change.type === 'move') {
                    let from = change.oldIndex;
                    if (from >= change.newIndex) {
                        from += change.oldValues.length;
                    }
                    nbmodel.deleteCellRange(from, from + change.oldValues.length);
                }
            });
        });
    }
    onSharedModelChanged(self, change) {
        this._mutex(() => {
            var _a;
            let currpos = 0;
            (_a = change.cellsChange) === null || _a === void 0 ? void 0 : _a.forEach(delta => {
                if (delta.insert != null) {
                    const cells = delta.insert.map(nbcell => {
                        const cell = this._factory.createCell(nbcell.cell_type, {});
                        cell.switchSharedModel(nbcell, true);
                        return cell;
                    });
                    this.insertAll(currpos, cells);
                    currpos += delta.insert.length;
                }
                else if (delta.delete != null) {
                    this.removeRange(currpos, currpos + delta.delete);
                }
                else if (delta.retain != null) {
                    currpos += delta.retain;
                }
            });
        });
    }
    /**
     * A signal emitted when the cell list has changed.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Test whether the cell list has been disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Test whether the list is empty.
     *
     * @returns `true` if the cell list is empty, `false` otherwise.
     *
     * #### Notes
     * This is a read-only property.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    get isEmpty() {
        return this._cellOrder.length === 0;
    }
    /**
     * Get the length of the cell list.
     *
     * @return The number of cells in the cell list.
     *
     * #### Notes
     * This is a read-only property.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    get length() {
        return this._cellOrder.length;
    }
    /**
     * Create an iterator over the cells in the cell list.
     *
     * @returns A new iterator starting at the front of the cell list.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    iter() {
        const arr = [];
        for (const id of (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.toArray)(this._cellOrder)) {
            arr.push(this._cellMap.get(id));
        }
        return new _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.ArrayIterator(arr);
    }
    /**
     * Dispose of the resources held by the cell list.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_3__.Signal.clearData(this);
        // Clean up the cell map and cell order objects.
        for (const cell of this._cellMap.values()) {
            cell.dispose();
        }
        this._cellMap.dispose();
        this._cellOrder.dispose();
    }
    /**
     * Get the cell at the specified index.
     *
     * @param index - The positive integer index of interest.
     *
     * @returns The cell at the specified index.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral or out of range.
     */
    get(index) {
        return this._cellMap.get(this._cellOrder.get(index));
    }
    /**
     * Set the cell at the specified index.
     *
     * @param index - The positive integer index of interest.
     *
     * @param cell - The cell to set at the specified index.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral or out of range.
     *
     * #### Notes
     * This should be considered to transfer ownership of the
     * cell to the `CellList`. As such, `cell.dispose()` should
     * not be called by other actors.
     */
    set(index, cell) {
        // Set the internal data structures.
        this._cellMap.set(cell.id, cell);
        this._cellOrder.set(index, cell.id);
    }
    /**
     * Add a cell to the back of the cell list.
     *
     * @param cell - The cell to add to the back of the cell list.
     *
     * @returns The new length of the cell list.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * This should be considered to transfer ownership of the
     * cell to the `CellList`. As such, `cell.dispose()` should
     * not be called by other actors.
     */
    push(cell) {
        // Set the internal data structures.
        this._cellMap.set(cell.id, cell);
        const num = this._cellOrder.push(cell.id);
        return num;
    }
    /**
     * Insert a cell into the cell list at a specific index.
     *
     * @param index - The index at which to insert the cell.
     *
     * @param cell - The cell to set at the specified index.
     *
     * @returns The new length of the cell list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the cell list.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     *
     * #### Notes
     * This should be considered to transfer ownership of the
     * cell to the `CellList`. As such, `cell.dispose()` should
     * not be called by other actors.
     */
    insert(index, cell) {
        // Set the internal data structures.
        this._cellMap.set(cell.id, cell);
        this._cellOrder.insert(index, cell.id);
    }
    /**
     * Remove the first occurrence of a cell from the cell list.
     *
     * @param cell - The cell of interest.
     *
     * @returns The index of the removed cell, or `-1` if the cell
     *   is not contained in the cell list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed cell and beyond are invalidated.
     */
    removeValue(cell) {
        const index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.findFirstIndex((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.toArray)(this._cellOrder), id => this._cellMap.get(id) === cell);
        this.remove(index);
        return index;
    }
    /**
     * Remove and return the cell at a specific index.
     *
     * @param index - The index of the cell of interest.
     *
     * @returns The cell at the specified index, or `undefined` if the
     *   index is out of range.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed cell and beyond are invalidated.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     */
    remove(index) {
        const id = this._cellOrder.get(index);
        this._cellOrder.remove(index);
        const cell = this._cellMap.get(id);
        return cell;
    }
    /**
     * Remove all cells from the cell list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * All current iterators are invalidated.
     */
    clear() {
        this._cellOrder.clear();
    }
    /**
     * Move a cell from one index to another.
     *
     * @parm fromIndex - The index of the element to move.
     *
     * @param toIndex - The index to move the element to.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
     * and beyond are invalidated.
     *
     * #### Undefined Behavior
     * A `fromIndex` or a `toIndex` which is non-integral.
     */
    move(fromIndex, toIndex) {
        this._cellOrder.move(fromIndex, toIndex);
    }
    /**
     * Push a set of cells to the back of the cell list.
     *
     * @param cells - An iterable or array-like set of cells to add.
     *
     * @returns The new length of the cell list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * This should be considered to transfer ownership of the
     * cells to the `CellList`. As such, `cell.dispose()` should
     * not be called by other actors.
     */
    pushAll(cells) {
        const newValues = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.toArray)(cells);
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(newValues, cell => {
            // Set the internal data structures.
            this._cellMap.set(cell.id, cell);
            this._cellOrder.push(cell.id);
        });
        return this.length;
    }
    /**
     * Insert a set of items into the cell list at the specified index.
     *
     * @param index - The index at which to insert the cells.
     *
     * @param cells - The cells to insert at the specified index.
     *
     * @returns The new length of the cell list.
     *
     * #### Complexity.
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the cell list.
     *
     * #### Undefined Behavior.
     * An `index` which is non-integral.
     *
     * #### Notes
     * This should be considered to transfer ownership of the
     * cells to the `CellList`. As such, `cell.dispose()` should
     * not be called by other actors.
     */
    insertAll(index, cells) {
        const newValues = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.toArray)(cells);
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(newValues, cell => {
            this._cellMap.set(cell.id, cell);
            // @todo it looks like this compound operation shoult start before the `each` loop.
            this._cellOrder.beginCompoundOperation();
            this._cellOrder.insert(index++, cell.id);
            this._cellOrder.endCompoundOperation();
        });
        return this.length;
    }
    /**
     * Remove a range of items from the cell list.
     *
     * @param startIndex - The start index of the range to remove (inclusive).
     *
     * @param endIndex - The end index of the range to remove (exclusive).
     *
     * @returns The new length of the cell list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing to the first removed cell and beyond are invalid.
     *
     * #### Undefined Behavior
     * A `startIndex` or `endIndex` which is non-integral.
     */
    removeRange(startIndex, endIndex) {
        this._cellOrder.removeRange(startIndex, endIndex);
        return this.length;
    }
    /**
     * Whether the object can redo changes.
     */
    get canRedo() {
        return this.nbmodel.canRedo();
    }
    /**
     * Whether the object can undo changes.
     */
    get canUndo() {
        return this.nbmodel.canUndo();
    }
    /**
     * Begin a compound operation.
     *
     * @param isUndoAble - Whether the operation is undoable.
     *   The default is `true`.
     */
    beginCompoundOperation(isUndoAble) {
        this._cellOrder.beginCompoundOperation(isUndoAble);
    }
    /**
     * End a compound operation.
     */
    endCompoundOperation() {
        this._cellOrder.endCompoundOperation();
    }
    /**
     * Undo an operation.
     */
    undo() {
        this.nbmodel.undo();
    }
    /**
     * Redo an operation.
     */
    redo() {
        this.nbmodel.redo();
    }
    /**
     * Clear the change stack.
     */
    clearUndo() {
        this.nbmodel.clearUndoHistory();
    }
    _onOrderChanged(order, change) {
        if (change.type === 'add' || change.type === 'set') {
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(change.newValues, id => {
                const existingCell = this._cellMap.get(id);
                if (existingCell == null) {
                    const cellDB = this._factory.modelDB;
                    const cellType = cellDB.createValue(id + '.type');
                    let cell;
                    switch (cellType.get()) {
                        case 'code':
                            cell = this._factory.createCodeCell({ id: id });
                            break;
                        case 'markdown':
                            cell = this._factory.createMarkdownCell({ id: id });
                            break;
                        default:
                            cell = this._factory.createRawCell({ id: id });
                            break;
                    }
                    this._cellMap.set(id, cell);
                }
                else if (!existingCell.sharedModel.isStandalone) {
                    this._mutex(() => {
                        // it does already exist, probably because it was deleted previously and we introduced it
                        // copy it to a fresh codecell instance
                        const cell = existingCell.toJSON();
                        let freshCell = null;
                        switch (cell.cell_type) {
                            case 'code':
                                freshCell = this._factory.createCodeCell({ cell });
                                break;
                            case 'markdown':
                                freshCell = this._factory.createMarkdownCell({ cell });
                                break;
                            default:
                                freshCell = this._factory.createRawCell({ cell });
                                break;
                        }
                        this._cellMap.set(id, freshCell);
                    });
                }
            });
        }
        const newValues = [];
        const oldValues = [];
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(change.newValues, id => {
            newValues.push(this._cellMap.get(id));
        });
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(change.oldValues, id => {
            oldValues.push(this._cellMap.get(id));
        });
        this._changed.emit({
            type: change.type,
            oldIndex: change.oldIndex,
            newIndex: change.newIndex,
            oldValues,
            newValues
        });
    }
}
//# sourceMappingURL=celllist.js.map

/***/ }),

/***/ 91062:
/*!**********************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/default-toolbar.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolbarItems": () => (/* binding */ ToolbarItems),
/* harmony export */   "CellTypeSwitcher": () => (/* binding */ CellTypeSwitcher)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ 65995);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ 2411);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions */ 49508);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





/**
 * The class name added to toolbar cell type dropdown wrapper.
 */
const TOOLBAR_CELLTYPE_CLASS = 'jp-Notebook-toolbarCellType';
/**
 * The class name added to toolbar cell type dropdown.
 */
const TOOLBAR_CELLTYPE_DROPDOWN_CLASS = 'jp-Notebook-toolbarCellTypeDropdown';
/**
 * A namespace for the default toolbar items.
 */
var ToolbarItems;
(function (ToolbarItems) {
    /**
     * Create save button toolbar item.
     */
    function createSaveButton(panel, translator) {
        const trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        function onClick() {
            if (panel.context.model.readOnly) {
                return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
                    title: trans.__('Cannot Save'),
                    body: trans.__('Document is read-only'),
                    buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: trans.__('Ok') })]
                });
            }
            void panel.context.save(true).then(() => {
                if (!panel.isDisposed) {
                    return panel.context.createCheckpoint();
                }
            });
        }
        return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.addToolbarButtonClass)(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget.create(react__WEBPACK_IMPORTED_MODULE_3__.createElement(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.UseSignal, { signal: panel.context.fileChanged }, () => (react__WEBPACK_IMPORTED_MODULE_3__.createElement(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButtonComponent, { icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.saveIcon, onClick: onClick, tooltip: trans.__('Save the notebook contents and create checkpoint'), enabled: !!(panel &&
                panel.context &&
                panel.context.contentsModel &&
                panel.context.contentsModel.writable) })))));
    }
    ToolbarItems.createSaveButton = createSaveButton;
    /**
     * Create an insert toolbar item.
     */
    function createInsertButton(panel, translator) {
        const trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        return new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.addIcon,
            onClick: () => {
                _actions__WEBPACK_IMPORTED_MODULE_4__.NotebookActions.insertBelow(panel.content);
            },
            tooltip: trans.__('Insert a cell below')
        });
    }
    ToolbarItems.createInsertButton = createInsertButton;
    /**
     * Create a cut toolbar item.
     */
    function createCutButton(panel, translator) {
        const trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        return new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.cutIcon,
            onClick: () => {
                _actions__WEBPACK_IMPORTED_MODULE_4__.NotebookActions.cut(panel.content);
            },
            tooltip: trans.__('Cut the selected cells')
        });
    }
    ToolbarItems.createCutButton = createCutButton;
    /**
     * Create a copy toolbar item.
     */
    function createCopyButton(panel, translator) {
        const trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        return new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.copyIcon,
            onClick: () => {
                _actions__WEBPACK_IMPORTED_MODULE_4__.NotebookActions.copy(panel.content);
            },
            tooltip: trans.__('Copy the selected cells')
        });
    }
    ToolbarItems.createCopyButton = createCopyButton;
    /**
     * Create a paste toolbar item.
     */
    function createPasteButton(panel, translator) {
        const trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        return new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.pasteIcon,
            onClick: () => {
                _actions__WEBPACK_IMPORTED_MODULE_4__.NotebookActions.paste(panel.content);
            },
            tooltip: trans.__('Paste cells from the clipboard')
        });
    }
    ToolbarItems.createPasteButton = createPasteButton;
    /**
     * Create a run toolbar item.
     */
    function createRunButton(panel, translator) {
        const trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        return new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.runIcon,
            onClick: () => {
                void _actions__WEBPACK_IMPORTED_MODULE_4__.NotebookActions.runAndAdvance(panel.content, panel.sessionContext);
            },
            tooltip: trans.__('Run the selected cells and advance')
        });
    }
    ToolbarItems.createRunButton = createRunButton;
    /**
     * Create a restart run all toolbar item
     */
    function createRestartRunAllButton(panel, dialogs, translator) {
        const trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        return new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.fastForwardIcon,
            onClick: () => {
                void (dialogs !== null && dialogs !== void 0 ? dialogs : _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.sessionContextDialogs)
                    .restart(panel.sessionContext, translator)
                    .then(restarted => {
                    if (restarted) {
                        void _actions__WEBPACK_IMPORTED_MODULE_4__.NotebookActions.runAll(panel.content, panel.sessionContext);
                    }
                    return restarted;
                });
            },
            tooltip: trans.__('Restart the kernel, then re-run the whole notebook')
        });
    }
    ToolbarItems.createRestartRunAllButton = createRestartRunAllButton;
    /**
     * Create a cell type switcher item.
     *
     * #### Notes
     * It will display the type of the current active cell.
     * If more than one cell is selected but are of different types,
     * it will display `'-'`.
     * When the user changes the cell type, it will change the
     * cell types of the selected cells.
     * It can handle a change to the context.
     */
    function createCellTypeItem(panel, translator) {
        return new CellTypeSwitcher(panel.content, translator);
    }
    ToolbarItems.createCellTypeItem = createCellTypeItem;
    /**
     * Get the default toolbar items for panel
     */
    function getDefaultItems(panel, sessionDialogs, translator) {
        return [
            { name: 'save', widget: createSaveButton(panel, translator) },
            { name: 'insert', widget: createInsertButton(panel, translator) },
            { name: 'cut', widget: createCutButton(panel, translator) },
            { name: 'copy', widget: createCopyButton(panel, translator) },
            { name: 'paste', widget: createPasteButton(panel, translator) },
            { name: 'run', widget: createRunButton(panel, translator) },
            {
                name: 'interrupt',
                widget: _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar.createInterruptButton(panel.sessionContext, translator)
            },
            {
                name: 'restart',
                widget: _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar.createRestartButton(panel.sessionContext, sessionDialogs, translator)
            },
            {
                name: 'restart-and-run',
                widget: createRestartRunAllButton(panel, sessionDialogs, translator)
            },
            { name: 'cellType', widget: createCellTypeItem(panel, translator) },
            { name: 'spacer', widget: _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar.createSpacerItem() },
            {
                name: 'kernelName',
                widget: _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar.createKernelNameItem(panel.sessionContext, sessionDialogs, translator)
            },
            {
                name: 'kernelStatus',
                widget: _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar.createKernelStatusItem(panel.sessionContext, translator)
            }
        ];
    }
    ToolbarItems.getDefaultItems = getDefaultItems;
})(ToolbarItems || (ToolbarItems = {}));
/**
 * A toolbar widget that switches cell types.
 */
class CellTypeSwitcher extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {
    /**
     * Construct a new cell type switcher.
     */
    constructor(widget, translator) {
        super();
        /**
         * Handle `change` events for the HTMLSelect component.
         */
        this.handleChange = (event) => {
            if (event.target.value !== '-') {
                _actions__WEBPACK_IMPORTED_MODULE_4__.NotebookActions.changeCellType(this._notebook, event.target.value);
                this._notebook.activate();
            }
        };
        /**
         * Handle `keydown` events for the HTMLSelect component.
         */
        this.handleKeyDown = (event) => {
            if (event.keyCode === 13) {
                this._notebook.activate();
            }
        };
        this._trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        this.addClass(TOOLBAR_CELLTYPE_CLASS);
        this._notebook = widget;
        if (widget.model) {
            this.update();
        }
        widget.activeCellChanged.connect(this.update, this);
        // Follow a change in the selection.
        widget.selectionChanged.connect(this.update, this);
    }
    render() {
        let value = '-';
        if (this._notebook.activeCell) {
            value = this._notebook.activeCell.model.type;
        }
        for (const widget of this._notebook.widgets) {
            if (this._notebook.isSelectedOrActive(widget)) {
                if (widget.model.type !== value) {
                    value = '-';
                    break;
                }
            }
        }
        return (react__WEBPACK_IMPORTED_MODULE_3__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.HTMLSelect, { className: TOOLBAR_CELLTYPE_DROPDOWN_CLASS, onChange: this.handleChange, onKeyDown: this.handleKeyDown, value: value, "aria-label": this._trans.__('Cell type'), title: this._trans.__('Select the cell type') },
            react__WEBPACK_IMPORTED_MODULE_3__.createElement("option", { value: "-" }, "-"),
            react__WEBPACK_IMPORTED_MODULE_3__.createElement("option", { value: "code" }, this._trans.__('Code')),
            react__WEBPACK_IMPORTED_MODULE_3__.createElement("option", { value: "markdown" }, this._trans.__('Markdown')),
            react__WEBPACK_IMPORTED_MODULE_3__.createElement("option", { value: "raw" }, this._trans.__('Raw'))));
    }
}
//# sourceMappingURL=default-toolbar.js.map

/***/ }),

/***/ 63299:
/*!************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KernelError": () => (/* reexport safe */ _actions__WEBPACK_IMPORTED_MODULE_0__.KernelError),
/* harmony export */   "NotebookActions": () => (/* reexport safe */ _actions__WEBPACK_IMPORTED_MODULE_0__.NotebookActions),
/* harmony export */   "CellTypeSwitcher": () => (/* reexport safe */ _default_toolbar__WEBPACK_IMPORTED_MODULE_1__.CellTypeSwitcher),
/* harmony export */   "ToolbarItems": () => (/* reexport safe */ _default_toolbar__WEBPACK_IMPORTED_MODULE_1__.ToolbarItems),
/* harmony export */   "NotebookModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_2__.NotebookModel),
/* harmony export */   "NotebookModelFactory": () => (/* reexport safe */ _modelfactory__WEBPACK_IMPORTED_MODULE_3__.NotebookModelFactory),
/* harmony export */   "CommandEditStatus": () => (/* reexport safe */ _modestatus__WEBPACK_IMPORTED_MODULE_4__.CommandEditStatus),
/* harmony export */   "NotebookTools": () => (/* reexport safe */ _notebooktools__WEBPACK_IMPORTED_MODULE_5__.NotebookTools),
/* harmony export */   "NotebookPanel": () => (/* reexport safe */ _panel__WEBPACK_IMPORTED_MODULE_6__.NotebookPanel),
/* harmony export */   "INotebookTools": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.INotebookTools),
/* harmony export */   "INotebookTracker": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.INotebookTracker),
/* harmony export */   "INotebookWidgetFactory": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.INotebookWidgetFactory),
/* harmony export */   "NotebookTracker": () => (/* reexport safe */ _tracker__WEBPACK_IMPORTED_MODULE_8__.NotebookTracker),
/* harmony export */   "NotebookTrustStatus": () => (/* reexport safe */ _truststatus__WEBPACK_IMPORTED_MODULE_9__.NotebookTrustStatus),
/* harmony export */   "Notebook": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_10__.Notebook),
/* harmony export */   "StaticNotebook": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_10__.StaticNotebook),
/* harmony export */   "NotebookWidgetFactory": () => (/* reexport safe */ _widgetfactory__WEBPACK_IMPORTED_MODULE_11__.NotebookWidgetFactory)
/* harmony export */ });
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions */ 49508);
/* harmony import */ var _default_toolbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default-toolbar */ 91062);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model */ 38575);
/* harmony import */ var _modelfactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modelfactory */ 75607);
/* harmony import */ var _modestatus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modestatus */ 40502);
/* harmony import */ var _notebooktools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./notebooktools */ 54410);
/* harmony import */ var _panel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./panel */ 91179);
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tokens */ 36434);
/* harmony import */ var _tracker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tracker */ 74075);
/* harmony import */ var _truststatus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./truststatus */ 35665);
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./widget */ 20267);
/* harmony import */ var _widgetfactory__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./widgetfactory */ 61451);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module notebook
 */












//# sourceMappingURL=index.js.map

/***/ }),

/***/ 38575:
/*!************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/model.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookModel": () => (/* binding */ NotebookModel)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/cells */ 96462);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/nbformat */ 48331);
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/observables */ 86780);
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/shared-models */ 62621);
/* harmony import */ var _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/coreutils */ 9727);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lumino/signaling */ 75138);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _celllist__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./celllist */ 23615);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.









/**
 * An implementation of a notebook Model.
 */
class NotebookModel {
    /**
     * Construct a new notebook model.
     */
    constructor(options = {}) {
        /**
         * The shared notebook model.
         */
        this.sharedModel = _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_4__.YNotebook.create();
        this._dirty = false;
        this._readOnly = false;
        this._contentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._nbformat = _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_2__.MAJOR_VERSION;
        this._nbformatMinor = _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_2__.MINOR_VERSION;
        this._isDisposed = false;
        if (options.modelDB) {
            this.modelDB = options.modelDB;
        }
        else {
            this.modelDB = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_3__.ModelDB();
        }
        this._isInitialized = options.isInitialized === false ? false : true;
        const factory = options.contentFactory || NotebookModel.defaultContentFactory;
        this.contentFactory = factory.clone(this.modelDB.view('cells'));
        this._cells = new _celllist__WEBPACK_IMPORTED_MODULE_8__.CellList(this.modelDB, this.contentFactory, this.sharedModel);
        this._trans = (options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_5__.nullTranslator).load('jupyterlab');
        this._cells.changed.connect(this._onCellsChanged, this);
        // Handle initial metadata.
        const metadata = this.modelDB.createMap('metadata');
        if (!metadata.has('language_info')) {
            const name = options.languagePreference || '';
            metadata.set('language_info', { name });
        }
        this._ensureMetadata();
        metadata.changed.connect(this.triggerContentChange, this);
        this._deletedCells = [];
    }
    /**
     * A signal emitted when the document content changes.
     */
    get contentChanged() {
        return this._contentChanged;
    }
    /**
     * A signal emitted when the document state changes.
     */
    get stateChanged() {
        return this._stateChanged;
    }
    /**
     * The dirty state of the document.
     */
    get dirty() {
        return this._dirty;
    }
    set dirty(newValue) {
        if (newValue === this._dirty) {
            return;
        }
        const oldValue = this._dirty;
        this._dirty = newValue;
        this.triggerStateChange({ name: 'dirty', oldValue, newValue });
    }
    /**
     * The read only state of the document.
     */
    get readOnly() {
        return this._readOnly;
    }
    set readOnly(newValue) {
        if (newValue === this._readOnly) {
            return;
        }
        const oldValue = this._readOnly;
        this._readOnly = newValue;
        this.triggerStateChange({ name: 'readOnly', oldValue, newValue });
    }
    /**
     * The metadata associated with the notebook.
     */
    get metadata() {
        return this.modelDB.get('metadata');
    }
    /**
     * Get the observable list of notebook cells.
     */
    get cells() {
        return this._cells;
    }
    /**
     * The major version number of the nbformat.
     */
    get nbformat() {
        return this._nbformat;
    }
    /**
     * The minor version number of the nbformat.
     */
    get nbformatMinor() {
        return this._nbformatMinor;
    }
    /**
     * The default kernel name of the document.
     */
    get defaultKernelName() {
        const spec = this.metadata.get('kernelspec');
        return spec ? spec.name : '';
    }
    /**
     * A list of deleted cells for the notebook..
     */
    get deletedCells() {
        return this._deletedCells;
    }
    /**
     * If the model is initialized or not.
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * The default kernel language of the document.
     */
    get defaultKernelLanguage() {
        const info = this.metadata.get('language_info');
        return info ? info.name : '';
    }
    /**
     * Dispose of the resources held by the model.
     */
    dispose() {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        const cells = this.cells;
        this._cells = null;
        cells.dispose();
        this._isDisposed = true;
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal.clearData(this);
    }
    /**
     * Serialize the model to a string.
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
    /**
     * Deserialize the model from a string.
     *
     * #### Notes
     * Should emit a [contentChanged] signal.
     */
    fromString(value) {
        this.fromJSON(JSON.parse(value));
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        var _a, _b;
        const cells = [];
        for (let i = 0; i < ((_b = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i++) {
            const cell = this.cells.get(i).toJSON();
            if (this._nbformat === 4 && this._nbformatMinor <= 4) {
                // strip cell ids if we have notebook format 4.0-4.4
                delete cell.id;
            }
            cells.push(cell);
        }
        this._ensureMetadata();
        const metadata = Object.create(null);
        for (const key of this.metadata.keys()) {
            metadata[key] = JSON.parse(JSON.stringify(this.metadata.get(key)));
        }
        return {
            metadata,
            nbformat_minor: this._nbformatMinor,
            nbformat: this._nbformat,
            cells
        };
    }
    /**
     * Deserialize the model from JSON.
     *
     * #### Notes
     * Should emit a [contentChanged] signal.
     */
    fromJSON(value) {
        const cells = [];
        const factory = this.contentFactory;
        const useId = value.nbformat === 4 && value.nbformat_minor >= 5;
        for (const cell of value.cells) {
            const options = { cell };
            if (useId) {
                options.id = cell.id;
            }
            switch (cell.cell_type) {
                case 'code':
                    cells.push(factory.createCodeCell(options));
                    break;
                case 'markdown':
                    cells.push(factory.createMarkdownCell(options));
                    break;
                case 'raw':
                    cells.push(factory.createRawCell(options));
                    break;
                default:
                    continue;
            }
        }
        this.cells.beginCompoundOperation();
        this.cells.clear();
        this.cells.pushAll(cells);
        this.cells.endCompoundOperation();
        let oldValue = 0;
        let newValue = 0;
        this._nbformatMinor = _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_2__.MINOR_VERSION;
        this._nbformat = _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_2__.MAJOR_VERSION;
        const origNbformat = value.metadata.orig_nbformat;
        if (value.nbformat !== this._nbformat) {
            oldValue = this._nbformat;
            this._nbformat = newValue = value.nbformat;
            this.triggerStateChange({ name: 'nbformat', oldValue, newValue });
        }
        if (value.nbformat_minor > this._nbformatMinor) {
            oldValue = this._nbformatMinor;
            this._nbformatMinor = newValue = value.nbformat_minor;
            this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });
        }
        // Alert the user if the format changes.
        if (origNbformat !== undefined && this._nbformat !== origNbformat) {
            const newer = this._nbformat > origNbformat;
            let msg;
            if (newer) {
                msg = this._trans.__(`This notebook has been converted from an older notebook format (v%1)
to the current notebook format (v%2).
The next time you save this notebook, the current notebook format (vthis._nbformat) will be used.
'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,
close the notebook without saving it.`, origNbformat, this._nbformat);
            }
            else {
                msg = this._trans.__(`This notebook has been converted from an newer notebook format (v%1)
to the current notebook format (v%2).
The next time you save this notebook, the current notebook format (v%2) will be used.
Some features of the original notebook may not be available.' To preserve the original format version,
close the notebook without saving it.`, origNbformat, this._nbformat);
            }
            void (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
                title: this._trans.__('Notebook converted'),
                body: msg,
                buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: this._trans.__('Ok') })]
            });
        }
        // Update the metadata.
        this.metadata.clear();
        const metadata = value.metadata;
        for (const key in metadata) {
            // orig_nbformat is not intended to be stored per spec.
            if (key === 'orig_nbformat') {
                continue;
            }
            this.metadata.set(key, metadata[key]);
        }
        this._ensureMetadata();
        this.dirty = true;
    }
    /**
     * Initialize the model with its current state.
     *
     * # Notes
     * Adds an empty code cell if the model is empty
     * and clears undo state.
     */
    initialize() {
        if (!this.cells.length) {
            const factory = this.contentFactory;
            this.cells.push(factory.createCodeCell({}));
        }
        this._isInitialized = true;
        this.cells.clearUndo();
    }
    /**
     * Handle a change in the cells list.
     */
    _onCellsChanged(list, change) {
        switch (change.type) {
            case 'add':
                change.newValues.forEach(cell => {
                    cell.contentChanged.connect(this.triggerContentChange, this);
                });
                break;
            case 'remove':
                break;
            case 'set':
                change.newValues.forEach(cell => {
                    cell.contentChanged.connect(this.triggerContentChange, this);
                });
                break;
            default:
                break;
        }
        this.triggerContentChange();
    }
    /**
     * Make sure we have the required metadata fields.
     */
    _ensureMetadata() {
        const metadata = this.metadata;
        if (!metadata.has('language_info')) {
            metadata.set('language_info', { name: '' });
        }
        if (!metadata.has('kernelspec')) {
            metadata.set('kernelspec', { name: '', display_name: '' });
        }
    }
    /**
     * Trigger a state change signal.
     */
    triggerStateChange(args) {
        this._stateChanged.emit(args);
    }
    /**
     * Trigger a content changed signal.
     */
    triggerContentChange() {
        this._contentChanged.emit(void 0);
        this.dirty = true;
    }
    /**
     * Whether the model is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
}
/**
 * The namespace for the `NotebookModel` class statics.
 */
(function (NotebookModel) {
    /**
     * The default implementation of an `IContentFactory`.
     */
    class ContentFactory {
        /**
         * Create a new cell model factory.
         */
        constructor(options) {
            this.codeCellContentFactory =
                options.codeCellContentFactory || _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.CodeCellModel.defaultContentFactory;
            this.modelDB = options.modelDB;
        }
        /**
         * Create a new cell by cell type.
         *
         * @param type:  the type of the cell to create.
         *
         * @param options: the cell creation options.
         *
         * #### Notes
         * This method is intended to be a convenience method to programmatically
         * call the other cell creation methods in the factory.
         */
        createCell(type, options) {
            switch (type) {
                case 'code':
                    return this.createCodeCell(options);
                case 'markdown':
                    return this.createMarkdownCell(options);
                case 'raw':
                default:
                    return this.createRawCell(options);
            }
        }
        /**
         * Create a new code cell.
         *
         * @param source - The data to use for the original source data.
         *
         * @returns A new code cell. If a source cell is provided, the
         *   new cell will be initialized with the data from the source.
         *   If the contentFactory is not provided, the instance
         *   `codeCellContentFactory` will be used.
         */
        createCodeCell(options) {
            if (options.contentFactory) {
                options.contentFactory = this.codeCellContentFactory;
            }
            if (this.modelDB) {
                if (!options.id) {
                    options.id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.UUID.uuid4();
                }
                options.modelDB = this.modelDB.view(options.id);
            }
            return new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.CodeCellModel(options);
        }
        /**
         * Create a new markdown cell.
         *
         * @param source - The data to use for the original source data.
         *
         * @returns A new markdown cell. If a source cell is provided, the
         *   new cell will be initialized with the data from the source.
         */
        createMarkdownCell(options) {
            if (this.modelDB) {
                if (!options.id) {
                    options.id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.UUID.uuid4();
                }
                options.modelDB = this.modelDB.view(options.id);
            }
            return new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.MarkdownCellModel(options);
        }
        /**
         * Create a new raw cell.
         *
         * @param source - The data to use for the original source data.
         *
         * @returns A new raw cell. If a source cell is provided, the
         *   new cell will be initialized with the data from the source.
         */
        createRawCell(options) {
            if (this.modelDB) {
                if (!options.id) {
                    options.id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.UUID.uuid4();
                }
                options.modelDB = this.modelDB.view(options.id);
            }
            return new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.RawCellModel(options);
        }
        /**
         * Clone the content factory with a new IModelDB.
         */
        clone(modelDB) {
            return new ContentFactory({
                modelDB: modelDB,
                codeCellContentFactory: this.codeCellContentFactory
            });
        }
    }
    NotebookModel.ContentFactory = ContentFactory;
    /**
     * The default `ContentFactory` instance.
     */
    NotebookModel.defaultContentFactory = new ContentFactory({});
})(NotebookModel || (NotebookModel = {}));
//# sourceMappingURL=model.js.map

/***/ }),

/***/ 75607:
/*!*******************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/modelfactory.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookModelFactory": () => (/* binding */ NotebookModelFactory)
/* harmony export */ });
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ 38575);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * A model factory for notebooks.
 */
class NotebookModelFactory {
    /**
     * Construct a new notebook model factory.
     */
    constructor(options) {
        this._disposed = false;
        const codeCellContentFactory = options.codeCellContentFactory;
        this.contentFactory =
            options.contentFactory ||
                new _model__WEBPACK_IMPORTED_MODULE_0__.NotebookModel.ContentFactory({ codeCellContentFactory });
    }
    /**
     * The name of the model.
     */
    get name() {
        return 'notebook';
    }
    /**
     * The content type of the file.
     */
    get contentType() {
        return 'notebook';
    }
    /**
     * The format of the file.
     */
    get fileFormat() {
        return 'json';
    }
    /**
     * Get whether the model factory has been disposed.
     */
    get isDisposed() {
        return this._disposed;
    }
    /**
     * Dispose of the model factory.
     */
    dispose() {
        this._disposed = true;
    }
    /**
     * Create a new model for a given path.
     *
     * @param languagePreference - An optional kernel language preference.
     *
     * @returns A new document model.
     */
    createNew(languagePreference, modelDB, isInitialized) {
        const contentFactory = this.contentFactory;
        return new _model__WEBPACK_IMPORTED_MODULE_0__.NotebookModel({
            languagePreference,
            contentFactory,
            modelDB,
            isInitialized
        });
    }
    /**
     * Get the preferred kernel language given a path.
     */
    preferredLanguage(path) {
        return '';
    }
}
//# sourceMappingURL=modelfactory.js.map

/***/ }),

/***/ 40502:
/*!*****************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/modestatus.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CommandEditStatus": () => (/* binding */ CommandEditStatus)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/coreutils */ 78548);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/statusbar */ 76150);
/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ 2411);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);





/**
 * A pure function for rendering a Command/Edit mode component.
 *
 * @param props: the props for rendering the component.
 *
 * @returns a tsx component for command/edit mode.
 */
function CommandEditComponent(props) {
    const trans = (props.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.nullTranslator).load('jupyterlab');
    return (react__WEBPACK_IMPORTED_MODULE_4__.createElement(_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_2__.TextItem, { source: trans.__('Mode: %1', _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.Text.titleCase(props.notebookMode)) }));
}
/**
 * StatusBar item to display which notebook mode user is in.
 */
class CommandEditStatus extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.VDomRenderer {
    /**
     * Construct a new CommandEdit status item.
     */
    constructor(translator) {
        super(new CommandEditStatus.Model());
        this.translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.nullTranslator;
        this._trans = this.translator.load('jupyterlab');
    }
    /**
     * Render the CommandEdit status item.
     */
    render() {
        if (!this.model) {
            return null;
        }
        this.node.title = this._trans.__('Notebook is in %1 mode', this.model.notebookMode);
        return (react__WEBPACK_IMPORTED_MODULE_4__.createElement(CommandEditComponent, { notebookMode: this.model.notebookMode, translator: this.translator }));
    }
}
/**
 * A namespace for CommandEdit statics.
 */
(function (CommandEditStatus) {
    /**
     * A VDomModel for the CommandEdit renderer.
     */
    class Model extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.VDomModel {
        constructor() {
            super(...arguments);
            /**
             * On a change to the notebook, update the mode.
             */
            this._onChanged = (_notebook) => {
                const oldMode = this._notebookMode;
                if (this._notebook) {
                    this._notebookMode = _notebook.mode;
                }
                else {
                    this._notebookMode = 'command';
                }
                this._triggerChange(oldMode, this._notebookMode);
            };
            this._notebookMode = 'command';
            this._notebook = null;
        }
        /**
         * The current mode of the current notebook.
         */
        get notebookMode() {
            return this._notebookMode;
        }
        /**
         * Set the current notebook for the model.
         */
        set notebook(notebook) {
            const oldNotebook = this._notebook;
            if (oldNotebook !== null) {
                oldNotebook.stateChanged.disconnect(this._onChanged, this);
                oldNotebook.activeCellChanged.disconnect(this._onChanged, this);
                oldNotebook.modelContentChanged.disconnect(this._onChanged, this);
            }
            const oldMode = this._notebookMode;
            this._notebook = notebook;
            if (this._notebook === null) {
                this._notebookMode = 'command';
            }
            else {
                this._notebookMode = this._notebook.mode;
                this._notebook.stateChanged.connect(this._onChanged, this);
                this._notebook.activeCellChanged.connect(this._onChanged, this);
                this._notebook.modelContentChanged.connect(this._onChanged, this);
            }
            this._triggerChange(oldMode, this._notebookMode);
        }
        /**
         * Trigger a state change for the renderer.
         */
        _triggerChange(oldState, newState) {
            if (oldState !== newState) {
                this.stateChanged.emit(void 0);
            }
        }
    }
    CommandEditStatus.Model = Model;
})(CommandEditStatus || (CommandEditStatus = {}));
//# sourceMappingURL=modestatus.js.map

/***/ }),

/***/ 54410:
/*!********************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/notebooktools.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookTools": () => (/* binding */ NotebookTools)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/codeeditor */ 6256);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/observables */ 86780);
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/algorithm */ 62867);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/messaging */ 32151);
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_messaging__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/virtualdom */ 98723);
/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lumino/widgets */ 61389);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_7__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








class RankedPanel extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.Widget {
    constructor() {
        super();
        this._items = [];
        this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.PanelLayout();
        this.addClass('jp-RankedPanel');
    }
    addWidget(widget, rank) {
        const rankItem = { widget, rank };
        const index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.ArrayExt.upperBound(this._items, rankItem, Private.itemCmp);
        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.ArrayExt.insert(this._items, index, rankItem);
        const layout = this.layout;
        layout.insertWidget(index, widget);
    }
    /**
     * Handle the removal of a child
     *
     */
    onChildRemoved(msg) {
        const index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.ArrayExt.findFirstIndex(this._items, item => item.widget === msg.child);
        if (index !== -1) {
            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.ArrayExt.removeAt(this._items, index);
        }
    }
}
/**
 * A widget that provides metadata tools.
 */
class NotebookTools extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.Widget {
    /**
     * Construct a new NotebookTools object.
     */
    constructor(options) {
        super();
        this.addClass('jp-NotebookTools');
        this.translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.nullTranslator;
        this._trans = this.translator.load('jupyterlab');
        this._commonTools = new RankedPanel();
        this._advancedTools = new RankedPanel();
        this._advancedTools.title.label = this._trans.__('Advanced Tools');
        const layout = (this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.PanelLayout());
        layout.addWidget(this._commonTools);
        layout.addWidget(new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Collapse({ widget: this._advancedTools }));
        this._tracker = options.tracker;
        this._tracker.currentChanged.connect(this._onActiveNotebookPanelChanged, this);
        this._tracker.activeCellChanged.connect(this._onActiveCellChanged, this);
        this._tracker.selectionChanged.connect(this._onSelectionChanged, this);
        this._onActiveNotebookPanelChanged();
        this._onActiveCellChanged();
        this._onSelectionChanged();
    }
    /**
     * The active cell widget.
     */
    get activeCell() {
        return this._tracker.activeCell;
    }
    /**
     * The currently selected cells.
     */
    get selectedCells() {
        const panel = this._tracker.currentWidget;
        if (!panel) {
            return [];
        }
        const notebook = panel.content;
        return notebook.widgets.filter(cell => notebook.isSelectedOrActive(cell));
    }
    /**
     * The current notebook.
     */
    get activeNotebookPanel() {
        return this._tracker.currentWidget;
    }
    /**
     * Add a cell tool item.
     */
    addItem(options) {
        var _a;
        const tool = options.tool;
        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : 100;
        let section;
        if (options.section === 'advanced') {
            section = this._advancedTools;
        }
        else {
            section = this._commonTools;
        }
        tool.addClass('jp-NotebookTools-tool');
        section.addWidget(tool, rank);
        // TODO: perhaps the necessary notebookTools functionality should be
        // consolidated into a single object, rather than a broad reference to this.
        tool.notebookTools = this;
        // Trigger the tool to update its active notebook and cell.
        _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.MessageLoop.sendMessage(tool, NotebookTools.ActiveNotebookPanelMessage);
        _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.MessageLoop.sendMessage(tool, NotebookTools.ActiveCellMessage);
    }
    /**
     * Handle a change to the notebook panel.
     */
    _onActiveNotebookPanelChanged() {
        if (this._prevActiveNotebookModel &&
            !this._prevActiveNotebookModel.isDisposed) {
            this._prevActiveNotebookModel.metadata.changed.disconnect(this._onActiveNotebookPanelMetadataChanged, this);
        }
        const activeNBModel = this.activeNotebookPanel && this.activeNotebookPanel.content
            ? this.activeNotebookPanel.content.model
            : null;
        this._prevActiveNotebookModel = activeNBModel;
        if (activeNBModel) {
            activeNBModel.metadata.changed.connect(this._onActiveNotebookPanelMetadataChanged, this);
        }
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.each)(this._toolChildren(), widget => {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.MessageLoop.sendMessage(widget, NotebookTools.ActiveNotebookPanelMessage);
        });
    }
    /**
     * Handle a change to the active cell.
     */
    _onActiveCellChanged() {
        if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {
            this._prevActiveCell.metadata.changed.disconnect(this._onActiveCellMetadataChanged, this);
        }
        const activeCell = this.activeCell ? this.activeCell.model : null;
        this._prevActiveCell = activeCell;
        if (activeCell) {
            activeCell.metadata.changed.connect(this._onActiveCellMetadataChanged, this);
        }
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.each)(this._toolChildren(), widget => {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.MessageLoop.sendMessage(widget, NotebookTools.ActiveCellMessage);
        });
    }
    /**
     * Handle a change in the selection.
     */
    _onSelectionChanged() {
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.each)(this._toolChildren(), widget => {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.MessageLoop.sendMessage(widget, NotebookTools.SelectionMessage);
        });
    }
    /**
     * Handle a change in the active cell metadata.
     */
    _onActiveNotebookPanelMetadataChanged(sender, args) {
        const message = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__.ObservableJSON.ChangeMessage('activenotebookpanel-metadata-changed', args);
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.each)(this._toolChildren(), widget => {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.MessageLoop.sendMessage(widget, message);
        });
    }
    /**
     * Handle a change in the notebook model metadata.
     */
    _onActiveCellMetadataChanged(sender, args) {
        const message = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__.ObservableJSON.ChangeMessage('activecell-metadata-changed', args);
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.each)(this._toolChildren(), widget => {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.MessageLoop.sendMessage(widget, message);
        });
    }
    _toolChildren() {
        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.chain)(this._commonTools.children(), this._advancedTools.children());
    }
}
/**
 * The namespace for NotebookTools class statics.
 */
(function (NotebookTools) {
    /**
     * A singleton conflatable `'activenotebookpanel-changed'` message.
     */
    NotebookTools.ActiveNotebookPanelMessage = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.ConflatableMessage('activenotebookpanel-changed');
    /**
     * A singleton conflatable `'activecell-changed'` message.
     */
    NotebookTools.ActiveCellMessage = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.ConflatableMessage('activecell-changed');
    /**
     * A singleton conflatable `'selection-changed'` message.
     */
    NotebookTools.SelectionMessage = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_5__.ConflatableMessage('selection-changed');
    /**
     * The base notebook tool, meant to be subclassed.
     */
    class Tool extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.Widget {
        dispose() {
            super.dispose();
            if (this.notebookTools) {
                this.notebookTools = null;
            }
        }
        /**
         * Process a message sent to the widget.
         *
         * @param msg - The message sent to the widget.
         */
        processMessage(msg) {
            super.processMessage(msg);
            switch (msg.type) {
                case 'activenotebookpanel-changed':
                    this.onActiveNotebookPanelChanged(msg);
                    break;
                case 'activecell-changed':
                    this.onActiveCellChanged(msg);
                    break;
                case 'selection-changed':
                    this.onSelectionChanged(msg);
                    break;
                case 'activecell-metadata-changed':
                    this.onActiveCellMetadataChanged(msg);
                    break;
                case 'activenotebookpanel-metadata-changed':
                    this.onActiveNotebookPanelMetadataChanged(msg);
                    break;
                default:
                    break;
            }
        }
        /**
         * Handle a change to the notebook panel.
         *
         * #### Notes
         * The default implementation is a no-op.
         */
        onActiveNotebookPanelChanged(msg) {
            /* no-op */
        }
        /**
         * Handle a change to the active cell.
         *
         * #### Notes
         * The default implementation is a no-op.
         */
        onActiveCellChanged(msg) {
            /* no-op */
        }
        /**
         * Handle a change to the selection.
         *
         * #### Notes
         * The default implementation is a no-op.
         */
        onSelectionChanged(msg) {
            /* no-op */
        }
        /**
         * Handle a change to the metadata of the active cell.
         *
         * #### Notes
         * The default implementation is a no-op.
         */
        onActiveCellMetadataChanged(msg) {
            /* no-op */
        }
        /**
         * Handle a change to the metadata of the active cell.
         *
         * #### Notes
         * The default implementation is a no-op.
         */
        onActiveNotebookPanelMetadataChanged(msg) {
            /* no-op */
        }
    }
    NotebookTools.Tool = Tool;
    /**
     * A cell tool displaying the active cell contents.
     */
    class ActiveCellTool extends Tool {
        /**
         * Construct a new active cell tool.
         */
        constructor() {
            super();
            this._model = new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditor.Model();
            this.addClass('jp-ActiveCellTool');
            this.addClass('jp-InputArea');
            this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.PanelLayout();
        }
        /**
         * Dispose of the resources used by the tool.
         */
        dispose() {
            if (this._model === null) {
                return;
            }
            this._model.dispose();
            this._model = null;
            super.dispose();
        }
        /**
         * Handle a change to the active cell.
         */
        onActiveCellChanged() {
            const activeCell = this.notebookTools.activeCell;
            const layout = this.layout;
            const count = layout.widgets.length;
            for (let i = 0; i < count; i++) {
                layout.widgets[0].dispose();
            }
            if (this._cellModel && !this._cellModel.isDisposed) {
                this._cellModel.value.changed.disconnect(this._onValueChanged, this);
                this._cellModel.mimeTypeChanged.disconnect(this._onMimeTypeChanged, this);
            }
            if (!activeCell) {
                const cell = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.Widget();
                cell.addClass('jp-InputArea-editor');
                cell.addClass('jp-InputArea-editor');
                layout.addWidget(cell);
                this._cellModel = null;
                return;
            }
            const promptNode = activeCell.promptNode
                ? activeCell.promptNode.cloneNode(true)
                : undefined;
            const prompt = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.Widget({ node: promptNode });
            const factory = activeCell.contentFactory.editorFactory;
            const cellModel = (this._cellModel = activeCell.model);
            cellModel.value.changed.connect(this._onValueChanged, this);
            cellModel.mimeTypeChanged.connect(this._onMimeTypeChanged, this);
            this._model.value.text = cellModel.value.text.split('\n')[0];
            this._model.mimeType = cellModel.mimeType;
            const model = this._model;
            const editorWidget = new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditorWrapper({ model, factory });
            editorWidget.addClass('jp-InputArea-editor');
            editorWidget.addClass('jp-InputArea-editor');
            editorWidget.editor.setOption('readOnly', true);
            layout.addWidget(prompt);
            layout.addWidget(editorWidget);
        }
        /**
         * Handle a change to the current editor value.
         */
        _onValueChanged() {
            this._model.value.text = this._cellModel.value.text.split('\n')[0];
        }
        /**
         * Handle a change to the current editor mimetype.
         */
        _onMimeTypeChanged() {
            this._model.mimeType = this._cellModel.mimeType;
        }
    }
    NotebookTools.ActiveCellTool = ActiveCellTool;
    /**
     * A raw metadata editor.
     */
    class MetadataEditorTool extends Tool {
        /**
         * Construct a new raw metadata tool.
         */
        constructor(options) {
            super();
            const { editorFactory } = options;
            this.addClass('jp-MetadataEditorTool');
            const layout = (this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.PanelLayout());
            this.editor = new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.JSONEditor({
                editorFactory
            });
            this.editor.title.label = options.label || 'Edit Metadata';
            const titleNode = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.Widget({ node: document.createElement('label') });
            titleNode.node.textContent = options.label || 'Edit Metadata';
            layout.addWidget(titleNode);
            layout.addWidget(this.editor);
        }
    }
    NotebookTools.MetadataEditorTool = MetadataEditorTool;
    /**
     * A notebook metadata editor
     */
    class NotebookMetadataEditorTool extends MetadataEditorTool {
        constructor(options) {
            const translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.nullTranslator;
            const trans = translator.load('jupyterlab');
            options.label = options.label || trans.__('Notebook Metadata');
            super(options);
        }
        /**
         * Handle a change to the notebook.
         */
        onActiveNotebookPanelChanged(msg) {
            this._update();
        }
        /**
         * Handle a change to the notebook metadata.
         */
        onActiveNotebookPanelMetadataChanged(msg) {
            this._update();
        }
        _update() {
            var _a, _b;
            const nb = this.notebookTools.activeNotebookPanel &&
                this.notebookTools.activeNotebookPanel.content;
            this.editor.source = (_b = (_a = nb === null || nb === void 0 ? void 0 : nb.model) === null || _a === void 0 ? void 0 : _a.metadata) !== null && _b !== void 0 ? _b : null;
        }
    }
    NotebookTools.NotebookMetadataEditorTool = NotebookMetadataEditorTool;
    /**
     * A cell metadata editor
     */
    class CellMetadataEditorTool extends MetadataEditorTool {
        constructor(options) {
            const translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.nullTranslator;
            const trans = translator.load('jupyterlab');
            options.label = options.label || trans.__('Cell Metadata');
            super(options);
        }
        /**
         * Handle a change to the active cell.
         */
        onActiveCellChanged(msg) {
            this._update();
        }
        /**
         * Handle a change to the active cell metadata.
         */
        onActiveCellMetadataChanged(msg) {
            this._update();
        }
        _update() {
            const cell = this.notebookTools.activeCell;
            this.editor.source = cell ? cell.model.metadata : null;
        }
    }
    NotebookTools.CellMetadataEditorTool = CellMetadataEditorTool;
    /**
     * A cell tool that provides a selection for a given metadata key.
     */
    class KeySelector extends Tool {
        /**
         * Construct a new KeySelector.
         */
        constructor(options) {
            // TODO: use react
            super({ node: Private.createSelectorNode(options) });
            /**
             * Get the value for the data.
             */
            this._getValue = (cell) => {
                let value = cell.model.metadata.get(this.key);
                if (value === undefined) {
                    value = this._default;
                }
                return value;
            };
            /**
             * Set the value for the data.
             */
            this._setValue = (cell, value) => {
                if (value === this._default) {
                    cell.model.metadata.delete(this.key);
                }
                else {
                    cell.model.metadata.set(this.key, value);
                }
            };
            this._changeGuard = false;
            this.addClass('jp-KeySelector');
            this.key = options.key;
            this._default = options.default;
            this._validCellTypes = options.validCellTypes || [];
            this._getter = options.getter || this._getValue;
            this._setter = options.setter || this._setValue;
        }
        /**
         * The select node for the widget.
         */
        get selectNode() {
            return this.node.getElementsByTagName('select')[0];
        }
        /**
         * Handle the DOM events for the widget.
         *
         * @param event - The DOM event sent to the widget.
         *
         * #### Notes
         * This method implements the DOM `EventListener` interface and is
         * called in response to events on the notebook panel's node. It should
         * not be called directly by user code.
         */
        handleEvent(event) {
            switch (event.type) {
                case 'change':
                    this.onValueChanged();
                    break;
                default:
                    break;
            }
        }
        /**
         * Handle `after-attach` messages for the widget.
         */
        onAfterAttach(msg) {
            const node = this.selectNode;
            node.addEventListener('change', this);
        }
        /**
         * Handle `before-detach` messages for the widget.
         */
        onBeforeDetach(msg) {
            const node = this.selectNode;
            node.removeEventListener('change', this);
        }
        /**
         * Handle a change to the active cell.
         */
        onActiveCellChanged(msg) {
            const select = this.selectNode;
            const activeCell = this.notebookTools.activeCell;
            if (!activeCell) {
                select.disabled = true;
                select.value = '';
                return;
            }
            const cellType = activeCell.model.type;
            if (this._validCellTypes.length &&
                this._validCellTypes.indexOf(cellType) === -1) {
                select.value = '';
                select.disabled = true;
                return;
            }
            select.disabled = false;
            this._changeGuard = true;
            const getter = this._getter;
            select.value = JSON.stringify(getter(activeCell));
            this._changeGuard = false;
        }
        /**
         * Handle a change to the metadata of the active cell.
         */
        onActiveCellMetadataChanged(msg) {
            if (this._changeGuard) {
                return;
            }
            const select = this.selectNode;
            const cell = this.notebookTools.activeCell;
            if (msg.args.key === this.key && cell) {
                this._changeGuard = true;
                const getter = this._getter;
                select.value = JSON.stringify(getter(cell));
                this._changeGuard = false;
            }
        }
        /**
         * Handle a change to the value.
         */
        onValueChanged() {
            const activeCell = this.notebookTools.activeCell;
            if (!activeCell || this._changeGuard) {
                return;
            }
            this._changeGuard = true;
            const select = this.selectNode;
            const setter = this._setter;
            setter(activeCell, JSON.parse(select.value));
            this._changeGuard = false;
        }
    }
    NotebookTools.KeySelector = KeySelector;
    /**
     * Create a slideshow selector.
     */
    function createSlideShowSelector(translator) {
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.nullTranslator;
        const trans = translator.load('jupyterlab');
        trans.__('');
        const options = {
            key: 'slideshow',
            title: trans.__('Slide Type'),
            optionValueArray: [
                ['-', null],
                [trans.__('Slide'), 'slide'],
                [trans.__('Sub-Slide'), 'subslide'],
                [trans.__('Fragment'), 'fragment'],
                [trans.__('Skip'), 'skip'],
                [trans.__('Notes'), 'notes']
            ],
            getter: cell => {
                const value = cell.model.metadata.get('slideshow');
                return value && value['slide_type'];
            },
            setter: (cell, value) => {
                let data = cell.model.metadata.get('slideshow') || Object.create(null);
                if (value === null) {
                    // Make a shallow copy so we aren't modifying the original metadata.
                    data = Object.assign({}, data);
                    delete data.slide_type;
                }
                else {
                    data = Object.assign(Object.assign({}, data), { slide_type: value });
                }
                if (Object.keys(data).length > 0) {
                    cell.model.metadata.set('slideshow', data);
                }
                else {
                    cell.model.metadata.delete('slideshow');
                }
            }
        };
        return new KeySelector(options);
    }
    NotebookTools.createSlideShowSelector = createSlideShowSelector;
    /**
     * Create an nbconvert selector.
     */
    function createNBConvertSelector(optionValueArray, translator) {
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.nullTranslator;
        const trans = translator.load('jupyterlab');
        return new KeySelector({
            key: 'raw_mimetype',
            title: trans.__('Raw NBConvert Format'),
            optionValueArray: optionValueArray,
            validCellTypes: ['raw']
        });
    }
    NotebookTools.createNBConvertSelector = createNBConvertSelector;
})(NotebookTools || (NotebookTools = {}));
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A comparator function for widget rank items.
     */
    function itemCmp(first, second) {
        return first.rank - second.rank;
    }
    Private.itemCmp = itemCmp;
    /**
     * Create the node for a KeySelector.
     */
    function createSelectorNode(options) {
        const name = options.key;
        const title = options.title || name[0].toLocaleUpperCase() + name.slice(1);
        const optionNodes = [];
        let value;
        let option;
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.each)(options.optionValueArray, item => {
            option = item[0];
            value = JSON.stringify(item[1]);
            optionNodes.push(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6__.h.option({ value }, option));
        });
        const node = _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6__.h.div({}, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6__.h.label(title, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_6__.h.select({}, optionNodes))));
        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Styling.styleNode(node);
        return node;
    }
    Private.createSelectorNode = createSelectorNode;
})(Private || (Private = {}));
//# sourceMappingURL=notebooktools.js.map

/***/ }),

/***/ 91179:
/*!************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/panel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookPanel": () => (/* binding */ NotebookPanel)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/cells */ 96462);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/coreutils */ 78548);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/docregistry */ 64984);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/algorithm */ 62867);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/coreutils */ 9727);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./widget */ 20267);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * The class name added to notebook panels.
 */
const NOTEBOOK_PANEL_CLASS = 'jp-NotebookPanel';
const NOTEBOOK_PANEL_TOOLBAR_CLASS = 'jp-NotebookPanel-toolbar';
const NOTEBOOK_PANEL_NOTEBOOK_CLASS = 'jp-NotebookPanel-notebook';
/**
 * The class name to add when the document is loaded for the search box.
 */
const SEARCH_DOCUMENT_LOADED_CLASS = 'jp-DocumentSearch-document-loaded';
/**
 * A widget that hosts a notebook toolbar and content area.
 *
 * #### Notes
 * The widget keeps the document metadata in sync with the current
 * kernel on the context.
 */
class NotebookPanel extends _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3__.DocumentWidget {
    /**
     * Construct a new notebook panel.
     */
    constructor(options) {
        super(options);
        /**
         * Whether we are currently in a series of autorestarts we have already
         * notified the user about.
         */
        this._autorestarting = false;
        this.translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__.nullTranslator;
        this._trans = this.translator.load('jupyterlab');
        // Set up CSS classes
        this.addClass(NOTEBOOK_PANEL_CLASS);
        this.toolbar.addClass(NOTEBOOK_PANEL_TOOLBAR_CLASS);
        this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);
        // Set up things related to the context
        this.content.model = this.context.model;
        this.context.sessionContext.kernelChanged.connect(this._onKernelChanged, this);
        this.context.sessionContext.statusChanged.connect(this._onSessionStatusChanged, this);
        this.content.fullyRendered.connect(this._onFullyRendered, this);
        this.context.saveState.connect(this._onSave, this);
        void this.revealed.then(() => {
            if (this.isDisposed) {
                // this widget has already been disposed, bail
                return;
            }
            // Set the document edit mode on initial open if it looks like a new document.
            if (this.content.widgets.length === 1) {
                const cellModel = this.content.widgets[0].model;
                if (cellModel.type === 'code' && cellModel.value.text === '') {
                    this.content.mode = 'edit';
                }
            }
        });
    }
    _onSave(sender, state) {
        if (state === 'started' && this.model) {
            // Find markdown cells
            const { cells } = this.model;
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__.each)(cells, cell => {
                if ((0,_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.isMarkdownCellModel)(cell)) {
                    for (const key of cell.attachments.keys) {
                        if (!cell.value.text.includes(key)) {
                            cell.attachments.remove(key);
                        }
                    }
                }
            });
        }
    }
    /**
     * The session context used by the panel.
     */
    get sessionContext() {
        return this.context.sessionContext;
    }
    /**
     * The model for the widget.
     */
    get model() {
        return this.content.model;
    }
    /**
     * Update the options for the current notebook panel.
     *
     * @param config new options to set
     */
    setConfig(config) {
        this.content.editorConfig = config.editorConfig;
        this.content.notebookConfig = config.notebookConfig;
        // Update kernel shutdown behavior
        const kernelPreference = this.context.sessionContext.kernelPreference;
        this.context.sessionContext.kernelPreference = Object.assign(Object.assign({}, kernelPreference), { shutdownOnDispose: config.kernelShutdown });
    }
    /**
     * Set URI fragment identifier.
     */
    setFragment(fragment) {
        void this.context.ready.then(() => {
            this.content.setFragment(fragment);
        });
    }
    /**
     * Dispose of the resources used by the widget.
     */
    dispose() {
        this.content.dispose();
        super.dispose();
    }
    /**
     * Prints the notebook by converting to HTML with nbconvert.
     */
    [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Printing.symbol]() {
        return async () => {
            // Save before generating HTML
            if (this.context.model.dirty && !this.context.model.readOnly) {
                await this.context.save();
            }
            await _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Printing.printURL(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getNBConvertURL({
                format: 'html',
                download: false,
                path: this.context.path
            }));
        };
    }
    /**
     * Handle a fully rendered signal notebook.
     */
    _onFullyRendered(notebook, fullyRendered) {
        fullyRendered
            ? this.removeClass(SEARCH_DOCUMENT_LOADED_CLASS)
            : this.addClass(SEARCH_DOCUMENT_LOADED_CLASS);
    }
    /**
     * Handle a change in the kernel by updating the document metadata.
     */
    _onKernelChanged(sender, args) {
        if (!this.model || !args.newValue) {
            return;
        }
        const { newValue } = args;
        void newValue.info.then(info => {
            var _a;
            if (this.model &&
                ((_a = this.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === newValue) {
                this._updateLanguage(info.language_info);
            }
        });
        void this._updateSpec(newValue);
    }
    _onSessionStatusChanged(sender, status) {
        var _a;
        // If the status is autorestarting, and we aren't already in a series of
        // autorestarts, show the dialog.
        if (status === 'autorestarting' && !this._autorestarting) {
            // The kernel died and the server is restarting it. We notify the user so
            // they know why their kernel state is gone.
            void (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
                title: this._trans.__('Kernel Restarting'),
                body: this._trans.__('The kernel for %1 appears to have died. It will restart automatically.', (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),
                buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: this._trans.__('Ok') })]
            });
            this._autorestarting = true;
        }
        else if (status === 'restarting') {
            // Another autorestart attempt will first change the status to
            // restarting, then to autorestarting again, so we don't reset the
            // autorestarting status if the status is 'restarting'.
            /* no-op */
        }
        else {
            this._autorestarting = false;
        }
    }
    /**
     * Update the kernel language.
     */
    _updateLanguage(language) {
        this.model.metadata.set('language_info', language);
    }
    /**
     * Update the kernel spec.
     */
    async _updateSpec(kernel) {
        const spec = await kernel.spec;
        if (this.isDisposed) {
            return;
        }
        this.model.metadata.set('kernelspec', {
            name: kernel.name,
            display_name: spec === null || spec === void 0 ? void 0 : spec.display_name,
            language: spec === null || spec === void 0 ? void 0 : spec.language
        });
    }
}
/**
 * A namespace for `NotebookPanel` statics.
 */
(function (NotebookPanel) {
    /**
     * The default implementation of an `IContentFactory`.
     */
    class ContentFactory extends _widget__WEBPACK_IMPORTED_MODULE_7__.Notebook.ContentFactory {
        /**
         * Create a new content area for the panel.
         */
        createNotebook(options) {
            return new _widget__WEBPACK_IMPORTED_MODULE_7__.Notebook(options);
        }
    }
    NotebookPanel.ContentFactory = ContentFactory;
    /**
     * Default content factory for the notebook panel.
     */
    NotebookPanel.defaultContentFactory = new ContentFactory();
    /* tslint:disable */
    /**
     * The notebook renderer token.
     */
    NotebookPanel.IContentFactory = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.Token('@jupyterlab/notebook:IContentFactory');
    /* tslint:enable */
})(NotebookPanel || (NotebookPanel = {}));
//# sourceMappingURL=panel.js.map

/***/ }),

/***/ 36434:
/*!*************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/tokens.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INotebookWidgetFactory": () => (/* binding */ INotebookWidgetFactory),
/* harmony export */   "INotebookTools": () => (/* binding */ INotebookTools),
/* harmony export */   "INotebookTracker": () => (/* binding */ INotebookTracker)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ 9727);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/* tslint:disable */
/**
 * The notebook widget factory token.
 */
const INotebookWidgetFactory = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/notebook:INotebookWidgetFactory');
/* tslint:enable */
/* tslint:disable */
/**
 * The notebook tools token.
 */
const INotebookTools = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/notebook:INotebookTools');
/* tslint:disable */
/**
 * The notebook tracker token.
 */
const INotebookTracker = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/notebook:INotebookTracker');
//# sourceMappingURL=tokens.js.map

/***/ }),

/***/ 74075:
/*!**************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/tracker.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookTracker": () => (/* binding */ NotebookTracker)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ 75138);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class NotebookTracker extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.WidgetTracker {
    constructor() {
        super(...arguments);
        this._activeCell = null;
        this._activeCellChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._selectionChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
    }
    /**
     * The currently focused cell.
     *
     * #### Notes
     * This is a read-only property. If there is no cell with the focus, then this
     * value is `null`.
     */
    get activeCell() {
        const widget = this.currentWidget;
        if (!widget) {
            return null;
        }
        return widget.content.activeCell || null;
    }
    /**
     * A signal emitted when the current active cell changes.
     *
     * #### Notes
     * If there is no cell with the focus, then `null` will be emitted.
     */
    get activeCellChanged() {
        return this._activeCellChanged;
    }
    /**
     * A signal emitted when the selection state changes.
     */
    get selectionChanged() {
        return this._selectionChanged;
    }
    /**
     * Add a new notebook panel to the tracker.
     *
     * @param panel - The notebook panel being added.
     */
    add(panel) {
        const promise = super.add(panel);
        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);
        panel.content.selectionChanged.connect(this._onSelectionChanged, this);
        return promise;
    }
    /**
     * Dispose of the resources held by the tracker.
     */
    dispose() {
        this._activeCell = null;
        super.dispose();
    }
    /**
     * Handle the current change event.
     */
    onCurrentChanged(widget) {
        // Store an internal reference to active cell to prevent false positives.
        const activeCell = this.activeCell;
        if (activeCell && activeCell === this._activeCell) {
            return;
        }
        this._activeCell = activeCell;
        if (!widget) {
            return;
        }
        // Since the notebook has changed, immediately signal an active cell change
        this._activeCellChanged.emit(widget.content.activeCell || null);
    }
    _onActiveCellChanged(sender, cell) {
        // Check if the active cell change happened for the current notebook.
        if (this.currentWidget && this.currentWidget.content === sender) {
            this._activeCell = cell || null;
            this._activeCellChanged.emit(this._activeCell);
        }
    }
    _onSelectionChanged(sender) {
        // Check if the selection change happened for the current notebook.
        if (this.currentWidget && this.currentWidget.content === sender) {
            this._selectionChanged.emit(void 0);
        }
    }
}
//# sourceMappingURL=tracker.js.map

/***/ }),

/***/ 35665:
/*!******************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/truststatus.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookTrustStatus": () => (/* binding */ NotebookTrustStatus)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ 65995);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/algorithm */ 62867);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ 2411);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);





/**
 * Determine the notebook trust status message.
 */
function cellTrust(props, translator) {
    translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
    const trans = translator.load('jupyterlab');
    if (props.trustedCells === props.totalCells) {
        return [
            trans.__('Notebook trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),
            'jp-StatusItem-trusted'
        ];
    }
    else if (props.activeCellTrusted) {
        return [
            trans.__('Active cell trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),
            'jp-StatusItem-trusted'
        ];
    }
    else {
        return [
            trans.__('Notebook not trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),
            'jp-StatusItem-untrusted'
        ];
    }
}
/**
 * A pure function for a notebook trust status component.
 *
 * @param props: the props for the component.
 *
 * @returns a tsx component for notebook trust.
 */
function NotebookTrustComponent(props) {
    if (props.allCellsTrusted) {
        return react__WEBPACK_IMPORTED_MODULE_4___default().createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.trustedIcon.react, { top: '2px', stylesheet: 'statusBar' });
    }
    else {
        return react__WEBPACK_IMPORTED_MODULE_4___default().createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.notTrustedIcon.react, { top: '2px', stylesheet: 'statusBar' });
    }
}
/**
 * The NotebookTrust status item.
 */
class NotebookTrustStatus extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.VDomRenderer {
    /**
     * Construct a new status item.
     */
    constructor(translator) {
        super(new NotebookTrustStatus.Model());
        this.translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
    }
    /**
     * Render the NotebookTrust status item.
     */
    render() {
        if (!this.model) {
            return null;
        }
        this.node.title = cellTrust(this.model, this.translator)[0];
        return (react__WEBPACK_IMPORTED_MODULE_4___default().createElement("div", null,
            react__WEBPACK_IMPORTED_MODULE_4___default().createElement(NotebookTrustComponent, { allCellsTrusted: this.model.trustedCells === this.model.totalCells, activeCellTrusted: this.model.activeCellTrusted, totalCells: this.model.totalCells, trustedCells: this.model.trustedCells })));
    }
}
/**
 * A namespace for NotebookTrust statics.
 */
(function (NotebookTrustStatus) {
    /**
     * A VDomModel for the NotebookTrust status item.
     */
    class Model extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.VDomModel {
        constructor() {
            super(...arguments);
            this._trustedCells = 0;
            this._totalCells = 0;
            this._activeCellTrusted = false;
            this._notebook = null;
        }
        /**
         * The number of trusted cells in the current notebook.
         */
        get trustedCells() {
            return this._trustedCells;
        }
        /**
         * The total number of cells in the current notebook.
         */
        get totalCells() {
            return this._totalCells;
        }
        /**
         * Whether the active cell is trusted.
         */
        get activeCellTrusted() {
            return this._activeCellTrusted;
        }
        /**
         * The current notebook for the model.
         */
        get notebook() {
            return this._notebook;
        }
        set notebook(model) {
            const oldNotebook = this._notebook;
            if (oldNotebook !== null) {
                oldNotebook.activeCellChanged.disconnect(this._onActiveCellChanged, this);
                oldNotebook.modelContentChanged.disconnect(this._onModelChanged, this);
            }
            const oldState = this._getAllState();
            this._notebook = model;
            if (this._notebook === null) {
                this._trustedCells = 0;
                this._totalCells = 0;
                this._activeCellTrusted = false;
            }
            else {
                // Add listeners
                this._notebook.activeCellChanged.connect(this._onActiveCellChanged, this);
                this._notebook.modelContentChanged.connect(this._onModelChanged, this);
                // Derive values
                if (this._notebook.activeCell !== undefined) {
                    this._activeCellTrusted = this._notebook.activeCell.model.trusted;
                }
                else {
                    this._activeCellTrusted = false;
                }
                const { total, trusted } = this._deriveCellTrustState(this._notebook.model);
                this._totalCells = total;
                this._trustedCells = trusted;
            }
            this._triggerChange(oldState, this._getAllState());
        }
        /**
         * When the notebook model changes, update the trust state.
         */
        _onModelChanged(notebook) {
            const oldState = this._getAllState();
            const { total, trusted } = this._deriveCellTrustState(notebook.model);
            this._totalCells = total;
            this._trustedCells = trusted;
            this._triggerChange(oldState, this._getAllState());
        }
        /**
         * When the active cell changes, update the trust state.
         */
        _onActiveCellChanged(model, cell) {
            const oldState = this._getAllState();
            if (cell) {
                this._activeCellTrusted = cell.model.trusted;
            }
            else {
                this._activeCellTrusted = false;
            }
            this._triggerChange(oldState, this._getAllState());
        }
        /**
         * Given a notebook model, figure out how many of the cells are trusted.
         */
        _deriveCellTrustState(model) {
            if (model === null) {
                return { total: 0, trusted: 0 };
            }
            const cells = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.toArray)(model.cells);
            const trusted = cells.reduce((accum, current) => {
                if (current.trusted) {
                    return accum + 1;
                }
                else {
                    return accum;
                }
            }, 0);
            const total = cells.length;
            return {
                total,
                trusted
            };
        }
        /**
         * Get the current state of the model.
         */
        _getAllState() {
            return [this._trustedCells, this._totalCells, this.activeCellTrusted];
        }
        /**
         * Trigger a change in the renderer.
         */
        _triggerChange(oldState, newState) {
            if (oldState[0] !== newState[0] ||
                oldState[1] !== newState[1] ||
                oldState[2] !== newState[2]) {
                this.stateChanged.emit(void 0);
            }
        }
    }
    NotebookTrustStatus.Model = Model;
})(NotebookTrustStatus || (NotebookTrustStatus = {}));
//# sourceMappingURL=truststatus.js.map

/***/ }),

/***/ 20267:
/*!*************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/widget.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StaticNotebook": () => (/* binding */ StaticNotebook),
/* harmony export */   "Notebook": () => (/* binding */ Notebook)
/* harmony export */ });
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/cells */ 96462);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/codeeditor */ 6256);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/algorithm */ 62867);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/coreutils */ 9727);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/domutils */ 33513);
/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/dragdrop */ 43800);
/* harmony import */ var _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lumino_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/properties */ 72189);
/* harmony import */ var _lumino_properties__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_properties__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lumino/signaling */ 75138);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lumino/virtualdom */ 98723);
/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lumino/widgets */ 61389);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./actions */ 49508);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.











/**
 * The data attribute added to a widget that has an active kernel.
 */
const KERNEL_USER = 'jpKernelUser';
/**
 * The data attribute added to a widget that can run code.
 */
const CODE_RUNNER = 'jpCodeRunner';
/**
 * The data attribute added to a widget that can undo.
 */
const UNDOER = 'jpUndoer';
/**
 * The class name added to notebook widgets.
 */
const NB_CLASS = 'jp-Notebook';
/**
 * The class name added to notebook widget cells.
 */
const NB_CELL_CLASS = 'jp-Notebook-cell';
/**
 * The class name added to a notebook in edit mode.
 */
const EDIT_CLASS = 'jp-mod-editMode';
/**
 * The class name added to a notebook in command mode.
 */
const COMMAND_CLASS = 'jp-mod-commandMode';
/**
 * The class name added to the active cell.
 */
const ACTIVE_CLASS = 'jp-mod-active';
/**
 * The class name added to selected cells.
 */
const SELECTED_CLASS = 'jp-mod-selected';
/**
 * The class name added to an active cell when there are other selected cells.
 */
const OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';
/**
 * The class name added to unconfined images.
 */
const UNCONFINED_CLASS = 'jp-mod-unconfined';
/**
 * The class name added to a drop target.
 */
const DROP_TARGET_CLASS = 'jp-mod-dropTarget';
/**
 * The class name added to a drop source.
 */
const DROP_SOURCE_CLASS = 'jp-mod-dropSource';
/**
 * The class name added to drag images.
 */
const DRAG_IMAGE_CLASS = 'jp-dragImage';
/**
 * The class name added to singular drag images
 */
const SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';
/**
 * The class name added to the drag image cell content.
 */
const CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';
/**
 * The class name added to the drag image cell content.
 */
const CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';
/**
 * The class name added to the drag image cell content.
 */
const CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';
/**
 * The mimetype used for Jupyter cell data.
 */
const JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';
/**
 * The threshold in pixels to start a drag event.
 */
const DRAG_THRESHOLD = 5;
/**
 * The class attached to the heading collapser button
 */
const HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';
if (window.requestIdleCallback === undefined) {
    // On Safari, requestIdleCallback is not available, so we use replacement functions for `idleCallbacks`
    // See: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#falling_back_to_settimeout
    window.requestIdleCallback = function (handler) {
        let startTime = Date.now();
        return setTimeout(function () {
            handler({
                didTimeout: false,
                timeRemaining: function () {
                    return Math.max(0, 50.0 - (Date.now() - startTime));
                }
            });
        }, 1);
    };
    window.cancelIdleCallback = function (id) {
        clearTimeout(id);
    };
}
/**
 * A widget which renders static non-interactive notebooks.
 *
 * #### Notes
 * The widget model must be set separately and can be changed
 * at any time.  Consumers of the widget must account for a
 * `null` model, and may want to listen to the `modelChanged`
 * signal.
 */
class StaticNotebook extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_9__.Widget {
    /**
     * Construct a notebook widget.
     */
    constructor(options) {
        super();
        this._editorConfig = StaticNotebook.defaultEditorConfig;
        this._notebookConfig = StaticNotebook.defaultNotebookConfig;
        this._mimetype = 'text/plain';
        this._model = null;
        this._modelChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._modelContentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._fullyRendered = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._placeholderCellRendered = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._renderedCellsCount = 0;
        this.addClass(NB_CLASS);
        this.node.dataset[KERNEL_USER] = 'true';
        this.node.dataset[UNDOER] = 'true';
        this.node.dataset[CODE_RUNNER] = 'true';
        this.rendermime = options.rendermime;
        this.layout = new Private.NotebookPanelLayout();
        this.contentFactory =
            options.contentFactory || StaticNotebook.defaultContentFactory;
        this.editorConfig =
            options.editorConfig || StaticNotebook.defaultEditorConfig;
        this.notebookConfig =
            options.notebookConfig || StaticNotebook.defaultNotebookConfig;
        this._mimetypeService = options.mimeTypeService;
        // Section for the virtual-notebook behavior.
        this._toRenderMap = new Map();
        this._cellsArray = new Array();
        if ('IntersectionObserver' in window) {
            this._observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(o => {
                    if (o.isIntersecting) {
                        observer.unobserve(o.target);
                        const ci = this._toRenderMap.get(o.target.id);
                        if (ci) {
                            const { cell, index } = ci;
                            this._renderPlaceholderCell(cell, index);
                        }
                    }
                });
            }, {
                root: this.node,
                threshold: 1,
                rootMargin: `${this.notebookConfig.observedTopMargin} 0px ${this.notebookConfig.observedBottomMargin} 0px`
            });
        }
    }
    /**
     * A signal emitted when the notebook is fully rendered.
     */
    get fullyRendered() {
        return this._fullyRendered;
    }
    /**
     * A signal emitted when the a placeholder cell is rendered.
     */
    get placeholderCellRendered() {
        return this._placeholderCellRendered;
    }
    /**
     * A signal emitted when the model of the notebook changes.
     */
    get modelChanged() {
        return this._modelChanged;
    }
    /**
     * A signal emitted when the model content changes.
     *
     * #### Notes
     * This is a convenience signal that follows the current model.
     */
    get modelContentChanged() {
        return this._modelContentChanged;
    }
    /**
     * The model for the widget.
     */
    get model() {
        return this._model;
    }
    set model(newValue) {
        newValue = newValue || null;
        if (this._model === newValue) {
            return;
        }
        const oldValue = this._model;
        this._model = newValue;
        if (oldValue && oldValue.modelDB.isCollaborative) {
            void oldValue.modelDB.connected.then(() => {
                oldValue.modelDB.collaborators.changed.disconnect(this._onCollaboratorsChanged, this);
            });
        }
        if (newValue && newValue.modelDB.isCollaborative) {
            void newValue.modelDB.connected.then(() => {
                newValue.modelDB.collaborators.changed.connect(this._onCollaboratorsChanged, this);
            });
        }
        // Trigger private, protected, and public changes.
        this._onModelChanged(oldValue, newValue);
        this.onModelChanged(oldValue, newValue);
        this._modelChanged.emit(void 0);
    }
    /**
     * Get the mimetype for code cells.
     */
    get codeMimetype() {
        return this._mimetype;
    }
    /**
     * A read-only sequence of the widgets in the notebook.
     */
    get widgets() {
        return this.layout.widgets;
    }
    /**
     * A configuration object for cell editor settings.
     */
    get editorConfig() {
        return this._editorConfig;
    }
    set editorConfig(value) {
        this._editorConfig = value;
        this._updateEditorConfig();
    }
    /**
     * A configuration object for notebook settings.
     */
    get notebookConfig() {
        return this._notebookConfig;
    }
    set notebookConfig(value) {
        this._notebookConfig = value;
        this._updateNotebookConfig();
    }
    /**
     * Dispose of the resources held by the widget.
     */
    dispose() {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._model = null;
        super.dispose();
    }
    /**
     * Handle a new model.
     *
     * #### Notes
     * This method is called after the model change has been handled
     * internally and before the `modelChanged` signal is emitted.
     * The default implementation is a no-op.
     */
    onModelChanged(oldValue, newValue) {
        // No-op.
    }
    /**
     * Handle changes to the notebook model content.
     *
     * #### Notes
     * The default implementation emits the `modelContentChanged` signal.
     */
    onModelContentChanged(model, args) {
        this._modelContentChanged.emit(void 0);
    }
    /**
     * Handle changes to the notebook model metadata.
     *
     * #### Notes
     * The default implementation updates the mimetypes of the code cells
     * when the `language_info` metadata changes.
     */
    onMetadataChanged(sender, args) {
        switch (args.key) {
            case 'language_info':
                this._updateMimetype();
                break;
            default:
                break;
        }
    }
    /**
     * Handle a cell being inserted.
     *
     * The default implementation is a no-op
     */
    onCellInserted(index, cell) {
        // This is a no-op.
    }
    /**
     * Handle a cell being moved.
     *
     * The default implementation is a no-op
     */
    onCellMoved(fromIndex, toIndex) {
        // This is a no-op.
    }
    /**
     * Handle a cell being removed.
     *
     * The default implementation is a no-op
     */
    onCellRemoved(index, cell) {
        // This is a no-op.
    }
    /**
     * Handle a new model on the widget.
     */
    _onModelChanged(oldValue, newValue) {
        const layout = this.layout;
        if (oldValue) {
            oldValue.cells.changed.disconnect(this._onCellsChanged, this);
            oldValue.metadata.changed.disconnect(this.onMetadataChanged, this);
            oldValue.contentChanged.disconnect(this.onModelContentChanged, this);
            // TODO: reuse existing cell widgets if possible. Remember to initially
            // clear the history of each cell if we do this.
            while (layout.widgets.length) {
                this._removeCell(0);
            }
        }
        if (!newValue) {
            this._mimetype = 'text/plain';
            return;
        }
        this._updateMimetype();
        const cells = newValue.cells;
        if (!cells.length && newValue.isInitialized) {
            cells.push(newValue.contentFactory.createCell(this.notebookConfig.defaultCell, {}));
        }
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(cells, (cell, i) => {
            this._insertCell(i, cell, 'set');
        });
        cells.changed.connect(this._onCellsChanged, this);
        newValue.contentChanged.connect(this.onModelContentChanged, this);
        newValue.metadata.changed.connect(this.onMetadataChanged, this);
    }
    /**
     * Handle a change cells event.
     */
    _onCellsChanged(sender, args) {
        let index = 0;
        switch (args.type) {
            case 'add':
                index = args.newIndex;
                // eslint-disable-next-line no-case-declarations
                const insertType = args.oldIndex == -1 ? 'push' : 'insert';
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(args.newValues, value => {
                    this._insertCell(index++, value, insertType);
                });
                break;
            case 'move':
                this._moveCell(args.oldIndex, args.newIndex);
                break;
            case 'remove':
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(args.oldValues, value => {
                    this._removeCell(args.oldIndex);
                });
                // Add default cell if there are no cells remaining.
                if (!sender.length) {
                    const model = this.model;
                    // Add the cell in a new context to avoid triggering another
                    // cell changed event during the handling of this signal.
                    requestAnimationFrame(() => {
                        if (model && !model.isDisposed && !model.cells.length) {
                            model.cells.push(model.contentFactory.createCell(this.notebookConfig.defaultCell, {}));
                        }
                    });
                }
                break;
            case 'set':
                // TODO: reuse existing widgets if possible.
                index = args.newIndex;
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(args.newValues, value => {
                    // Note: this ordering (insert then remove)
                    // is important for getting the active cell
                    // index for the editable notebook correct.
                    this._insertCell(index, value, 'set');
                    this._removeCell(index + 1);
                    index++;
                });
                break;
            default:
                return;
        }
    }
    /**
     * Create a cell widget and insert into the notebook.
     */
    _insertCell(index, cell, insertType) {
        let widget;
        switch (cell.type) {
            case 'code':
                widget = this._createCodeCell(cell);
                widget.model.mimeType = this._mimetype;
                break;
            case 'markdown':
                widget = this._createMarkdownCell(cell);
                if (cell.value.text === '') {
                    widget.rendered = false;
                }
                break;
            default:
                widget = this._createRawCell(cell);
        }
        widget.addClass(NB_CELL_CLASS);
        const layout = this.layout;
        this._cellsArray.push(widget);
        if (this._observer &&
            insertType === 'push' &&
            this._renderedCellsCount >=
                this.notebookConfig.numberCellsToRenderDirectly) {
            // We have an observer and we are have been asked to push (not to insert).
            // and we are above the number of cells to render directly, then
            // we will add a placeholder and let the intersection observer or the
            // idle browser render those placeholder cells.
            this._toRenderMap.set(widget.model.id, { index: index, cell: widget });
            const placeholder = this._createPlaceholderCell(cell, index);
            placeholder.node.id = widget.model.id;
            layout.insertWidget(index, placeholder);
            this.onCellInserted(index, placeholder);
            this._fullyRendered.emit(false);
            this._observer.observe(placeholder.node);
        }
        else {
            // We have no intersection observer, or we insert, or we are below
            // the number of cells to render directly, so we render directly.
            layout.insertWidget(index, widget);
            this._incrementRenderedCount();
            this.onCellInserted(index, widget);
        }
        if (this._observer && this.notebookConfig.renderCellOnIdle) {
            const renderPlaceholderCells = this._renderPlaceholderCells.bind(this);
            window.requestIdleCallback(renderPlaceholderCells, {
                timeout: 1000
            });
        }
    }
    _renderPlaceholderCells(deadline) {
        if (this._renderedCellsCount < this._cellsArray.length &&
            this._renderedCellsCount >=
                this.notebookConfig.numberCellsToRenderDirectly) {
            const index = this._renderedCellsCount;
            const cell = this._cellsArray[index];
            this._renderPlaceholderCell(cell, index);
        }
    }
    _renderPlaceholderCell(cell, index) {
        const pl = this.layout;
        pl.removeWidgetAt(index);
        pl.insertWidget(index, cell);
        this._toRenderMap.delete(cell.model.id);
        this._incrementRenderedCount();
        this.onCellInserted(index, cell);
        this._placeholderCellRendered.emit(cell);
    }
    /**
     * Create a code cell widget from a code cell model.
     */
    _createCodeCell(model) {
        const rendermime = this.rendermime;
        const contentFactory = this.contentFactory;
        const editorConfig = this.editorConfig.code;
        const options = {
            editorConfig,
            model,
            rendermime,
            contentFactory,
            updateEditorOnShow: false,
            placeholder: false,
            maxNumberOutputs: this.notebookConfig.maxNumberOutputs
        };
        const cell = this.contentFactory.createCodeCell(options, this);
        cell.syncCollapse = true;
        cell.syncEditable = true;
        cell.syncScrolled = true;
        return cell;
    }
    /**
     * Create a markdown cell widget from a markdown cell model.
     */
    _createMarkdownCell(model) {
        const rendermime = this.rendermime;
        const contentFactory = this.contentFactory;
        const editorConfig = this.editorConfig.markdown;
        const options = {
            editorConfig,
            model,
            rendermime,
            contentFactory,
            updateEditorOnShow: false,
            placeholder: false
        };
        const cell = this.contentFactory.createMarkdownCell(options, this);
        cell.syncCollapse = true;
        cell.syncEditable = true;
        return cell;
    }
    /**
     * Create a placeholder cell widget from a raw cell model.
     */
    _createPlaceholderCell(model, index) {
        const contentFactory = this.contentFactory;
        const editorConfig = this.editorConfig.raw;
        const options = {
            editorConfig,
            model,
            contentFactory,
            updateEditorOnShow: false,
            placeholder: true
        };
        const cell = this.contentFactory.createRawCell(options, this);
        cell.node.innerHTML = `
      <div class="jp-Cell-Placeholder">
        <div class="jp-Cell-Placeholder-wrapper">
        </div>
      </div>`;
        cell.inputHidden = true;
        cell.syncCollapse = true;
        cell.syncEditable = true;
        return cell;
    }
    /**
     * Create a raw cell widget from a raw cell model.
     */
    _createRawCell(model) {
        const contentFactory = this.contentFactory;
        const editorConfig = this.editorConfig.raw;
        const options = {
            editorConfig,
            model,
            contentFactory,
            updateEditorOnShow: false,
            placeholder: false
        };
        const cell = this.contentFactory.createRawCell(options, this);
        cell.syncCollapse = true;
        cell.syncEditable = true;
        return cell;
    }
    /**
     * Move a cell widget.
     */
    _moveCell(fromIndex, toIndex) {
        const layout = this.layout;
        layout.insertWidget(toIndex, layout.widgets[fromIndex]);
        this.onCellMoved(fromIndex, toIndex);
    }
    /**
     * Remove a cell widget.
     */
    _removeCell(index) {
        const layout = this.layout;
        const widget = layout.widgets[index];
        widget.parent = null;
        this.onCellRemoved(index, widget);
        widget.dispose();
    }
    /**
     * Update the mimetype of the notebook.
     */
    _updateMimetype() {
        var _a;
        const info = (_a = this._model) === null || _a === void 0 ? void 0 : _a.metadata.get('language_info');
        if (!info) {
            return;
        }
        this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(this.widgets, widget => {
            if (widget.model.type === 'code') {
                widget.model.mimeType = this._mimetype;
            }
        });
    }
    /**
     * Handle an update to the collaborators.
     */
    _onCollaboratorsChanged() {
        var _a, _b, _c;
        // If there are selections corresponding to non-collaborators,
        // they are stale and should be removed.
        for (let i = 0; i < this.widgets.length; i++) {
            const cell = this.widgets[i];
            for (const key of cell.model.selections.keys()) {
                if (false === ((_c = (_b = (_a = this._model) === null || _a === void 0 ? void 0 : _a.modelDB) === null || _b === void 0 ? void 0 : _b.collaborators) === null || _c === void 0 ? void 0 : _c.has(key))) {
                    cell.model.selections.delete(key);
                }
            }
        }
    }
    /**
     * Update editor settings for notebook cells.
     */
    _updateEditorConfig() {
        for (let i = 0; i < this.widgets.length; i++) {
            const cell = this.widgets[i];
            let config;
            switch (cell.model.type) {
                case 'code':
                    config = this._editorConfig.code;
                    break;
                case 'markdown':
                    config = this._editorConfig.markdown;
                    break;
                default:
                    config = this._editorConfig.raw;
                    break;
            }
            let editorOptions = {};
            Object.keys(config).forEach((key) => {
                var _a;
                editorOptions[key] = (_a = config[key]) !== null && _a !== void 0 ? _a : null;
            });
            cell.editor.setOptions(editorOptions);
            cell.editor.refresh();
        }
    }
    /**
     * Apply updated notebook settings.
     */
    _updateNotebookConfig() {
        // Apply scrollPastEnd setting.
        this.toggleClass('jp-mod-scrollPastEnd', this._notebookConfig.scrollPastEnd);
    }
    _incrementRenderedCount() {
        if (this._toRenderMap.size === 0) {
            this._fullyRendered.emit(true);
        }
        this._renderedCellsCount++;
    }
}
/**
 * The namespace for the `StaticNotebook` class statics.
 */
(function (StaticNotebook) {
    /**
     * Default configuration options for cell editors.
     */
    StaticNotebook.defaultEditorConfig = {
        code: Object.assign(Object.assign({}, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditor.defaultConfig), { lineWrap: 'off', matchBrackets: true, autoClosingBrackets: false }),
        markdown: Object.assign(Object.assign({}, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false }),
        raw: Object.assign(Object.assign({}, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false })
    };
    /**
     * Default configuration options for notebooks.
     */
    StaticNotebook.defaultNotebookConfig = {
        scrollPastEnd: true,
        defaultCell: 'code',
        recordTiming: false,
        numberCellsToRenderDirectly: 20,
        renderCellOnIdle: true,
        observedTopMargin: '1000px',
        observedBottomMargin: '1000px',
        maxNumberOutputs: 50
    };
    /**
     * The default implementation of an `IContentFactory`.
     */
    class ContentFactory extends _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.Cell.ContentFactory {
        /**
         * Create a new code cell widget.
         *
         * #### Notes
         * If no cell content factory is passed in with the options, the one on the
         * notebook content factory is used.
         */
        createCodeCell(options, parent) {
            if (!options.contentFactory) {
                options.contentFactory = this;
            }
            return new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.CodeCell(options).initializeState();
        }
        /**
         * Create a new markdown cell widget.
         *
         * #### Notes
         * If no cell content factory is passed in with the options, the one on the
         * notebook content factory is used.
         */
        createMarkdownCell(options, parent) {
            if (!options.contentFactory) {
                options.contentFactory = this;
            }
            return new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.MarkdownCell(options).initializeState();
        }
        /**
         * Create a new raw cell widget.
         *
         * #### Notes
         * If no cell content factory is passed in with the options, the one on the
         * notebook content factory is used.
         */
        createRawCell(options, parent) {
            if (!options.contentFactory) {
                options.contentFactory = this;
            }
            return new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.RawCell(options).initializeState();
        }
    }
    StaticNotebook.ContentFactory = ContentFactory;
    /**
     * Default content factory for the static notebook widget.
     */
    StaticNotebook.defaultContentFactory = new ContentFactory();
})(StaticNotebook || (StaticNotebook = {}));
/**
 * A notebook widget that supports interactivity.
 */
class Notebook extends StaticNotebook {
    /**
     * Construct a notebook widget.
     */
    constructor(options) {
        super(Private.processNotebookOptions(options));
        this._activeCellIndex = -1;
        this._activeCell = null;
        this._mode = 'command';
        this._drag = null;
        this._fragment = '';
        this._dragData = null;
        this._mouseMode = null;
        this._activeCellChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._selectionChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._checkCacheOnNextResize = false;
        this.node.tabIndex = 0; // Allow the widget to take focus.
        // Allow the node to scroll while dragging items.
        this.node.setAttribute('data-lm-dragscroll', 'true');
    }
    /**
     * A signal emitted when the active cell changes.
     *
     * #### Notes
     * This can be due to the active index changing or the
     * cell at the active index changing.
     */
    get activeCellChanged() {
        return this._activeCellChanged;
    }
    /**
     * A signal emitted when the state of the notebook changes.
     */
    get stateChanged() {
        return this._stateChanged;
    }
    /**
     * A signal emitted when the selection state of the notebook changes.
     */
    get selectionChanged() {
        return this._selectionChanged;
    }
    /**
     * The interactivity mode of the notebook.
     */
    get mode() {
        return this._mode;
    }
    set mode(newValue) {
        const activeCell = this.activeCell;
        if (!activeCell) {
            newValue = 'command';
        }
        if (newValue === this._mode) {
            this._ensureFocus();
            return;
        }
        // Post an update request.
        this.update();
        const oldValue = this._mode;
        this._mode = newValue;
        if (newValue === 'edit') {
            // Edit mode deselects all cells.
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(this.widgets, widget => {
                this.deselect(widget);
            });
            //  Edit mode unrenders an active markdown widget.
            if (activeCell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.MarkdownCell) {
                activeCell.rendered = false;
            }
            activeCell.inputHidden = false;
        }
        else {
            // Focus on the notebook document, which blurs the active cell.
            this.node.focus();
        }
        this._stateChanged.emit({ name: 'mode', oldValue, newValue });
        this._ensureFocus();
    }
    /**
     * The active cell index of the notebook.
     *
     * #### Notes
     * The index will be clamped to the bounds of the notebook cells.
     */
    get activeCellIndex() {
        if (!this.model) {
            return -1;
        }
        return this.model.cells.length ? this._activeCellIndex : -1;
    }
    set activeCellIndex(newValue) {
        const oldValue = this._activeCellIndex;
        if (!this.model || !this.model.cells.length) {
            newValue = -1;
        }
        else {
            newValue = Math.max(newValue, 0);
            newValue = Math.min(newValue, this.model.cells.length - 1);
        }
        this._activeCellIndex = newValue;
        const cell = this.widgets[newValue];
        if (cell !== this._activeCell) {
            // Post an update request.
            this.update();
            this._activeCell = cell;
            this._activeCellChanged.emit(cell);
        }
        if (this.mode === 'edit' && cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.MarkdownCell) {
            cell.rendered = false;
        }
        this._ensureFocus();
        if (newValue === oldValue) {
            return;
        }
        this._trimSelections();
        this._stateChanged.emit({ name: 'activeCellIndex', oldValue, newValue });
    }
    /**
     * Get the active cell widget.
     *
     * #### Notes
     * This is a cell or `null` if there is no active cell.
     */
    get activeCell() {
        return this._activeCell;
    }
    /**
     * Dispose of the resources held by the widget.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._activeCell = null;
        super.dispose();
    }
    /**
     * Select a cell widget.
     *
     * #### Notes
     * It is a no-op if the value does not change.
     * It will emit the `selectionChanged` signal.
     */
    select(widget) {
        if (Private.selectedProperty.get(widget)) {
            return;
        }
        Private.selectedProperty.set(widget, true);
        this._selectionChanged.emit(void 0);
        this.update();
    }
    /**
     * Deselect a cell widget.
     *
     * #### Notes
     * It is a no-op if the value does not change.
     * It will emit the `selectionChanged` signal.
     */
    deselect(widget) {
        if (!Private.selectedProperty.get(widget)) {
            return;
        }
        Private.selectedProperty.set(widget, false);
        this._selectionChanged.emit(void 0);
        this.update();
    }
    /**
     * Whether a cell is selected.
     */
    isSelected(widget) {
        return Private.selectedProperty.get(widget);
    }
    /**
     * Whether a cell is selected or is the active cell.
     */
    isSelectedOrActive(widget) {
        if (widget === this._activeCell) {
            return true;
        }
        return Private.selectedProperty.get(widget);
    }
    /**
     * Deselect all of the cells.
     */
    deselectAll() {
        let changed = false;
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(this.widgets, widget => {
            if (Private.selectedProperty.get(widget)) {
                changed = true;
            }
            Private.selectedProperty.set(widget, false);
        });
        if (changed) {
            this._selectionChanged.emit(void 0);
        }
        // Make sure we have a valid active cell.
        this.activeCellIndex = this.activeCellIndex; // eslint-disable-line
        this.update();
    }
    /**
     * Move the head of an existing contiguous selection to extend the selection.
     *
     * @param index - The new head of the existing selection.
     *
     * #### Notes
     * If there is no existing selection, the active cell is considered an
     * existing one-cell selection.
     *
     * If the new selection is a single cell, that cell becomes the active cell
     * and all cells are deselected.
     *
     * There is no change if there are no cells (i.e., activeCellIndex is -1).
     */
    extendContiguousSelectionTo(index) {
        let { head, anchor } = this.getContiguousSelection();
        let i;
        // Handle the case of no current selection.
        if (anchor === null || head === null) {
            if (index === this.activeCellIndex) {
                // Already collapsed selection, nothing more to do.
                return;
            }
            // We will start a new selection below.
            head = this.activeCellIndex;
            anchor = this.activeCellIndex;
        }
        // Move the active cell. We do this before the collapsing shortcut below.
        this.activeCellIndex = index;
        // Make sure the index is valid, according to the rules for setting and clipping the
        // active cell index. This may change the index.
        index = this.activeCellIndex;
        // Collapse the selection if it is only the active cell.
        if (index === anchor) {
            this.deselectAll();
            return;
        }
        let selectionChanged = false;
        if (head < index) {
            if (head < anchor) {
                Private.selectedProperty.set(this.widgets[head], false);
                selectionChanged = true;
            }
            // Toggle everything strictly between head and index except anchor.
            for (i = head + 1; i < index; i++) {
                if (i !== anchor) {
                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));
                    selectionChanged = true;
                }
            }
        }
        else if (index < head) {
            if (anchor < head) {
                Private.selectedProperty.set(this.widgets[head], false);
                selectionChanged = true;
            }
            // Toggle everything strictly between index and head except anchor.
            for (i = index + 1; i < head; i++) {
                if (i !== anchor) {
                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));
                    selectionChanged = true;
                }
            }
        }
        // Anchor and index should *always* be selected.
        if (!Private.selectedProperty.get(this.widgets[anchor])) {
            selectionChanged = true;
        }
        Private.selectedProperty.set(this.widgets[anchor], true);
        if (!Private.selectedProperty.get(this.widgets[index])) {
            selectionChanged = true;
        }
        Private.selectedProperty.set(this.widgets[index], true);
        if (selectionChanged) {
            this._selectionChanged.emit(void 0);
        }
    }
    /**
     * Get the head and anchor of a contiguous cell selection.
     *
     * The head of a contiguous selection is always the active cell.
     *
     * If there are no cells selected, `{head: null, anchor: null}` is returned.
     *
     * Throws an error if the currently selected cells do not form a contiguous
     * selection.
     */
    getContiguousSelection() {
        const cells = this.widgets;
        const first = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.findFirstIndex(cells, c => this.isSelected(c));
        // Return early if no cells are selected.
        if (first === -1) {
            return { head: null, anchor: null };
        }
        const last = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.findLastIndex(cells, c => this.isSelected(c), -1, first);
        // Check that the selection is contiguous.
        for (let i = first; i <= last; i++) {
            if (!this.isSelected(cells[i])) {
                throw new Error('Selection not contiguous');
            }
        }
        // Check that the active cell is one of the endpoints of the selection.
        const activeIndex = this.activeCellIndex;
        if (first !== activeIndex && last !== activeIndex) {
            throw new Error('Active cell not at endpoint of selection');
        }
        // Determine the head and anchor of the selection.
        if (first === activeIndex) {
            return { head: first, anchor: last };
        }
        else {
            return { head: last, anchor: first };
        }
    }
    /**
     * Scroll so that the given position is centered.
     *
     * @param position - The vertical position in the notebook widget.
     *
     * @param threshold - An optional threshold for the scroll (0-50, defaults to
     * 25).
     *
     * #### Notes
     * If the position is within the threshold percentage of the widget height,
     * measured from the center of the widget, the scroll position will not be
     * changed. A threshold of 0 means we will always scroll so the position is
     * centered, and a threshold of 50 means scrolling only happens if position is
     * outside the current window.
     */
    scrollToPosition(position, threshold = 25) {
        const node = this.node;
        const ar = node.getBoundingClientRect();
        const delta = position - ar.top - ar.height / 2;
        if (Math.abs(delta) > (ar.height * threshold) / 100) {
            node.scrollTop += delta;
        }
    }
    /**
     * Scroll so that the given cell is in view. Selects and activates cell.
     *
     * @param cell - A cell in the notebook widget.
     *
     */
    scrollToCell(cell) {
        // use Phosphor to scroll
        _lumino_domutils__WEBPACK_IMPORTED_MODULE_4__.ElementExt.scrollIntoViewIfNeeded(this.node, cell.node);
        // change selection and active cell:
        this.deselectAll();
        this.select(cell);
        cell.activate();
    }
    /**
     * Set URI fragment identifier.
     */
    setFragment(fragment) {
        // Wait all cells are rendered then set fragment and update.
        void Promise.all(this.widgets.map(widget => widget.ready)).then(() => {
            this._fragment = fragment;
            this.update();
        });
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the notebook panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        if (!this.model) {
            return;
        }
        switch (event.type) {
            case 'contextmenu':
                if (event.eventPhase === Event.CAPTURING_PHASE) {
                    this._evtContextMenuCapture(event);
                }
                break;
            case 'mousedown':
                if (event.eventPhase === Event.CAPTURING_PHASE) {
                    this._evtMouseDownCapture(event);
                }
                else {
                    this._evtMouseDown(event);
                }
                break;
            case 'mouseup':
                if (event.currentTarget === document) {
                    this._evtDocumentMouseup(event);
                }
                break;
            case 'mousemove':
                if (event.currentTarget === document) {
                    this._evtDocumentMousemove(event);
                }
                break;
            case 'keydown':
                this._ensureFocus(true);
                break;
            case 'dblclick':
                this._evtDblClick(event);
                break;
            case 'focusin':
                this._evtFocusIn(event);
                break;
            case 'focusout':
                this._evtFocusOut(event);
                break;
            case 'lm-dragenter':
                this._evtDragEnter(event);
                break;
            case 'lm-dragleave':
                this._evtDragLeave(event);
                break;
            case 'lm-dragover':
                this._evtDragOver(event);
                break;
            case 'lm-drop':
                this._evtDrop(event);
                break;
            default:
                break;
        }
    }
    /**
     * Handle `after-attach` messages for the widget.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        const node = this.node;
        node.addEventListener('contextmenu', this, true);
        node.addEventListener('mousedown', this, true);
        node.addEventListener('mousedown', this);
        node.addEventListener('keydown', this);
        node.addEventListener('dblclick', this);
        node.addEventListener('focusin', this);
        node.addEventListener('focusout', this);
        // Capture drag events for the notebook widget
        // in order to preempt the drag/drop handlers in the
        // code editor widgets, which can take text data.
        node.addEventListener('lm-dragenter', this, true);
        node.addEventListener('lm-dragleave', this, true);
        node.addEventListener('lm-dragover', this, true);
        node.addEventListener('lm-drop', this, true);
    }
    /**
     * Handle `before-detach` messages for the widget.
     */
    onBeforeDetach(msg) {
        const node = this.node;
        node.removeEventListener('contextmenu', this, true);
        node.removeEventListener('mousedown', this, true);
        node.removeEventListener('mousedown', this);
        node.removeEventListener('keydown', this);
        node.removeEventListener('dblclick', this);
        node.removeEventListener('focusin', this);
        node.removeEventListener('focusout', this);
        node.removeEventListener('lm-dragenter', this, true);
        node.removeEventListener('lm-dragleave', this, true);
        node.removeEventListener('lm-dragover', this, true);
        node.removeEventListener('lm-drop', this, true);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
    }
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    onAfterShow(msg) {
        this._checkCacheOnNextResize = true;
    }
    /**
     * A message handler invoked on a `'resize'` message.
     */
    onResize(msg) {
        if (!this._checkCacheOnNextResize) {
            return super.onResize(msg);
        }
        this._checkCacheOnNextResize = false;
        const cache = this._cellLayoutStateCache;
        const width = parseInt(this.node.style.width, 10);
        if (cache) {
            if (width === cache.width) {
                // Cache identical, do nothing
                return;
            }
        }
        // Update cache
        this._cellLayoutStateCache = { width };
        // Fallback:
        for (const w of this.widgets) {
            if (w instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.Cell) {
                w.editorWidget.update();
            }
        }
    }
    /**
     * A message handler invoked on an `'before-hide'` message.
     */
    onBeforeHide(msg) {
        // Update cache
        const width = parseInt(this.node.style.width, 10);
        this._cellLayoutStateCache = { width };
    }
    /**
     * Handle `'activate-request'` messages.
     */
    onActivateRequest(msg) {
        this._ensureFocus(true);
    }
    /**
     * Handle `update-request` messages sent to the widget.
     */
    onUpdateRequest(msg) {
        const activeCell = this.activeCell;
        // Set the appropriate classes on the cells.
        if (this.mode === 'edit') {
            this.addClass(EDIT_CLASS);
            this.removeClass(COMMAND_CLASS);
        }
        else {
            this.addClass(COMMAND_CLASS);
            this.removeClass(EDIT_CLASS);
        }
        if (activeCell) {
            activeCell.addClass(ACTIVE_CLASS);
        }
        let count = 0;
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(this.widgets, widget => {
            if (widget !== activeCell) {
                widget.removeClass(ACTIVE_CLASS);
            }
            widget.removeClass(OTHER_SELECTED_CLASS);
            if (this.isSelectedOrActive(widget)) {
                widget.addClass(SELECTED_CLASS);
                count++;
            }
            else {
                widget.removeClass(SELECTED_CLASS);
            }
        });
        if (count > 1) {
            activeCell === null || activeCell === void 0 ? void 0 : activeCell.addClass(OTHER_SELECTED_CLASS);
        }
        if (this._fragment) {
            let el;
            try {
                el = this.node.querySelector(this._fragment);
            }
            catch (error) {
                console.warn('Unable to set URI fragment identifier', error);
            }
            if (el) {
                el.scrollIntoView();
            }
            this._fragment = '';
        }
    }
    /**
     * Handle a cell being inserted.
     */
    onCellInserted(index, cell) {
        if (this.model && this.model.modelDB.isCollaborative) {
            const modelDB = this.model.modelDB;
            void modelDB.connected.then(() => {
                if (!cell.isDisposed) {
                    // Setup the selection style for collaborators.
                    const localCollaborator = modelDB.collaborators.localCollaborator;
                    cell.editor.uuid = localCollaborator.sessionId;
                    cell.editor.selectionStyle = Object.assign(Object.assign({}, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditor.defaultSelectionStyle), { color: localCollaborator.color });
                }
            });
        }
        cell.editor.edgeRequested.connect(this._onEdgeRequest, this);
        // If the insertion happened above, increment the active cell
        // index, otherwise it stays the same.
        this.activeCellIndex =
            index <= this.activeCellIndex
                ? this.activeCellIndex + 1
                : this.activeCellIndex;
    }
    /**
     * Handle a cell being moved.
     */
    onCellMoved(fromIndex, toIndex) {
        const i = this.activeCellIndex;
        if (fromIndex === i) {
            this.activeCellIndex = toIndex;
        }
        else if (fromIndex < i && i <= toIndex) {
            this.activeCellIndex--;
        }
        else if (toIndex <= i && i < fromIndex) {
            this.activeCellIndex++;
        }
    }
    /**
     * Handle a cell being removed.
     */
    onCellRemoved(index, cell) {
        // If the removal happened above, decrement the active
        // cell index, otherwise it stays the same.
        this.activeCellIndex =
            index <= this.activeCellIndex
                ? this.activeCellIndex - 1
                : this.activeCellIndex;
        if (this.isSelected(cell)) {
            this._selectionChanged.emit(void 0);
        }
    }
    /**
     * Handle a new model.
     */
    onModelChanged(oldValue, newValue) {
        super.onModelChanged(oldValue, newValue);
        // Try to set the active cell index to 0.
        // It will be set to `-1` if there is no new model or the model is empty.
        this.activeCellIndex = 0;
    }
    /**
     * Handle edge request signals from cells.
     */
    _onEdgeRequest(editor, location) {
        const prev = this.activeCellIndex;
        if (location === 'top') {
            this.activeCellIndex--;
            // Move the cursor to the first position on the last line.
            if (this.activeCellIndex < prev) {
                const editor = this.activeCell.editor;
                const lastLine = editor.lineCount - 1;
                editor.setCursorPosition({ line: lastLine, column: 0 });
            }
        }
        else if (location === 'bottom') {
            this.activeCellIndex++;
            // Move the cursor to the first character.
            if (this.activeCellIndex > prev) {
                const editor = this.activeCell.editor;
                editor.setCursorPosition({ line: 0, column: 0 });
            }
        }
        this.mode = 'edit';
    }
    /**
     * Ensure that the notebook has proper focus.
     */
    _ensureFocus(force = false) {
        const activeCell = this.activeCell;
        if (this.mode === 'edit' && activeCell) {
            if (!activeCell.editor.hasFocus()) {
                activeCell.editor.focus();
            }
        }
        if (force && !this.node.contains(document.activeElement)) {
            this.node.focus();
        }
    }
    /**
     * Find the cell index containing the target html element.
     *
     * #### Notes
     * Returns -1 if the cell is not found.
     */
    _findCell(node) {
        // Trace up the DOM hierarchy to find the root cell node.
        // Then find the corresponding child and select it.
        let n = node;
        while (n && n !== this.node) {
            if (n.classList.contains(NB_CELL_CLASS)) {
                const i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.findFirstIndex(this.widgets, widget => widget.node === n);
                if (i !== -1) {
                    return i;
                }
                break;
            }
            n = n.parentElement;
        }
        return -1;
    }
    /**
     * Find the target of html mouse event and cell index containing this target.
     *
     * #### Notes
     * Returned index is -1 if the cell is not found.
     */
    _findEventTargetAndCell(event) {
        let target = event.target;
        let index = this._findCell(target);
        if (index === -1) {
            // `event.target` sometimes gives an orphaned node in Firefox 57, which
            // can have `null` anywhere in its parent line. If we fail to find a cell
            // using `event.target`, try again using a target reconstructed from the
            // position of the click event.
            target = document.elementFromPoint(event.clientX, event.clientY);
            index = this._findCell(target);
        }
        return [target, index];
    }
    /**
     * Handle `contextmenu` event.
     */
    _evtContextMenuCapture(event) {
        // Allow the event to propagate un-modified if the user
        // is holding the shift-key (and probably requesting
        // the native context menu).
        if (event.shiftKey) {
            return;
        }
        const [target, index] = this._findEventTargetAndCell(event);
        const widget = this.widgets[index];
        if (widget && widget.editorWidget.node.contains(target)) {
            // Prevent CodeMirror from focusing the editor.
            // TODO: find an editor-agnostic solution.
            event.preventDefault();
        }
    }
    /**
     * Handle `mousedown` event in the capture phase for the widget.
     */
    _evtMouseDownCapture(event) {
        const { button, shiftKey } = event;
        const [target, index] = this._findEventTargetAndCell(event);
        const widget = this.widgets[index];
        // On OS X, the context menu may be triggered with ctrl-left-click. In
        // Firefox, ctrl-left-click gives an event with button 2, but in Chrome,
        // ctrl-left-click gives an event with button 0 with the ctrl modifier.
        if (button === 2 &&
            !shiftKey &&
            widget &&
            widget.editorWidget.node.contains(target)) {
            this.mode = 'command';
            // Prevent CodeMirror from focusing the editor.
            // TODO: find an editor-agnostic solution.
            event.preventDefault();
        }
    }
    /**
     * Handle `mousedown` events for the widget.
     */
    _evtMouseDown(event) {
        var _a;
        const { button, shiftKey } = event;
        // We only handle main or secondary button actions.
        if (!(button === 0 || button === 2)) {
            return;
        }
        // Shift right-click gives the browser default behavior.
        if (shiftKey && button === 2) {
            return;
        }
        const [target, index] = this._findEventTargetAndCell(event);
        const widget = this.widgets[index];
        let targetArea;
        if (widget) {
            if (widget.editorWidget.node.contains(target)) {
                targetArea = 'input';
            }
            else if (widget.promptNode.contains(target)) {
                targetArea = 'prompt';
            }
            else {
                targetArea = 'cell';
            }
        }
        else {
            targetArea = 'notebook';
        }
        // Make sure we go to command mode if the click isn't in the cell editor If
        // we do click in the cell editor, the editor handles the focus event to
        // switch to edit mode.
        if (targetArea !== 'input') {
            this.mode = 'command';
        }
        if (targetArea === 'notebook') {
            this.deselectAll();
        }
        else if (targetArea === 'prompt' || targetArea === 'cell') {
            // We don't want to prevent the default selection behavior
            // if there is currently text selected in an output.
            const hasSelection = ((_a = window.getSelection()) !== null && _a !== void 0 ? _a : '').toString() !== '';
            if (button === 0 && shiftKey && !hasSelection) {
                // Prevent browser selecting text in prompt or output
                event.preventDefault();
                // Shift-click - extend selection
                try {
                    this.extendContiguousSelectionTo(index);
                }
                catch (e) {
                    console.error(e);
                    this.deselectAll();
                    return;
                }
                // Enter selecting mode
                this._mouseMode = 'select';
                document.addEventListener('mouseup', this, true);
                document.addEventListener('mousemove', this, true);
            }
            else if (button === 0 && !shiftKey) {
                // Prepare to start a drag if we are on the drag region.
                if (targetArea === 'prompt') {
                    // Prepare for a drag start
                    this._dragData = {
                        pressX: event.clientX,
                        pressY: event.clientY,
                        index: index
                    };
                    // Enter possible drag mode
                    this._mouseMode = 'couldDrag';
                    document.addEventListener('mouseup', this, true);
                    document.addEventListener('mousemove', this, true);
                    event.preventDefault();
                }
                if (!this.isSelectedOrActive(widget)) {
                    this.deselectAll();
                    this.activeCellIndex = index;
                }
            }
            else if (button === 2) {
                if (!this.isSelectedOrActive(widget)) {
                    this.deselectAll();
                    this.activeCellIndex = index;
                }
                event.preventDefault();
            }
        }
        else if (targetArea === 'input') {
            if (button === 2 && !this.isSelectedOrActive(widget)) {
                this.deselectAll();
                this.activeCellIndex = index;
            }
        }
        // If we didn't set focus above, make sure we get focus now.
        this._ensureFocus(true);
    }
    /**
     * Handle the `'mouseup'` event on the document.
     */
    _evtDocumentMouseup(event) {
        event.preventDefault();
        event.stopPropagation();
        // Remove the event listeners we put on the document
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        if (this._mouseMode === 'couldDrag') {
            // We didn't end up dragging if we are here, so treat it as a click event.
            const [, index] = this._findEventTargetAndCell(event);
            this.deselectAll();
            this.activeCellIndex = index;
        }
        this._mouseMode = null;
    }
    /**
     * Handle the `'mousemove'` event for the widget.
     */
    _evtDocumentMousemove(event) {
        event.preventDefault();
        event.stopPropagation();
        // If in select mode, update the selection
        switch (this._mouseMode) {
            case 'select': {
                const target = event.target;
                const index = this._findCell(target);
                if (index !== -1) {
                    this.extendContiguousSelectionTo(index);
                }
                break;
            }
            case 'couldDrag': {
                // Check for a drag initialization.
                const data = this._dragData;
                const dx = Math.abs(event.clientX - data.pressX);
                const dy = Math.abs(event.clientY - data.pressY);
                if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD) {
                    this._mouseMode = null;
                    this._startDrag(data.index, event.clientX, event.clientY);
                }
                break;
            }
            default:
                break;
        }
    }
    /**
     * Handle the `'lm-dragenter'` event for the widget.
     */
    _evtDragEnter(event) {
        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        const target = event.target;
        const index = this._findCell(target);
        if (index === -1) {
            return;
        }
        const widget = this.layout.widgets[index];
        widget.node.classList.add(DROP_TARGET_CLASS);
    }
    /**
     * Handle the `'lm-dragleave'` event for the widget.
     */
    _evtDragLeave(event) {
        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);
        if (elements.length) {
            elements[0].classList.remove(DROP_TARGET_CLASS);
        }
    }
    /**
     * Handle the `'lm-dragover'` event for the widget.
     */
    _evtDragOver(event) {
        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.dropAction = event.proposedAction;
        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);
        if (elements.length) {
            elements[0].classList.remove(DROP_TARGET_CLASS);
        }
        const target = event.target;
        const index = this._findCell(target);
        if (index === -1) {
            return;
        }
        const widget = this.layout.widgets[index];
        widget.node.classList.add(DROP_TARGET_CLASS);
    }
    /**
     * Handle the `'lm-drop'` event for the widget.
     */
    _evtDrop(event) {
        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.proposedAction === 'none') {
            event.dropAction = 'none';
            return;
        }
        let target = event.target;
        while (target && target.parentElement) {
            if (target.classList.contains(DROP_TARGET_CLASS)) {
                target.classList.remove(DROP_TARGET_CLASS);
                break;
            }
            target = target.parentElement;
        }
        // Model presence should be checked before calling event handlers
        const model = this.model;
        const source = event.source;
        if (source === this) {
            // Handle the case where we are moving cells within
            // the same notebook.
            event.dropAction = 'move';
            const toMove = event.mimeData.getData('internal:cells');
            // For collapsed markdown headings with hidden "child" cells, move all
            // child cells as well as the markdown heading.
            const cell = toMove[toMove.length - 1];
            if (cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_0__.MarkdownCell && cell.headingCollapsed) {
                const nextParent = _actions__WEBPACK_IMPORTED_MODULE_10__.NotebookActions.findNextParentHeading(cell, source);
                if (nextParent > 0) {
                    const index = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.findIndex)(source.widgets, (possibleCell) => {
                        return cell.model.id === possibleCell.model.id;
                    });
                    toMove.push(...source.widgets.slice(index + 1, nextParent));
                }
            }
            // Compute the to/from indices for the move.
            let fromIndex = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.firstIndexOf(this.widgets, toMove[0]);
            let toIndex = this._findCell(target);
            // This check is needed for consistency with the view.
            if (toIndex !== -1 && toIndex > fromIndex) {
                toIndex -= 1;
            }
            else if (toIndex === -1) {
                // If the drop is within the notebook but not on any cell,
                // most often this means it is past the cell areas, so
                // set it to move the cells to the end of the notebook.
                toIndex = this.widgets.length - 1;
            }
            // Don't move if we are within the block of selected cells.
            if (toIndex >= fromIndex && toIndex < fromIndex + toMove.length) {
                return;
            }
            // Move the cells one by one
            model.cells.beginCompoundOperation();
            if (fromIndex < toIndex) {
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(toMove, cellWidget => {
                    model.cells.move(fromIndex, toIndex);
                });
            }
            else if (fromIndex > toIndex) {
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(toMove, cellWidget => {
                    model.cells.move(fromIndex++, toIndex++);
                });
            }
            model.cells.endCompoundOperation();
        }
        else {
            // Handle the case where we are copying cells between
            // notebooks.
            event.dropAction = 'copy';
            // Find the target cell and insert the copied cells.
            let index = this._findCell(target);
            if (index === -1) {
                index = this.widgets.length;
            }
            const start = index;
            const values = event.mimeData.getData(JUPYTER_CELL_MIME);
            const factory = model.contentFactory;
            // Insert the copies of the original cells.
            model.cells.beginCompoundOperation();
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(values, (cell) => {
                let value;
                switch (cell.cell_type) {
                    case 'code':
                        value = factory.createCodeCell({ cell });
                        break;
                    case 'markdown':
                        value = factory.createMarkdownCell({ cell });
                        break;
                    default:
                        value = factory.createRawCell({ cell });
                        break;
                }
                model.cells.insert(index++, value);
            });
            model.cells.endCompoundOperation();
            // Select the inserted cells.
            this.deselectAll();
            this.activeCellIndex = start;
            this.extendContiguousSelectionTo(index - 1);
        }
    }
    /**
     * Start a drag event.
     */
    _startDrag(index, clientX, clientY) {
        var _a;
        const cells = this.model.cells;
        const selected = [];
        const toMove = [];
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(this.widgets, (widget, i) => {
            const cell = cells.get(i);
            if (this.isSelectedOrActive(widget)) {
                widget.addClass(DROP_SOURCE_CLASS);
                selected.push(cell.toJSON());
                toMove.push(widget);
            }
        });
        const activeCell = this.activeCell;
        let dragImage = null;
        let countString;
        if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'code') {
            const executionCount = activeCell.model
                .executionCount;
            countString = ' ';
            if (executionCount) {
                countString = executionCount.toString();
            }
        }
        else {
            countString = '';
        }
        // Create the drag image.
        dragImage = Private.createDragImage(selected.length, countString, (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.value.text.split('\n')[0].slice(0, 26)) !== null && _a !== void 0 ? _a : '');
        // Set up the drag event.
        this._drag = new _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__.Drag({
            mimeData: new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__.MimeData(),
            dragImage,
            supportedActions: 'copy-move',
            proposedAction: 'copy',
            source: this
        });
        this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);
        // Add mimeData for the fully reified cell widgets, for the
        // case where the target is in the same notebook and we
        // can just move the cells.
        this._drag.mimeData.setData('internal:cells', toMove);
        // Add mimeData for the text content of the selected cells,
        // allowing for drag/drop into plain text fields.
        const textContent = toMove.map(cell => cell.model.value.text).join('\n');
        this._drag.mimeData.setData('text/plain', textContent);
        // Remove mousemove and mouseup listeners and start the drag.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        this._mouseMode = null;
        void this._drag.start(clientX, clientY).then(action => {
            if (this.isDisposed) {
                return;
            }
            this._drag = null;
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(toMove, widget => {
                widget.removeClass(DROP_SOURCE_CLASS);
            });
        });
    }
    /**
     * Handle `focus` events for the widget.
     */
    _evtFocusIn(event) {
        const target = event.target;
        const index = this._findCell(target);
        if (index !== -1) {
            const widget = this.widgets[index];
            // If the editor itself does not have focus, ensure command mode.
            if (!widget.editorWidget.node.contains(target)) {
                this.mode = 'command';
            }
            this.activeCellIndex = index;
            // If the editor has focus, ensure edit mode.
            const node = widget.editorWidget.node;
            if (node.contains(target)) {
                this.mode = 'edit';
            }
            this.activeCellIndex = index;
        }
        else {
            // No cell has focus, ensure command mode.
            this.mode = 'command';
        }
    }
    /**
     * Handle `focusout` events for the notebook.
     */
    _evtFocusOut(event) {
        const relatedTarget = event.relatedTarget;
        // Bail if the window is losing focus, to preserve edit mode. This test
        // assumes that we explicitly focus things rather than calling blur()
        if (!relatedTarget) {
            return;
        }
        // Bail if the item gaining focus is another cell,
        // and we should not be entering command mode.
        const index = this._findCell(relatedTarget);
        if (index !== -1) {
            const widget = this.widgets[index];
            if (widget.editorWidget.node.contains(relatedTarget)) {
                return;
            }
        }
        // Otherwise enter command mode if not already.
        if (this.mode !== 'command') {
            this.mode = 'command';
            // Switching to command mode currently focuses the notebook element, so
            // refocus the relatedTarget so the focus actually switches as intended.
            if (relatedTarget) {
                relatedTarget.focus();
            }
        }
    }
    /**
     * Handle `dblclick` events for the widget.
     */
    _evtDblClick(event) {
        const model = this.model;
        if (!model) {
            return;
        }
        this.deselectAll();
        const [target, index] = this._findEventTargetAndCell(event);
        if (event.target.classList.contains(HEADING_COLLAPSER_CLASS)) {
            return;
        }
        if (index === -1) {
            return;
        }
        this.activeCellIndex = index;
        if (model.cells.get(index).type === 'markdown') {
            const widget = this.widgets[index];
            widget.rendered = false;
        }
        else if (target.localName === 'img') {
            target.classList.toggle(UNCONFINED_CLASS);
        }
    }
    /**
     * Remove selections from inactive cells to avoid
     * spurious cursors.
     */
    _trimSelections() {
        for (let i = 0; i < this.widgets.length; i++) {
            if (i !== this._activeCellIndex) {
                const cell = this.widgets[i];
                cell.model.selections.delete(cell.editor.uuid);
            }
        }
    }
}
/**
 * The namespace for the `Notebook` class statics.
 */
(function (Notebook) {
    /**
     * The default implementation of a notebook content factory..
     *
     * #### Notes
     * Override methods on this class to customize the default notebook factory
     * methods that create notebook content.
     */
    class ContentFactory extends StaticNotebook.ContentFactory {
    }
    Notebook.ContentFactory = ContentFactory;
    Notebook.defaultContentFactory = new ContentFactory();
})(Notebook || (Notebook = {}));
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for the selected state of a cell.
     */
    Private.selectedProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_6__.AttachedProperty({
        name: 'selected',
        create: () => false
    });
    /**
     * A custom panel layout for the notebook.
     */
    class NotebookPanelLayout extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_9__.PanelLayout {
        /**
         * A message handler invoked on an `'update-request'` message.
         *
         * #### Notes
         * This is a reimplementation of the base class method,
         * and is a no-op.
         */
        onUpdateRequest(msg) {
            // This is a no-op.
        }
    }
    Private.NotebookPanelLayout = NotebookPanelLayout;
    /**
     * Create a cell drag image.
     */
    function createDragImage(count, promptNumber, cellContent) {
        if (count > 1) {
            if (promptNumber !== '') {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: DRAG_IMAGE_CLASS }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));
            }
            else {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: DRAG_IMAGE_CLASS }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_PROMPT_CLASS }), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));
            }
        }
        else {
            if (promptNumber !== '') {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));
            }
            else {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_PROMPT_CLASS }), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));
            }
        }
    }
    Private.createDragImage = createDragImage;
    /**
     * Process the `IOptions` passed to the notebook widget.
     *
     * #### Notes
     * This defaults the content factory to that in the `Notebook` namespace.
     */
    function processNotebookOptions(options) {
        if (options.contentFactory) {
            return options;
        }
        else {
            return {
                rendermime: options.rendermime,
                languagePreference: options.languagePreference,
                contentFactory: Notebook.defaultContentFactory,
                mimeTypeService: options.mimeTypeService
            };
        }
    }
    Private.processNotebookOptions = processNotebookOptions;
})(Private || (Private = {}));
//# sourceMappingURL=widget.js.map

/***/ }),

/***/ 61451:
/*!********************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook/lib/widgetfactory.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookWidgetFactory": () => (/* binding */ NotebookWidgetFactory)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/docregistry */ 64984);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _default_toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./default-toolbar */ 91062);
/* harmony import */ var _panel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./panel */ 91179);
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./widget */ 20267);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





/**
 * A widget factory for notebook panels.
 */
class NotebookWidgetFactory extends _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1__.ABCWidgetFactory {
    /**
     * Construct a new notebook widget factory.
     *
     * @param options - The options used to construct the factory.
     */
    constructor(options) {
        super(options);
        this.rendermime = options.rendermime;
        this.contentFactory =
            options.contentFactory || _panel__WEBPACK_IMPORTED_MODULE_2__.NotebookPanel.defaultContentFactory;
        this.mimeTypeService = options.mimeTypeService;
        this._editorConfig =
            options.editorConfig || _widget__WEBPACK_IMPORTED_MODULE_3__.StaticNotebook.defaultEditorConfig;
        this._notebookConfig =
            options.notebookConfig || _widget__WEBPACK_IMPORTED_MODULE_3__.StaticNotebook.defaultNotebookConfig;
        this._sessionDialogs = options.sessionDialogs || _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.sessionContextDialogs;
    }
    /**
     * A configuration object for cell editor settings.
     */
    get editorConfig() {
        return this._editorConfig;
    }
    set editorConfig(value) {
        this._editorConfig = value;
    }
    /**
     * A configuration object for notebook settings.
     */
    get notebookConfig() {
        return this._notebookConfig;
    }
    set notebookConfig(value) {
        this._notebookConfig = value;
    }
    /**
     * Create a new widget.
     *
     * #### Notes
     * The factory will start the appropriate kernel.
     */
    createNewWidget(context, source) {
        const nbOptions = {
            rendermime: source
                ? source.content.rendermime
                : this.rendermime.clone({ resolver: context.urlResolver }),
            contentFactory: this.contentFactory,
            mimeTypeService: this.mimeTypeService,
            editorConfig: source ? source.content.editorConfig : this._editorConfig,
            notebookConfig: source
                ? source.content.notebookConfig
                : this._notebookConfig
        };
        const content = this.contentFactory.createNotebook(nbOptions);
        return new _panel__WEBPACK_IMPORTED_MODULE_2__.NotebookPanel({ context, content });
    }
    /**
     * Default factory for toolbar items to be added after the widget is created.
     */
    defaultToolbarFactory(widget) {
        return _default_toolbar__WEBPACK_IMPORTED_MODULE_4__.ToolbarItems.getDefaultItems(widget, this._sessionDialogs, this.translator);
    }
}
//# sourceMappingURL=widgetfactory.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jupyterlab_notebook_lib_index_js.e80238c5f63adaa4ac09.js.map