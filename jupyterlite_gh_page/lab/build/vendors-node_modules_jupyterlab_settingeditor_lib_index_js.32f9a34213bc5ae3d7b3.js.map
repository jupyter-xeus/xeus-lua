{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/inspector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/plugineditor.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/pluginlist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/raweditor.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/settingeditor.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/splitpanel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/settingeditor/lib/tokens.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACgC;AACP;AACzB,iC;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AAC0E;AACa;AACnC;AACK;AACzD;AACA;AACA;AACO;AACP,+BAA+B,mEAAc;AAC7C;AACA;AACA,0BAA0B,iEAAc;AACxC;AACA;AACA,KAAK;AACL,wBAAwB,oEAAiB;AACzC;AACA;AACA,gBAAgB,sEAAkB;AAClC,kCAAkC,6EAAyB;AAC3D;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAa;AAC9C;AACA;AACA;AACA,wCAAwC,mEAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAqD;AACpF;AACA,qBAAqB;AACrB;AACA,yBAAyB,2CAA2C,EAAE;AACtE,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,sBAAsB,cAAc,UAAU;AAC9C;AACA,uCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+EAA+E;AAC7F;AACA,kDAAkD,cAAc;AAChE;AACA;AACA,cAAc,eAAe,KAAK,cAAc;AAChD;AACA,2CAA2C,cAAc;AACzD;AACA;AACA,CAAC,0BAA0B;AAC3B,qC;;;;;;;;;;;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AAC0D;AACD;AACb;AACD;AACa;AAChB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,mDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAM;AACvC;AACA,eAAe,4DAA4D;AAC3E,wCAAwC,mEAAc;AACtD;AACA;AACA;AACA;AACA;AACA,0CAA0C,0DAAa;AACvD,eAAe,cAAc;AAC7B,yCAAyC,iDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA,YAAY,gEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAU;AACzB;AACA;AACA;AACA,gBAAgB,qEAAmB,EAAE,kCAAkC;AACvE,gBAAgB,iEAAe,EAAE,8BAA8B;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA,6DAA6D,eAAe;AAC5E,aAAa,gEAAU;AACvB;AACA;AACA,sBAAsB,iEAAe,EAAE,wBAAwB;AAC/D,SAAS;AACT;AACA;AACA,CAAC,0BAA0B;AAC3B,wC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACyD;AACkB;AAChC;AACF;AACV;AACO;AACtC;AACA;AACA;AACO,yBAAyB,mDAAM;AACtC;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAM;AAClC;AACA;AACA;AACA,gDAAgD,mEAAc;AAC9D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,gEAAgE;AAChE;AACA;AACA,SAAS;AACT;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY,IAAI,GAAG,IAAI,QAAQ;AAChE;AACA;AACA;AACA,oBAAoB,gDAAmB,QAAQ,iGAAiG;AAChJ,gBAAgB,gDAAmB,CAAC,2EAAoB,GAAG,wCAAwC,mEAAY,cAAc,kEAAO,qFAAqF;AACzN,gBAAgB,gDAAmB;AACnC,SAAS;AACT,QAAQ,6DAA+B;AACvC,QAAQ,6CAAe,CAAC,gDAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC,0BAA0B;AAC3B,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnOA;AACA;AACqE;AACE;AACd;AACd;AACS;AACN;AACJ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,mDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAA0B;AAChD;AACA,SAAS;AACT;AACA;AACA,oCAAoC,qDAAM;AAC1C;AACA,4BAA4B,yDAAO;AACnC,eAAe,gDAAgD;AAC/D;AACA,wCAAwC,mEAAc;AACtD;AACA;AACA,+CAA+C,qEAAiB;AAChE,uBAAuB,oEAAgB;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC,qEAAiB;AACxD,uBAAuB,oEAAgB;AACvC;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,2DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA,2BAA2B,mDAAM;AACjC,4CAA4C,sDAAS,EAAE,aAAa;AACpE,2BAA2B,mDAAM;AACjC,wBAAwB,yDAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,kCAAkC,0EAAwB;AAC1D;AACA;AACA;AACA;AACA,6BAA6B,sEAAoB,EAAE,+BAA+B;AAClF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA;AACA,2BAA2B,mDAAM;AACjC,4CAA4C,sDAAS,EAAE,aAAa;AACpE,2BAA2B,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,qC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpSA;AACA;AACA;AACA;AACyD;AACD;AACZ;AACU;AACvB;AACO;AACQ;AACJ;AACA;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,mDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAgB;AACtC,gDAAgD,mEAAc;AAC9D;AACA;AACA;AACA,eAAe,sCAAsC;AACrD,0CAA0C,wDAAW;AACrD;AACA,yCAAyC,mDAAU;AACnD;AACA,sBAAsB,mEAA0B;AAChD;AACA,SAAS;AACT,uDAAuD,mDAAM;AAC7D,2CAA2C,uDAAY;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uCAAuC,mDAAU;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAqB;AAC7B,QAAQ,8DAAqB;AAC7B,QAAQ,8DAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA,QAAQ,6CAAe,CAAC,gDAAmB,CAAC,2CAAc;AAC1D,YAAY,gDAAmB;AAC/B,gBAAgB,gDAAmB,CAAC,wEAAiB,GAAG,wHAAwH;AAChL,gBAAgB,gDAAmB,UAAU,kDAAkD;AAC/F,YAAY,gDAAmB,UAAU,iDAAiD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAgB;AACnC;AACA;AACA,0BAA0B,+DAAgB;AAC1C;AACA;AACA,8BAA8B,+DAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,yC;;;;;;;;;;;;;;;;;;;AClUA;AACA;AACA;AACA;AAC2C;AACY;AACvD;AACA;AACA;AACA;AACO,yBAAyB,uDAAM;AACtC;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;ACzBA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACO,kCAAkC,oDAAK;AAC9C,kC","file":"vendors-node_modules_jupyterlab_settingeditor_lib_index_js.32f9a34213bc5ae3d7b3.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module settingeditor\n */\nexport * from './settingeditor';\nexport * from './tokens';\n//# sourceMappingURL=index.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { InspectionHandler, InspectorPanel } from '@jupyterlab/inspector';\nimport { RenderMimeRegistry, standardRendererFactories } from '@jupyterlab/rendermime';\nimport { DataConnector } from '@jupyterlab/statedb';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * Create a raw editor inspector.\n */\nexport function createInspector(editor, rendermime, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const connector = new InspectorConnector(editor, translator);\n    const inspector = new InspectorPanel({\n        initialContent: trans.__('Any errors will be listed here'),\n        translator: translator\n    });\n    const handler = new InspectionHandler({\n        connector,\n        rendermime: rendermime ||\n            new RenderMimeRegistry({\n                initialFactories: standardRendererFactories,\n                translator: translator\n            })\n    });\n    inspector.addClass('jp-SettingsDebug');\n    inspector.source = handler;\n    handler.editor = editor.source;\n    return inspector;\n}\n/**\n * The data connector used to populate a code inspector.\n *\n * #### Notes\n * This data connector debounces fetch requests to throttle them at no more than\n * one request per 100ms. This means that using the connector to populate\n * multiple client objects can lead to missed fetch responses.\n */\nclass InspectorConnector extends DataConnector {\n    constructor(editor, translator) {\n        super();\n        this._current = 0;\n        this.translator = translator || nullTranslator;\n        this._editor = editor;\n        this._trans = this.translator.load('jupyterlab');\n    }\n    /**\n     * Fetch inspection requests.\n     */\n    fetch(request) {\n        return new Promise(resolve => {\n            // Debounce requests at a rate of 100ms.\n            const current = (this._current = window.setTimeout(() => {\n                if (current !== this._current) {\n                    return resolve(undefined);\n                }\n                const errors = this._validate(request.text);\n                if (!errors) {\n                    return resolve({\n                        data: { 'text/markdown': this._trans.__('No errors found') },\n                        metadata: {}\n                    });\n                }\n                resolve({ data: Private.render(errors), metadata: {} });\n            }, 100));\n        });\n    }\n    _validate(raw) {\n        const editor = this._editor;\n        if (!editor.settings) {\n            return null;\n        }\n        const { id, schema, version } = editor.settings;\n        const data = { composite: {}, user: {} };\n        const validator = editor.registry.validator;\n        return validator.validateData({ data, id, raw, schema, version }, false);\n    }\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Render validation errors as an HTML string.\n     */\n    function render(errors) {\n        return { 'text/markdown': errors.map(renderError).join('') };\n    }\n    Private.render = render;\n    /**\n     * Render an individual validation error as a markdown string.\n     */\n    function renderError(error) {\n        var _a;\n        switch (error.keyword) {\n            case 'additionalProperties':\n                return `**\\`[additional property error]\\`**\n          \\`${(_a = error.params) === null || _a === void 0 ? void 0 : _a.additionalProperty}\\` is not a valid property`;\n            case 'syntax':\n                return `**\\`[syntax error]\\`** *${error.message}*`;\n            case 'type':\n                return `**\\`[type error]\\`**\n          \\`${error.dataPath}\\` ${error.message}`;\n            default:\n                return `**\\`[error]\\`** *${error.message}*`;\n        }\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=inspector.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { StackedLayout, Widget } from '@lumino/widgets';\nimport { RawEditor } from './raweditor';\n/**\n * The class name added to all plugin editors.\n */\nconst PLUGIN_EDITOR_CLASS = 'jp-PluginEditor';\n/**\n * An individual plugin settings editor.\n */\nexport class PluginEditor extends Widget {\n    /**\n     * Create a new plugin editor.\n     *\n     * @param options - The plugin editor instantiation options.\n     */\n    constructor(options) {\n        super();\n        this._settings = null;\n        this._stateChanged = new Signal(this);\n        this.addClass(PLUGIN_EDITOR_CLASS);\n        const { commands, editorFactory, registry, rendermime, translator } = options;\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        // TODO: Remove this layout. We were using this before when we\n        // when we had a way to switch between the raw and table editor\n        // Now, the raw editor is the only child and probably could merged into\n        // this class directly in the future.\n        const layout = (this.layout = new StackedLayout());\n        const { onSaveError } = Private;\n        this.raw = this._rawEditor = new RawEditor({\n            commands,\n            editorFactory,\n            onSaveError,\n            registry,\n            rendermime,\n            translator\n        });\n        this._rawEditor.handleMoved.connect(this._onStateChanged, this);\n        layout.addWidget(this._rawEditor);\n    }\n    /**\n     * Tests whether the settings have been modified and need saving.\n     */\n    get isDirty() {\n        return this._rawEditor.isDirty;\n    }\n    /**\n     * The plugin settings being edited.\n     */\n    get settings() {\n        return this._settings;\n    }\n    set settings(settings) {\n        if (this._settings === settings) {\n            return;\n        }\n        const raw = this._rawEditor;\n        this._settings = raw.settings = settings;\n        this.update();\n    }\n    /**\n     * The plugin editor layout state.\n     */\n    get state() {\n        const plugin = this._settings ? this._settings.id : '';\n        const { sizes } = this._rawEditor;\n        return { plugin, sizes };\n    }\n    set state(state) {\n        if (JSONExt.deepEqual(this.state, state)) {\n            return;\n        }\n        this._rawEditor.sizes = state.sizes;\n        this.update();\n    }\n    /**\n     * A signal that emits when editor layout state changes and needs to be saved.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * If the editor is in a dirty state, confirm that the user wants to leave.\n     */\n    confirm() {\n        if (this.isHidden || !this.isAttached || !this.isDirty) {\n            return Promise.resolve(undefined);\n        }\n        return showDialog({\n            title: this._trans.__('You have unsaved changes.'),\n            body: this._trans.__('Do you want to leave without saving?'),\n            buttons: [\n                Dialog.cancelButton({ label: this._trans.__('Cancel') }),\n                Dialog.okButton({ label: this._trans.__('Ok') })\n            ]\n        }).then(result => {\n            if (!result.button.accept) {\n                throw new Error('User canceled.');\n            }\n        });\n    }\n    /**\n     * Dispose of the resources held by the plugin editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        super.dispose();\n        this._rawEditor.dispose();\n    }\n    /**\n     * Handle `after-attach` messages.\n     */\n    onAfterAttach(msg) {\n        this.update();\n    }\n    /**\n     * Handle `'update-request'` messages.\n     */\n    onUpdateRequest(msg) {\n        const raw = this._rawEditor;\n        const settings = this._settings;\n        if (!settings) {\n            this.hide();\n            return;\n        }\n        this.show();\n        raw.show();\n    }\n    /**\n     * Handle layout state changes that need to be saved.\n     */\n    _onStateChanged() {\n        this.stateChanged.emit(undefined);\n    }\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Handle save errors.\n     */\n    function onSaveError(reason, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        console.error(`Saving setting editor value failed: ${reason.message}`);\n        void showDialog({\n            title: trans.__('Your changes were not saved.'),\n            body: reason.message,\n            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n        });\n    }\n    Private.onSaveError = onSaveError;\n})(Private || (Private = {}));\n//# sourceMappingURL=plugineditor.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { classes, LabIcon, settingsIcon } from '@jupyterlab/ui-components';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\n/**\n * A list of plugins with editable settings.\n */\nexport class PluginList extends Widget {\n    /**\n     * Create a new plugin list.\n     */\n    constructor(options) {\n        super();\n        this._changed = new Signal(this);\n        this._scrollTop = 0;\n        this._selection = '';\n        this.registry = options.registry;\n        this.translator = options.translator || nullTranslator;\n        this.addClass('jp-PluginList');\n        this._confirm = options.confirm;\n        this.registry.pluginChanged.connect(() => {\n            this.update();\n        }, this);\n    }\n    /**\n     * A signal emitted when a list user interaction happens.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The selection value of the plugin list.\n     */\n    get scrollTop() {\n        var _a;\n        return (_a = this.node.querySelector('ul')) === null || _a === void 0 ? void 0 : _a.scrollTop;\n    }\n    /**\n     * The selection value of the plugin list.\n     */\n    get selection() {\n        return this._selection;\n    }\n    set selection(selection) {\n        if (this._selection === selection) {\n            return;\n        }\n        this._selection = selection;\n        this.update();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the plugin list's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'mousedown':\n                this._evtMousedown(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `'after-attach'` messages.\n     */\n    onAfterAttach(msg) {\n        this.node.addEventListener('mousedown', this);\n        this.update();\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        this.node.removeEventListener('mousedown', this);\n    }\n    /**\n     * Handle `'update-request'` messages.\n     */\n    onUpdateRequest(msg) {\n        const { node, registry } = this;\n        const selection = this._selection;\n        const translation = this.translator;\n        Private.populateList(registry, selection, node, translation);\n        const ul = node.querySelector('ul');\n        if (ul && this._scrollTop !== undefined) {\n            ul.scrollTop = this._scrollTop;\n        }\n    }\n    /**\n     * Handle the `'mousedown'` event for the plugin list.\n     *\n     * @param event - The DOM event sent to the widget\n     */\n    _evtMousedown(event) {\n        event.preventDefault();\n        let target = event.target;\n        let id = target.getAttribute('data-id');\n        if (id === this._selection) {\n            return;\n        }\n        if (!id) {\n            while (!id && target !== this.node) {\n                target = target.parentElement;\n                id = target.getAttribute('data-id');\n            }\n        }\n        if (!id) {\n            return;\n        }\n        this._confirm()\n            .then(() => {\n            this._scrollTop = this.scrollTop;\n            this._selection = id;\n            this._changed.emit(undefined);\n            this.update();\n        })\n            .catch(() => {\n            /* no op */\n        });\n    }\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The JupyterLab plugin schema key for the setting editor\n     * icon class of a plugin.\n     */\n    const ICON_KEY = 'jupyter.lab.setting-icon';\n    /**\n     * The JupyterLab plugin schema key for the setting editor\n     * icon class of a plugin.\n     */\n    const ICON_CLASS_KEY = 'jupyter.lab.setting-icon-class';\n    /**\n     * The JupyterLab plugin schema key for the setting editor\n     * icon label of a plugin.\n     */\n    const ICON_LABEL_KEY = 'jupyter.lab.setting-icon-label';\n    /**\n     * Check the plugin for a rendering hint's value.\n     *\n     * #### Notes\n     * The order of priority for overridden hints is as follows, from most\n     * important to least:\n     * 1. Data set by the end user in a settings file.\n     * 2. Data set by the plugin author as a schema default.\n     * 3. Data set by the plugin author as a top-level key of the schema.\n     */\n    function getHint(key, registry, plugin) {\n        // First, give priority to checking if the hint exists in the user data.\n        let hint = plugin.data.user[key];\n        // Second, check to see if the hint exists in composite data, which folds\n        // in default values from the schema.\n        if (!hint) {\n            hint = plugin.data.composite[key];\n        }\n        // Third, check to see if the plugin schema has defined the hint.\n        if (!hint) {\n            hint = plugin.schema[key];\n        }\n        // Finally, use the defaults from the registry schema.\n        if (!hint) {\n            const { properties } = registry.schema;\n            hint = properties && properties[key] && properties[key].default;\n        }\n        return typeof hint === 'string' ? hint : '';\n    }\n    /**\n     * Populate the plugin list.\n     */\n    function populateList(registry, selection, node, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const plugins = sortPlugins(registry).filter(plugin => {\n            const { schema } = plugin;\n            const deprecated = schema['jupyter.lab.setting-deprecated'] === true;\n            const editable = Object.keys(schema.properties || {}).length > 0;\n            const extensible = schema.additionalProperties !== false;\n            return !deprecated && (editable || extensible);\n        });\n        const items = plugins.map(plugin => {\n            const { id, schema, version } = plugin;\n            const title = typeof schema.title === 'string'\n                ? trans._p('schema', schema.title)\n                : id;\n            const description = typeof schema.description === 'string'\n                ? trans._p('schema', schema.description)\n                : '';\n            const itemTitle = `${description}\\n${id}\\n${version}`;\n            const icon = getHint(ICON_KEY, registry, plugin);\n            const iconClass = getHint(ICON_CLASS_KEY, registry, plugin);\n            const iconTitle = getHint(ICON_LABEL_KEY, registry, plugin);\n            return (React.createElement(\"li\", { className: id === selection ? 'jp-mod-selected' : '', \"data-id\": id, key: id, title: itemTitle },\n                React.createElement(LabIcon.resolveReact, { icon: icon || (iconClass ? undefined : settingsIcon), iconClass: classes(iconClass, 'jp-Icon'), title: iconTitle, tag: \"span\", stylesheet: \"settingsEditor\" }),\n                React.createElement(\"span\", null, title)));\n        });\n        ReactDOM.unmountComponentAtNode(node);\n        ReactDOM.render(React.createElement(\"ul\", null, items), node);\n    }\n    Private.populateList = populateList;\n    /**\n     * Sort a list of plugins by title and ID.\n     */\n    function sortPlugins(registry) {\n        return Object.keys(registry.plugins)\n            .map(plugin => registry.plugins[plugin])\n            .sort((a, b) => {\n            return (a.schema.title || a.id).localeCompare(b.schema.title || b.id);\n        });\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=pluginlist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CommandToolbarButton, Toolbar } from '@jupyterlab/apputils';\nimport { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Signal } from '@lumino/signaling';\nimport { BoxLayout, Widget } from '@lumino/widgets';\nimport { createInspector } from './inspector';\nimport { SplitPanel } from './splitpanel';\n/**\n * A class name added to all raw editors.\n */\nconst RAW_EDITOR_CLASS = 'jp-SettingsRawEditor';\n/**\n * A class name added to the user settings editor.\n */\nconst USER_CLASS = 'jp-SettingsRawEditor-user';\n/**\n * A class name added to the user editor when there are validation errors.\n */\nconst ERROR_CLASS = 'jp-mod-error';\n/**\n * A raw JSON settings editor.\n */\nexport class RawEditor extends SplitPanel {\n    /**\n     * Create a new plugin editor.\n     */\n    constructor(options) {\n        super({\n            orientation: 'horizontal',\n            renderer: SplitPanel.defaultRenderer,\n            spacing: 1\n        });\n        this._canRevert = false;\n        this._canSave = false;\n        this._commandsChanged = new Signal(this);\n        this._settings = null;\n        this._toolbar = new Toolbar();\n        const { commands, editorFactory, registry, translator } = options;\n        this.registry = registry;\n        this.translator = translator || nullTranslator;\n        this._commands = commands;\n        // Create read-only defaults editor.\n        const defaults = (this._defaults = new CodeEditorWrapper({\n            model: new CodeEditor.Model(),\n            factory: editorFactory\n        }));\n        defaults.editor.model.value.text = '';\n        defaults.editor.model.mimeType = 'text/javascript';\n        defaults.editor.setOption('readOnly', true);\n        // Create read-write user settings editor.\n        const user = (this._user = new CodeEditorWrapper({\n            model: new CodeEditor.Model(),\n            factory: editorFactory,\n            config: { lineNumbers: true }\n        }));\n        user.addClass(USER_CLASS);\n        user.editor.model.mimeType = 'text/javascript';\n        user.editor.model.value.changed.connect(this._onTextChanged, this);\n        // Create and set up an inspector.\n        this._inspector = createInspector(this, options.rendermime, this.translator);\n        this.addClass(RAW_EDITOR_CLASS);\n        // FIXME-TRANS: onSaveError must have an optional translator?\n        this._onSaveError = options.onSaveError;\n        this.addWidget(Private.defaultsEditor(defaults, this.translator));\n        this.addWidget(Private.userEditor(user, this._toolbar, this._inspector, this.translator));\n    }\n    /**\n     * Whether the raw editor revert functionality is enabled.\n     */\n    get canRevert() {\n        return this._canRevert;\n    }\n    /**\n     * Whether the raw editor save functionality is enabled.\n     */\n    get canSave() {\n        return this._canSave;\n    }\n    /**\n     * Emits when the commands passed in at instantiation change.\n     */\n    get commandsChanged() {\n        return this._commandsChanged;\n    }\n    /**\n     * Tests whether the settings have been modified and need saving.\n     */\n    get isDirty() {\n        var _a, _b;\n        return (_b = this._user.editor.model.value.text !== ((_a = this._settings) === null || _a === void 0 ? void 0 : _a.raw)) !== null && _b !== void 0 ? _b : '';\n    }\n    /**\n     * The plugin settings being edited.\n     */\n    get settings() {\n        return this._settings;\n    }\n    set settings(settings) {\n        if (!settings && !this._settings) {\n            return;\n        }\n        const samePlugin = settings && this._settings && settings.plugin === this._settings.plugin;\n        if (samePlugin) {\n            return;\n        }\n        const defaults = this._defaults;\n        const user = this._user;\n        // Disconnect old settings change handler.\n        if (this._settings) {\n            this._settings.changed.disconnect(this._onSettingsChanged, this);\n        }\n        if (settings) {\n            this._settings = settings;\n            this._settings.changed.connect(this._onSettingsChanged, this);\n            this._onSettingsChanged();\n        }\n        else {\n            this._settings = null;\n            defaults.editor.model.value.text = '';\n            user.editor.model.value.text = '';\n        }\n        this.update();\n    }\n    /**\n     * Get the relative sizes of the two editor panels.\n     */\n    get sizes() {\n        return this.relativeSizes();\n    }\n    set sizes(sizes) {\n        this.setRelativeSizes(sizes);\n    }\n    /**\n     * The inspectable source editor for user input.\n     */\n    get source() {\n        return this._user.editor;\n    }\n    /**\n     * Dispose of the resources held by the raw editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        super.dispose();\n        this._defaults.dispose();\n        this._user.dispose();\n    }\n    /**\n     * Revert the editor back to original settings.\n     */\n    revert() {\n        var _a, _b;\n        this._user.editor.model.value.text = (_b = (_a = this.settings) === null || _a === void 0 ? void 0 : _a.raw) !== null && _b !== void 0 ? _b : '';\n        this._updateToolbar(false, false);\n    }\n    /**\n     * Save the contents of the raw editor.\n     */\n    save() {\n        if (!this.isDirty || !this._settings) {\n            return Promise.resolve(undefined);\n        }\n        const settings = this._settings;\n        const source = this._user.editor.model.value.text;\n        return settings\n            .save(source)\n            .then(() => {\n            this._updateToolbar(false, false);\n        })\n            .catch(reason => {\n            this._updateToolbar(true, false);\n            this._onSaveError(reason, this.translator);\n        });\n    }\n    /**\n     * Handle `after-attach` messages.\n     */\n    onAfterAttach(msg) {\n        Private.populateToolbar(this._commands, this._toolbar);\n        this.update();\n    }\n    /**\n     * Handle `'update-request'` messages.\n     */\n    onUpdateRequest(msg) {\n        const settings = this._settings;\n        const defaults = this._defaults;\n        const user = this._user;\n        if (settings) {\n            defaults.editor.refresh();\n            user.editor.refresh();\n        }\n    }\n    /**\n     * Handle text changes in the underlying editor.\n     */\n    _onTextChanged() {\n        const raw = this._user.editor.model.value.text;\n        const settings = this._settings;\n        this.removeClass(ERROR_CLASS);\n        // If there are no settings loaded or there are no changes, bail.\n        if (!settings || settings.raw === raw) {\n            this._updateToolbar(false, false);\n            return;\n        }\n        const errors = settings.validate(raw);\n        if (errors) {\n            this.addClass(ERROR_CLASS);\n            this._updateToolbar(true, false);\n            return;\n        }\n        this._updateToolbar(true, true);\n    }\n    /**\n     * Handle updates to the settings.\n     */\n    _onSettingsChanged() {\n        var _a, _b;\n        const settings = this._settings;\n        const defaults = this._defaults;\n        const user = this._user;\n        defaults.editor.model.value.text = (_a = settings === null || settings === void 0 ? void 0 : settings.annotatedDefaults()) !== null && _a !== void 0 ? _a : '';\n        user.editor.model.value.text = (_b = settings === null || settings === void 0 ? void 0 : settings.raw) !== null && _b !== void 0 ? _b : '';\n    }\n    _updateToolbar(revert = this._canRevert, save = this._canSave) {\n        const commands = this._commands;\n        this._canRevert = revert;\n        this._canSave = save;\n        this._commandsChanged.emit([commands.revert, commands.save]);\n    }\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Returns the wrapped setting defaults editor.\n     */\n    function defaultsEditor(editor, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const widget = new Widget();\n        const layout = (widget.layout = new BoxLayout({ spacing: 0 }));\n        const banner = new Widget();\n        const bar = new Toolbar();\n        const defaultTitle = trans.__('System Defaults');\n        banner.node.innerText = defaultTitle;\n        bar.insertItem(0, 'banner', banner);\n        layout.addWidget(bar);\n        layout.addWidget(editor);\n        return widget;\n    }\n    Private.defaultsEditor = defaultsEditor;\n    /**\n     * Populate the raw editor toolbar.\n     */\n    function populateToolbar(commands, toolbar) {\n        const { registry, revert, save } = commands;\n        toolbar.addItem('spacer', Toolbar.createSpacerItem());\n        // Note the button order. The rationale here is that no matter what state\n        // the toolbar is in, the relative location of the revert button in the\n        // toolbar remains the same.\n        [revert, save].forEach(name => {\n            const item = new CommandToolbarButton({ commands: registry, id: name });\n            toolbar.addItem(name, item);\n        });\n    }\n    Private.populateToolbar = populateToolbar;\n    /**\n     * Returns the wrapped user overrides editor.\n     */\n    function userEditor(editor, toolbar, inspector, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const userTitle = trans.__('User Preferences');\n        const widget = new Widget();\n        const layout = (widget.layout = new BoxLayout({ spacing: 0 }));\n        const banner = new Widget();\n        banner.node.innerText = userTitle;\n        toolbar.insertItem(0, 'banner', banner);\n        layout.addWidget(toolbar);\n        layout.addWidget(editor);\n        layout.addWidget(inspector);\n        return widget;\n    }\n    Private.userEditor = userEditor;\n})(Private || (Private = {}));\n//# sourceMappingURL=raweditor.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { jupyterIcon } from '@jupyterlab/ui-components';\nimport { JSONExt } from '@lumino/coreutils';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { PluginEditor } from './plugineditor';\nimport { PluginList } from './pluginlist';\nimport { SplitPanel } from './splitpanel';\n/**\n * The ratio panes in the setting editor.\n */\nconst DEFAULT_LAYOUT = {\n    sizes: [1, 3],\n    container: {\n        editor: 'raw',\n        plugin: '',\n        sizes: [1, 1]\n    }\n};\n/**\n * An interface for modifying and saving application settings.\n */\nexport class SettingEditor extends Widget {\n    /**\n     * Create a new setting editor.\n     */\n    constructor(options) {\n        super();\n        this._fetching = null;\n        this._saving = false;\n        this._state = JSONExt.deepCopy(DEFAULT_LAYOUT);\n        this.translator = options.translator || nullTranslator;\n        this.addClass('jp-SettingEditor');\n        this.key = options.key;\n        this.state = options.state;\n        const { commands, editorFactory, rendermime } = options;\n        const layout = (this.layout = new PanelLayout());\n        const registry = (this.registry = options.registry);\n        const panel = (this._panel = new SplitPanel({\n            orientation: 'horizontal',\n            renderer: SplitPanel.defaultRenderer,\n            spacing: 1\n        }));\n        const instructions = (this._instructions = new Widget());\n        const editor = (this._editor = new PluginEditor({\n            commands,\n            editorFactory,\n            registry,\n            rendermime,\n            translator: this.translator\n        }));\n        const confirm = () => editor.confirm();\n        const list = (this._list = new PluginList({\n            confirm,\n            registry,\n            translator: this.translator\n        }));\n        const when = options.when;\n        instructions.addClass('jp-SettingEditorInstructions');\n        Private.populateInstructionsNode(instructions.node, this.translator);\n        if (when) {\n            this._when = Array.isArray(when) ? Promise.all(when) : when;\n        }\n        panel.addClass('jp-SettingEditor-main');\n        layout.addWidget(panel);\n        panel.addWidget(list);\n        panel.addWidget(instructions);\n        SplitPanel.setStretch(list, 0);\n        SplitPanel.setStretch(instructions, 1);\n        SplitPanel.setStretch(editor, 1);\n        editor.stateChanged.connect(this._onStateChanged, this);\n        list.changed.connect(this._onStateChanged, this);\n        panel.handleMoved.connect(this._onStateChanged, this);\n    }\n    /**\n     * Whether the raw editor revert functionality is enabled.\n     */\n    get canRevertRaw() {\n        return this._editor.raw.canRevert;\n    }\n    /**\n     * Whether the raw editor save functionality is enabled.\n     */\n    get canSaveRaw() {\n        return this._editor.raw.canSave;\n    }\n    /**\n     * Emits when the commands passed in at instantiation change.\n     */\n    get commandsChanged() {\n        return this._editor.raw.commandsChanged;\n    }\n    /**\n     * The currently loaded settings.\n     */\n    get settings() {\n        return this._editor.settings;\n    }\n    /**\n     * The inspectable raw user editor source for the currently loaded settings.\n     */\n    get source() {\n        return this._editor.raw.source;\n    }\n    /**\n     * Dispose of the resources held by the setting editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        super.dispose();\n        this._editor.dispose();\n        this._instructions.dispose();\n        this._list.dispose();\n        this._panel.dispose();\n    }\n    /**\n     * Revert raw editor back to original settings.\n     */\n    revert() {\n        this._editor.raw.revert();\n    }\n    /**\n     * Save the contents of the raw editor.\n     */\n    save() {\n        return this._editor.raw.save();\n    }\n    /**\n     * Handle `'after-attach'` messages.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        this._panel.hide();\n        this._fetchState()\n            .then(() => {\n            this._panel.show();\n            this._setState();\n        })\n            .catch(reason => {\n            console.error('Fetching setting editor state failed', reason);\n            this._panel.show();\n            this._setState();\n        });\n    }\n    /**\n     * Handle `'close-request'` messages.\n     */\n    onCloseRequest(msg) {\n        this._editor\n            .confirm()\n            .then(() => {\n            super.onCloseRequest(msg);\n            this.dispose();\n        })\n            .catch(() => {\n            /* no op */\n        });\n    }\n    /**\n     * Get the state of the panel.\n     */\n    _fetchState() {\n        if (this._fetching) {\n            return this._fetching;\n        }\n        const { key, state } = this;\n        const promises = [state.fetch(key), this._when];\n        return (this._fetching = Promise.all(promises).then(([value]) => {\n            this._fetching = null;\n            if (this._saving) {\n                return;\n            }\n            this._state = Private.normalizeState(value, this._state);\n        }));\n    }\n    /**\n     * Handle root level layout state changes.\n     */\n    async _onStateChanged() {\n        this._state.sizes = this._panel.relativeSizes();\n        this._state.container = this._editor.state;\n        this._state.container.plugin = this._list.selection;\n        try {\n            await this._saveState();\n        }\n        catch (error) {\n            console.error('Saving setting editor state failed', error);\n        }\n        this._setState();\n    }\n    /**\n     * Set the state of the setting editor.\n     */\n    async _saveState() {\n        const { key, state } = this;\n        const value = this._state;\n        this._saving = true;\n        try {\n            await state.save(key, value);\n            this._saving = false;\n        }\n        catch (error) {\n            this._saving = false;\n            throw error;\n        }\n    }\n    /**\n     * Set the layout sizes.\n     */\n    _setLayout() {\n        const editor = this._editor;\n        const panel = this._panel;\n        const state = this._state;\n        editor.state = state.container;\n        // Allow the message queue (which includes fit requests that might disrupt\n        // setting relative sizes) to clear before setting sizes.\n        requestAnimationFrame(() => {\n            panel.setRelativeSizes(state.sizes);\n        });\n    }\n    /**\n     * Set the presets of the setting editor.\n     */\n    _setState() {\n        const editor = this._editor;\n        const list = this._list;\n        const panel = this._panel;\n        const { container } = this._state;\n        if (!container.plugin) {\n            editor.settings = null;\n            list.selection = '';\n            this._setLayout();\n            return;\n        }\n        if (editor.settings && editor.settings.id === container.plugin) {\n            this._setLayout();\n            return;\n        }\n        const instructions = this._instructions;\n        this.registry\n            .load(container.plugin)\n            .then(settings => {\n            if (instructions.isAttached) {\n                instructions.parent = null;\n            }\n            if (!editor.isAttached) {\n                panel.addWidget(editor);\n            }\n            editor.settings = settings;\n            list.selection = container.plugin;\n            this._setLayout();\n        })\n            .catch(reason => {\n            console.error(`Loading ${container.plugin} settings failed.`, reason);\n            list.selection = this._state.container.plugin = '';\n            editor.settings = null;\n            this._setLayout();\n        });\n    }\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Populate the instructions text node.\n     */\n    function populateInstructionsNode(node, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        ReactDOM.render(React.createElement(React.Fragment, null,\n            React.createElement(\"h2\", null,\n                React.createElement(jupyterIcon.react, { className: \"jp-SettingEditorInstructions-icon\", tag: \"span\", elementPosition: \"center\", height: \"auto\", width: \"60px\" }),\n                React.createElement(\"span\", { className: \"jp-SettingEditorInstructions-title\" }, \"Settings\")),\n            React.createElement(\"span\", { className: \"jp-SettingEditorInstructions-text\" }, trans.__('Select a plugin from the list to view and edit its preferences.'))), node);\n    }\n    Private.populateInstructionsNode = populateInstructionsNode;\n    /**\n     * Return a normalized restored layout state that defaults to the presets.\n     */\n    function normalizeState(saved, current) {\n        if (!saved) {\n            return JSONExt.deepCopy(DEFAULT_LAYOUT);\n        }\n        if (!('sizes' in saved) || !numberArray(saved.sizes)) {\n            saved.sizes = JSONExt.deepCopy(DEFAULT_LAYOUT.sizes);\n        }\n        if (!('container' in saved)) {\n            saved.container = JSONExt.deepCopy(DEFAULT_LAYOUT.container);\n            return saved;\n        }\n        const container = 'container' in saved &&\n            saved.container &&\n            typeof saved.container === 'object'\n            ? saved.container\n            : {};\n        saved.container = {\n            plugin: typeof container.plugin === 'string'\n                ? container.plugin\n                : DEFAULT_LAYOUT.container.plugin,\n            sizes: numberArray(container.sizes)\n                ? container.sizes\n                : JSONExt.deepCopy(DEFAULT_LAYOUT.container.sizes)\n        };\n        return saved;\n    }\n    Private.normalizeState = normalizeState;\n    /**\n     * Tests whether an array consists exclusively of numbers.\n     */\n    function numberArray(value) {\n        return Array.isArray(value) && value.every(x => typeof x === 'number');\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=settingeditor.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { Signal } from '@lumino/signaling';\nimport { SplitPanel as SPanel } from '@lumino/widgets';\n/**\n * A deprecated split panel that will be removed when the phosphor split panel\n * supports a handle moved signal. See https://github.com/phosphorjs/phosphor/issues/297.\n */\nexport class SplitPanel extends SPanel {\n    constructor() {\n        super(...arguments);\n        /**\n         * Emits when the split handle has moved.\n         */\n        this.handleMoved = new Signal(this);\n    }\n    handleEvent(event) {\n        super.handleEvent(event);\n        if (event.type === 'mouseup') {\n            this.handleMoved.emit(undefined);\n        }\n    }\n}\n//# sourceMappingURL=splitpanel.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The setting editor tracker token.\n */\nexport const ISettingEditorTracker = new Token('@jupyterlab/settingeditor:ISettingEditorTracker');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}