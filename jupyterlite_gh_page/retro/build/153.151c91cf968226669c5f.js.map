{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/settingregistry/lib/settingregistry.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/settingregistry/lib/tokens.js"],"names":["copy","JSONExt","RECORD_SEPARATOR","String","fromCharCode","DefaultSchemaValidator","constructor","this","_composer","useDefaults","_validator","addSchema","validateData","plugin","populate","validate","getSchema","id","compose","schema","type","dataPath","keyword","schemaPath","message","_addSchema","user","raw","error","SyntaxError","column","description","lineNumber","errors","composite","data","composer","validator","validateSchema","removeSchema","SettingRegistry","options","plugins","Object","create","_pluginChanged","Signal","_ready","Promise","resolve","_transformers","connector","_timeout","timeout","_preload","key","undefined","load","then","get","Settings","registry","reload","fetched","fetch","_load","_transform","emit","Private","annotatedPlugin","_save","value","set","assign","transform","transforms","transformers","Error","DisposableDelegate","upload","_validate","output","forEach","index","push","console","warn","join","all","map","async","_a","save","phase","started","Date","getTime","elapsed","transformed","call","setTimeout","_changed","_isDisposed","pluginChanged","connect","_onPluginChanged","version","annotatedDefaults","default","reifyDefault","dispose","remove","sender","reconcileMenus","reference","addition","addNewItems","merged","menu","refIndex","findIndex","ref","items","reconcileItems","item","submenu","_b","command","selector","args","filterDisabledItems","reduce","final","disabled","reconcileShortcuts","defaults","memo","filter","shortcut","keys","CommandRegistry","s","concat","indent","nondescript","untitled","body","acc","val","idx","rows","split","length","trim","indexOf","prefix","source","pre","root","properties","result","props","property","title","sort","a","b","localeCompare","Math","max","repeat","reified","spaces","JSON","stringify","str","defaultDocumentedValue","attribute","documentedValue","ISettingRegistry","Token"],"mappings":"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","file":"153.151c91cf968226669c5f.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CommandRegistry } from '@lumino/commands';\nimport { JSONExt } from '@lumino/coreutils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\nimport Ajv from 'ajv';\nimport * as json5 from 'json5';\nimport SCHEMA from './plugin-schema.json';\n/**\n * An alias for the JSON deep copy function.\n */\nconst copy = JSONExt.deepCopy;\n/**\n * The default number of milliseconds before a `load()` call to the registry\n * will wait before timing out if it requires a transformation that has not been\n * registered.\n */\nconst DEFAULT_TRANSFORM_TIMEOUT = 1000;\n/**\n * The ASCII record separator character.\n */\nconst RECORD_SEPARATOR = String.fromCharCode(30);\n/**\n * The default implementation of a schema validator.\n */\nexport class DefaultSchemaValidator {\n    /**\n     * Instantiate a schema validator.\n     */\n    constructor() {\n        this._composer = new Ajv({ useDefaults: true });\n        this._validator = new Ajv();\n        this._composer.addSchema(SCHEMA, 'jupyterlab-plugin-schema');\n        this._validator.addSchema(SCHEMA, 'jupyterlab-plugin-schema');\n    }\n    /**\n     * Validate a plugin's schema and user data; populate the `composite` data.\n     *\n     * @param plugin - The plugin being validated. Its `composite` data will be\n     * populated by reference.\n     *\n     * @param populate - Whether plugin data should be populated, defaults to\n     * `true`.\n     *\n     * @return A list of errors if either the schema or data fail to validate or\n     * `null` if there are no errors.\n     */\n    validateData(plugin, populate = true) {\n        const validate = this._validator.getSchema(plugin.id);\n        const compose = this._composer.getSchema(plugin.id);\n        // If the schemas do not exist, add them to the validator and continue.\n        if (!validate || !compose) {\n            if (plugin.schema.type !== 'object') {\n                const keyword = 'schema';\n                const message = `Setting registry schemas' root-level type must be ` +\n                    `'object', rejecting type: ${plugin.schema.type}`;\n                return [{ dataPath: 'type', keyword, schemaPath: '', message }];\n            }\n            const errors = this._addSchema(plugin.id, plugin.schema);\n            return errors || this.validateData(plugin);\n        }\n        // Parse the raw commented JSON into a user map.\n        let user;\n        try {\n            user = json5.parse(plugin.raw);\n        }\n        catch (error) {\n            if (error instanceof SyntaxError) {\n                return [\n                    {\n                        dataPath: '',\n                        keyword: 'syntax',\n                        schemaPath: '',\n                        message: error.message\n                    }\n                ];\n            }\n            const { column, description } = error;\n            const line = error.lineNumber;\n            return [\n                {\n                    dataPath: '',\n                    keyword: 'parse',\n                    schemaPath: '',\n                    message: `${description} (line ${line} column ${column})`\n                }\n            ];\n        }\n        if (!validate(user)) {\n            return validate.errors;\n        }\n        // Copy the user data before merging defaults into composite map.\n        const composite = copy(user);\n        if (!compose(composite)) {\n            return compose.errors;\n        }\n        if (populate) {\n            plugin.data = { composite, user };\n        }\n        return null;\n    }\n    /**\n     * Add a schema to the validator.\n     *\n     * @param plugin - The plugin ID.\n     *\n     * @param schema - The schema being added.\n     *\n     * @return A list of errors if the schema fails to validate or `null` if there\n     * are no errors.\n     *\n     * #### Notes\n     * It is safe to call this function multiple times with the same plugin name.\n     */\n    _addSchema(plugin, schema) {\n        const composer = this._composer;\n        const validator = this._validator;\n        const validate = validator.getSchema('jupyterlab-plugin-schema');\n        // Validate against the main schema.\n        if (!validate(schema)) {\n            return validate.errors;\n        }\n        // Validate against the JSON schema meta-schema.\n        if (!validator.validateSchema(schema)) {\n            return validator.errors;\n        }\n        // Remove if schema already exists.\n        composer.removeSchema(plugin);\n        validator.removeSchema(plugin);\n        // Add schema to the validator and composer.\n        composer.addSchema(schema, plugin);\n        validator.addSchema(schema, plugin);\n        return null;\n    }\n}\n/**\n * The default concrete implementation of a setting registry.\n */\nexport class SettingRegistry {\n    /**\n     * Create a new setting registry.\n     */\n    constructor(options) {\n        /**\n         * The schema of the setting registry.\n         */\n        this.schema = SCHEMA;\n        /**\n         * The collection of setting registry plugins.\n         */\n        this.plugins = Object.create(null);\n        this._pluginChanged = new Signal(this);\n        this._ready = Promise.resolve();\n        this._transformers = Object.create(null);\n        this.connector = options.connector;\n        this.validator = options.validator || new DefaultSchemaValidator();\n        this._timeout = options.timeout || DEFAULT_TRANSFORM_TIMEOUT;\n        // Preload with any available data at instantiation-time.\n        if (options.plugins) {\n            this._ready = this._preload(options.plugins);\n        }\n    }\n    /**\n     * A signal that emits the name of a plugin when its settings change.\n     */\n    get pluginChanged() {\n        return this._pluginChanged;\n    }\n    /**\n     * Get an individual setting.\n     *\n     * @param plugin - The name of the plugin whose settings are being retrieved.\n     *\n     * @param key - The name of the setting being retrieved.\n     *\n     * @returns A promise that resolves when the setting is retrieved.\n     */\n    async get(plugin, key) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (plugin in plugins) {\n            const { composite, user } = plugins[plugin].data;\n            return {\n                composite: composite[key] !== undefined ? copy(composite[key]) : undefined,\n                user: user[key] !== undefined ? copy(user[key]) : undefined\n            };\n        }\n        return this.load(plugin).then(() => this.get(plugin, key));\n    }\n    /**\n     * Load a plugin's settings into the setting registry.\n     *\n     * @param plugin - The name of the plugin whose settings are being loaded.\n     *\n     * @returns A promise that resolves with a plugin settings object or rejects\n     * if the plugin is not found.\n     */\n    async load(plugin) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        const registry = this; // eslint-disable-line\n        // If the plugin exists, resolve.\n        if (plugin in plugins) {\n            return new Settings({ plugin: plugins[plugin], registry });\n        }\n        // If the plugin needs to be loaded from the data connector, fetch.\n        return this.reload(plugin);\n    }\n    /**\n     * Reload a plugin's settings into the registry even if they already exist.\n     *\n     * @param plugin - The name of the plugin whose settings are being reloaded.\n     *\n     * @returns A promise that resolves with a plugin settings object or rejects\n     * with a list of `ISchemaValidator.IError` objects if it fails.\n     */\n    async reload(plugin) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const fetched = await this.connector.fetch(plugin);\n        const plugins = this.plugins; // eslint-disable-line\n        const registry = this; // eslint-disable-line\n        if (fetched === undefined) {\n            throw [\n                {\n                    dataPath: '',\n                    keyword: 'id',\n                    message: `Could not fetch settings for ${plugin}.`,\n                    schemaPath: ''\n                }\n            ];\n        }\n        await this._load(await this._transform('fetch', fetched));\n        this._pluginChanged.emit(plugin);\n        return new Settings({ plugin: plugins[plugin], registry });\n    }\n    /**\n     * Remove a single setting in the registry.\n     *\n     * @param plugin - The name of the plugin whose setting is being removed.\n     *\n     * @param key - The name of the setting being removed.\n     *\n     * @returns A promise that resolves when the setting is removed.\n     */\n    async remove(plugin, key) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            return;\n        }\n        const raw = json5.parse(plugins[plugin].raw);\n        // Delete both the value and any associated comment.\n        delete raw[key];\n        delete raw[`// ${key}`];\n        plugins[plugin].raw = Private.annotatedPlugin(plugins[plugin], raw);\n        return this._save(plugin);\n    }\n    /**\n     * Set a single setting in the registry.\n     *\n     * @param plugin - The name of the plugin whose setting is being set.\n     *\n     * @param key - The name of the setting being set.\n     *\n     * @param value - The value of the setting being set.\n     *\n     * @returns A promise that resolves when the setting has been saved.\n     *\n     */\n    async set(plugin, key, value) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            return this.load(plugin).then(() => this.set(plugin, key, value));\n        }\n        // Parse the raw JSON string removing all comments and return an object.\n        const raw = json5.parse(plugins[plugin].raw);\n        plugins[plugin].raw = Private.annotatedPlugin(plugins[plugin], Object.assign(Object.assign({}, raw), { [key]: value }));\n        return this._save(plugin);\n    }\n    /**\n     * Register a plugin transform function to act on a specific plugin.\n     *\n     * @param plugin - The name of the plugin whose settings are transformed.\n     *\n     * @param transforms - The transform functions applied to the plugin.\n     *\n     * @returns A disposable that removes the transforms from the registry.\n     *\n     * #### Notes\n     * - `compose` transformations: The registry automatically overwrites a\n     * plugin's default values with user overrides, but a plugin may instead wish\n     * to merge values. This behavior can be accomplished in a `compose`\n     * transformation.\n     * - `fetch` transformations: The registry uses the plugin data that is\n     * fetched from its connector. If a plugin wants to override, e.g. to update\n     * its schema with dynamic defaults, a `fetch` transformation can be applied.\n     */\n    transform(plugin, transforms) {\n        const transformers = this._transformers;\n        if (plugin in transformers) {\n            throw new Error(`${plugin} already has a transformer.`);\n        }\n        transformers[plugin] = {\n            fetch: transforms.fetch || (plugin => plugin),\n            compose: transforms.compose || (plugin => plugin)\n        };\n        return new DisposableDelegate(() => {\n            delete transformers[plugin];\n        });\n    }\n    /**\n     * Upload a plugin's settings.\n     *\n     * @param plugin - The name of the plugin whose settings are being set.\n     *\n     * @param raw - The raw plugin settings being uploaded.\n     *\n     * @returns A promise that resolves when the settings have been saved.\n     */\n    async upload(plugin, raw) {\n        // Wait for data preload before allowing normal operation.\n        await this._ready;\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            return this.load(plugin).then(() => this.upload(plugin, raw));\n        }\n        // Set the local copy.\n        plugins[plugin].raw = raw;\n        return this._save(plugin);\n    }\n    /**\n     * Load a plugin into the registry.\n     */\n    async _load(data) {\n        const plugin = data.id;\n        // Validate and preload the item.\n        try {\n            await this._validate(data);\n        }\n        catch (errors) {\n            const output = [`Validating ${plugin} failed:`];\n            errors.forEach((error, index) => {\n                const { dataPath, schemaPath, keyword, message } = error;\n                if (dataPath || schemaPath) {\n                    output.push(`${index} - schema @ ${schemaPath}, data @ ${dataPath}`);\n                }\n                output.push(`{${keyword}} ${message}`);\n            });\n            console.warn(output.join('\\n'));\n            throw errors;\n        }\n    }\n    /**\n     * Preload a list of plugins and fail gracefully.\n     */\n    async _preload(plugins) {\n        await Promise.all(plugins.map(async (plugin) => {\n            var _a;\n            try {\n                // Apply a transformation to the plugin if necessary.\n                await this._load(await this._transform('fetch', plugin));\n            }\n            catch (errors) {\n                /* Ignore preload timeout errors silently. */\n                if (((_a = errors[0]) === null || _a === void 0 ? void 0 : _a.keyword) !== 'timeout') {\n                    console.warn('Ignored setting registry preload errors.', errors);\n                }\n            }\n        }));\n    }\n    /**\n     * Save a plugin in the registry.\n     */\n    async _save(plugin) {\n        const plugins = this.plugins;\n        if (!(plugin in plugins)) {\n            throw new Error(`${plugin} does not exist in setting registry.`);\n        }\n        try {\n            await this._validate(plugins[plugin]);\n        }\n        catch (errors) {\n            console.warn(`${plugin} validation errors:`, errors);\n            throw new Error(`${plugin} failed to validate; check console.`);\n        }\n        await this.connector.save(plugin, plugins[plugin].raw);\n        // Fetch and reload the data to guarantee server and client are in sync.\n        const fetched = await this.connector.fetch(plugin);\n        if (fetched === undefined) {\n            throw [\n                {\n                    dataPath: '',\n                    keyword: 'id',\n                    message: `Could not fetch settings for ${plugin}.`,\n                    schemaPath: ''\n                }\n            ];\n        }\n        await this._load(await this._transform('fetch', fetched));\n        this._pluginChanged.emit(plugin);\n    }\n    /**\n     * Transform the plugin if necessary.\n     */\n    async _transform(phase, plugin, started = new Date().getTime()) {\n        const elapsed = new Date().getTime() - started;\n        const id = plugin.id;\n        const transformers = this._transformers;\n        const timeout = this._timeout;\n        if (!plugin.schema['jupyter.lab.transform']) {\n            return plugin;\n        }\n        if (id in transformers) {\n            const transformed = transformers[id][phase].call(null, plugin);\n            if (transformed.id !== id) {\n                throw [\n                    {\n                        dataPath: '',\n                        keyword: 'id',\n                        message: 'Plugin transformations cannot change plugin IDs.',\n                        schemaPath: ''\n                    }\n                ];\n            }\n            return transformed;\n        }\n        // If the timeout has not been exceeded, stall and try again in 250ms.\n        if (elapsed < timeout) {\n            await new Promise(resolve => {\n                setTimeout(() => {\n                    resolve();\n                }, 250);\n            });\n            return this._transform(phase, plugin, started);\n        }\n        throw [\n            {\n                dataPath: '',\n                keyword: 'timeout',\n                message: `Transforming ${plugin.id} timed out.`,\n                schemaPath: ''\n            }\n        ];\n    }\n    /**\n     * Validate and preload a plugin, compose the `composite` data.\n     */\n    async _validate(plugin) {\n        // Validate the user data and create the composite data.\n        const errors = this.validator.validateData(plugin);\n        if (errors) {\n            throw errors;\n        }\n        // Apply a transformation if necessary and set the local copy.\n        this.plugins[plugin.id] = await this._transform('compose', plugin);\n    }\n}\n/**\n * A manager for a specific plugin's settings.\n */\nexport class Settings {\n    /**\n     * Instantiate a new plugin settings manager.\n     */\n    constructor(options) {\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this.id = options.plugin.id;\n        this.registry = options.registry;\n        this.registry.pluginChanged.connect(this._onPluginChanged, this);\n    }\n    /**\n     * A signal that emits when the plugin's settings have changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The composite of user settings and extension defaults.\n     */\n    get composite() {\n        return this.plugin.data.composite;\n    }\n    /**\n     * Test whether the plugin settings manager disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    get plugin() {\n        return this.registry.plugins[this.id];\n    }\n    /**\n     * The plugin's schema.\n     */\n    get schema() {\n        return this.plugin.schema;\n    }\n    /**\n     * The plugin settings raw text value.\n     */\n    get raw() {\n        return this.plugin.raw;\n    }\n    /**\n     * The user settings.\n     */\n    get user() {\n        return this.plugin.data.user;\n    }\n    /**\n     * The published version of the NPM package containing these settings.\n     */\n    get version() {\n        return this.plugin.version;\n    }\n    /**\n     * Return the defaults in a commented JSON format.\n     */\n    annotatedDefaults() {\n        return Private.annotatedDefaults(this.schema, this.id);\n    }\n    /**\n     * Calculate the default value of a setting by iterating through the schema.\n     *\n     * @param key - The name of the setting whose default value is calculated.\n     *\n     * @returns A calculated default JSON value for a specific setting.\n     */\n    default(key) {\n        return Private.reifyDefault(this.schema, key);\n    }\n    /**\n     * Dispose of the plugin settings resources.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Get an individual setting.\n     *\n     * @param key - The name of the setting being retrieved.\n     *\n     * @returns The setting value.\n     *\n     * #### Notes\n     * This method returns synchronously because it uses a cached copy of the\n     * plugin settings that is synchronized with the registry.\n     */\n    get(key) {\n        const { composite, user } = this;\n        return {\n            composite: composite[key] !== undefined ? copy(composite[key]) : undefined,\n            user: user[key] !== undefined ? copy(user[key]) : undefined\n        };\n    }\n    /**\n     * Remove a single setting.\n     *\n     * @param key - The name of the setting being removed.\n     *\n     * @returns A promise that resolves when the setting is removed.\n     *\n     * #### Notes\n     * This function is asynchronous because it writes to the setting registry.\n     */\n    remove(key) {\n        return this.registry.remove(this.plugin.id, key);\n    }\n    /**\n     * Save all of the plugin's user settings at once.\n     */\n    save(raw) {\n        return this.registry.upload(this.plugin.id, raw);\n    }\n    /**\n     * Set a single setting.\n     *\n     * @param key - The name of the setting being set.\n     *\n     * @param value - The value of the setting.\n     *\n     * @returns A promise that resolves when the setting has been saved.\n     *\n     * #### Notes\n     * This function is asynchronous because it writes to the setting registry.\n     */\n    set(key, value) {\n        return this.registry.set(this.plugin.id, key, value);\n    }\n    /**\n     * Validates raw settings with comments.\n     *\n     * @param raw - The JSON with comments string being validated.\n     *\n     * @returns A list of errors or `null` if valid.\n     */\n    validate(raw) {\n        const data = { composite: {}, user: {} };\n        const { id, schema } = this.plugin;\n        const validator = this.registry.validator;\n        const version = this.version;\n        return validator.validateData({ data, id, raw, schema, version }, false);\n    }\n    /**\n     * Handle plugin changes in the setting registry.\n     */\n    _onPluginChanged(sender, plugin) {\n        if (plugin === this.plugin.id) {\n            this._changed.emit(undefined);\n        }\n    }\n}\n/**\n * A namespace for `SettingRegistry` statics.\n */\n(function (SettingRegistry) {\n    /**\n     * Reconcile the menus.\n     *\n     * @param reference The reference list of menus.\n     * @param addition The list of menus to add.\n     * @param warn Warn if the command items are duplicated within the same menu.\n     * @returns The reconciled list of menus.\n     */\n    function reconcileMenus(reference, addition, warn = false, addNewItems = true) {\n        if (!reference) {\n            return addition && addNewItems ? JSONExt.deepCopy(addition) : [];\n        }\n        if (!addition) {\n            return JSONExt.deepCopy(reference);\n        }\n        const merged = JSONExt.deepCopy(reference);\n        addition.forEach(menu => {\n            const refIndex = merged.findIndex(ref => ref.id === menu.id);\n            if (refIndex >= 0) {\n                merged[refIndex] = Object.assign(Object.assign(Object.assign({}, merged[refIndex]), menu), { items: reconcileItems(merged[refIndex].items, menu.items, warn, addNewItems) });\n            }\n            else {\n                if (addNewItems) {\n                    merged.push(menu);\n                }\n            }\n        });\n        return merged;\n    }\n    SettingRegistry.reconcileMenus = reconcileMenus;\n    /**\n     * Merge two set of menu items.\n     *\n     * @param reference Reference set of menu items\n     * @param addition New items to add\n     * @param warn Whether to warn if item is duplicated; default to false\n     * @returns The merged set of items\n     */\n    function reconcileItems(reference, addition, warn = false, addNewItems = true) {\n        if (!reference) {\n            return addition ? JSONExt.deepCopy(addition) : undefined;\n        }\n        if (!addition) {\n            return JSONExt.deepCopy(reference);\n        }\n        const items = JSONExt.deepCopy(reference);\n        // Merge array element depending on the type\n        addition.forEach(item => {\n            var _a;\n            switch ((_a = item.type) !== null && _a !== void 0 ? _a : 'command') {\n                case 'separator':\n                    if (addNewItems) {\n                        items.push(Object.assign({}, item));\n                    }\n                    break;\n                case 'submenu':\n                    if (item.submenu) {\n                        const refIndex = items.findIndex(ref => { var _a, _b; return ref.type === 'submenu' && ((_a = ref.submenu) === null || _a === void 0 ? void 0 : _a.id) === ((_b = item.submenu) === null || _b === void 0 ? void 0 : _b.id); });\n                        if (refIndex < 0) {\n                            if (addNewItems) {\n                                items.push(JSONExt.deepCopy(item));\n                            }\n                        }\n                        else {\n                            items[refIndex] = Object.assign(Object.assign(Object.assign({}, items[refIndex]), item), { submenu: reconcileMenus(items[refIndex].submenu\n                                    ? [items[refIndex].submenu]\n                                    : null, [item.submenu], warn, addNewItems)[0] });\n                        }\n                    }\n                    break;\n                case 'command':\n                    if (item.command) {\n                        const refIndex = items.findIndex(ref => {\n                            var _a, _b;\n                            return ref.command === item.command &&\n                                ref.selector === item.selector &&\n                                JSONExt.deepEqual((_a = ref.args) !== null && _a !== void 0 ? _a : {}, (_b = item.args) !== null && _b !== void 0 ? _b : {});\n                        });\n                        if (refIndex < 0) {\n                            if (addNewItems) {\n                                items.push(Object.assign({}, item));\n                            }\n                        }\n                        else {\n                            if (warn) {\n                                console.warn(`Menu entry for command '${item.command}' is duplicated.`);\n                            }\n                            items[refIndex] = Object.assign(Object.assign({}, items[refIndex]), item);\n                        }\n                    }\n            }\n        });\n        return items;\n    }\n    SettingRegistry.reconcileItems = reconcileItems;\n    function filterDisabledItems(items) {\n        return items.reduce((final, value) => {\n            var _a;\n            const copy = Object.assign({}, value);\n            if (!copy.disabled) {\n                if (copy.type === 'submenu') {\n                    const { submenu } = copy;\n                    if (submenu && !submenu.disabled) {\n                        copy.submenu = Object.assign(Object.assign({}, submenu), { items: filterDisabledItems((_a = submenu.items) !== null && _a !== void 0 ? _a : []) });\n                    }\n                }\n                final.push(copy);\n            }\n            return final;\n        }, []);\n    }\n    SettingRegistry.filterDisabledItems = filterDisabledItems;\n    /**\n     * Reconcile default and user shortcuts and return the composite list.\n     *\n     * @param defaults - The list of default shortcuts.\n     *\n     * @param user - The list of user shortcut overrides and additions.\n     *\n     * @returns A loadable list of shortcuts (omitting disabled and overridden).\n     */\n    function reconcileShortcuts(defaults, user) {\n        const memo = {};\n        // If a user shortcut collides with another user shortcut warn and filter.\n        user = user.filter(shortcut => {\n            const keys = CommandRegistry.normalizeKeys(shortcut).join(RECORD_SEPARATOR);\n            if (!keys) {\n                console.warn('Skipping this shortcut because there are no actionable keys on this platform', shortcut);\n                return false;\n            }\n            if (!(keys in memo)) {\n                memo[keys] = {};\n            }\n            const { selector } = shortcut;\n            if (!(selector in memo[keys])) {\n                memo[keys][selector] = false; // Do not warn if a default shortcut conflicts.\n                return true;\n            }\n            console.warn('Skipping this shortcut because it collides with another shortcut.', shortcut);\n            return false;\n        });\n        // If a default shortcut collides with another default, warn and filter,\n        // unless one of the shortcuts is a disabling shortcut (so look through\n        // disabled shortcuts first). If a shortcut has already been added by the\n        // user preferences, filter it out too (this includes shortcuts that are\n        // disabled by user preferences).\n        defaults = [\n            ...defaults.filter(s => !!s.disabled),\n            ...defaults.filter(s => !s.disabled)\n        ].filter(shortcut => {\n            const keys = CommandRegistry.normalizeKeys(shortcut).join(RECORD_SEPARATOR);\n            if (!keys) {\n                return false;\n            }\n            if (!(keys in memo)) {\n                memo[keys] = {};\n            }\n            const { disabled, selector } = shortcut;\n            if (!(selector in memo[keys])) {\n                // Warn of future conflicts if the default shortcut is not disabled.\n                memo[keys][selector] = !disabled;\n                return true;\n            }\n            // We have a conflict now. Warn the user if we need to do so.\n            if (memo[keys][selector]) {\n                console.warn('Skipping this default shortcut because it collides with another default shortcut.', shortcut);\n            }\n            return false;\n        });\n        // Return all the shortcuts that should be registered\n        return user.concat(defaults).filter(shortcut => !shortcut.disabled);\n    }\n    SettingRegistry.reconcileShortcuts = reconcileShortcuts;\n})(SettingRegistry || (SettingRegistry = {}));\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default indentation level, uses spaces instead of tabs.\n     */\n    const indent = '    ';\n    /**\n     * Replacement text for schema properties missing a `description` field.\n     */\n    const nondescript = '[missing schema description]';\n    /**\n     * Replacement text for schema properties missing a `title` field.\n     */\n    const untitled = '[missing schema title]';\n    /**\n     * Returns an annotated (JSON with comments) version of a schema's defaults.\n     */\n    function annotatedDefaults(schema, plugin) {\n        const { description, properties, title } = schema;\n        const keys = properties\n            ? Object.keys(properties).sort((a, b) => a.localeCompare(b))\n            : [];\n        const length = Math.max((description || nondescript).length, plugin.length);\n        return [\n            '{',\n            prefix(`${title || untitled}`),\n            prefix(plugin),\n            prefix(description || nondescript),\n            prefix('*'.repeat(length)),\n            '',\n            join(keys.map(key => defaultDocumentedValue(schema, key))),\n            '}'\n        ].join('\\n');\n    }\n    Private.annotatedDefaults = annotatedDefaults;\n    /**\n     * Returns an annotated (JSON with comments) version of a plugin's\n     * setting data.\n     */\n    function annotatedPlugin(plugin, data) {\n        const { description, title } = plugin.schema;\n        const keys = Object.keys(data).sort((a, b) => a.localeCompare(b));\n        const length = Math.max((description || nondescript).length, plugin.id.length);\n        return [\n            '{',\n            prefix(`${title || untitled}`),\n            prefix(plugin.id),\n            prefix(description || nondescript),\n            prefix('*'.repeat(length)),\n            '',\n            join(keys.map(key => documentedValue(plugin.schema, key, data[key]))),\n            '}'\n        ].join('\\n');\n    }\n    Private.annotatedPlugin = annotatedPlugin;\n    /**\n     * Returns the default value-with-documentation-string for a\n     * specific schema property.\n     */\n    function defaultDocumentedValue(schema, key) {\n        const props = (schema.properties && schema.properties[key]) || {};\n        const type = props['type'];\n        const description = props['description'] || nondescript;\n        const title = props['title'] || '';\n        const reified = reifyDefault(schema, key);\n        const spaces = indent.length;\n        const defaults = reified !== undefined\n            ? prefix(`\"${key}\": ${JSON.stringify(reified, null, spaces)}`, indent)\n            : prefix(`\"${key}\": ${type}`);\n        return [prefix(title), prefix(description), defaults]\n            .filter(str => str.length)\n            .join('\\n');\n    }\n    /**\n     * Returns a value-with-documentation-string for a specific schema property.\n     */\n    function documentedValue(schema, key, value) {\n        const props = schema.properties && schema.properties[key];\n        const description = (props && props['description']) || nondescript;\n        const title = (props && props['title']) || untitled;\n        const spaces = indent.length;\n        const attribute = prefix(`\"${key}\": ${JSON.stringify(value, null, spaces)}`, indent);\n        return [prefix(title), prefix(description), attribute].join('\\n');\n    }\n    /**\n     * Returns a joined string with line breaks and commas where appropriate.\n     */\n    function join(body) {\n        return body.reduce((acc, val, idx) => {\n            const rows = val.split('\\n');\n            const last = rows[rows.length - 1];\n            const comment = last.trim().indexOf('//') === 0;\n            const comma = comment || idx === body.length - 1 ? '' : ',';\n            const separator = idx === body.length - 1 ? '' : '\\n\\n';\n            return acc + val + comma + separator;\n        }, '');\n    }\n    /**\n     * Returns a documentation string with a comment prefix added on every line.\n     */\n    function prefix(source, pre = `${indent}// `) {\n        return pre + source.split('\\n').join(`\\n${pre}`);\n    }\n    /**\n     * Create a fully extrapolated default value for a root key in a schema.\n     */\n    function reifyDefault(schema, root) {\n        var _a;\n        // If the property is at the root level, traverse its schema.\n        schema = (root ? (_a = schema.properties) === null || _a === void 0 ? void 0 : _a[root] : schema) || {};\n        // If the property has no default or is a primitive, return.\n        if (!('default' in schema) || schema.type !== 'object') {\n            return schema.default;\n        }\n        // Make a copy of the default value to populate.\n        const result = JSONExt.deepCopy(schema.default);\n        // Iterate through and populate each child property.\n        const props = schema.properties || {};\n        for (const property in props) {\n            result[property] = reifyDefault(props[property]);\n        }\n        return result;\n    }\n    Private.reifyDefault = reifyDefault;\n})(Private || (Private = {}));\n//# sourceMappingURL=settingregistry.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The setting registry token.\n */\nexport const ISettingRegistry = new Token('@jupyterlab/coreutils:ISettingRegistry');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}