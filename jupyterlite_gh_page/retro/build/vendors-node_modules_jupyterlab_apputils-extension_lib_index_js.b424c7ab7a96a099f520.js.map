{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/apputils-extension/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/apputils-extension/lib/palette.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/apputils-extension/lib/settingconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/apputils-extension/lib/settingsplugin.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/apputils-extension/lib/themesplugins.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/apputils-extension/lib/workspacesplugin.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoF;AACkI;AAC3J;AACI;AACP;AACF;AACS;AACX;AACI;AACD;AACnB;AACc;AACsB;AAClB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B,cAAc,iEAAe;AAC7B,eAAe,yEAAgB;AAC/B;AACA,eAAe,uDAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAe,EAAE,gEAAW;AAC3C;AACA,QAAQ,sDAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iEAAe;AAC7B,eAAe,2EAAsB,EAAE,4DAAO;AAC9C;AACA,eAAe,eAAe;AAC9B,sBAAsB,6EAA0B;AAChD,2BAA2B,gEAAc;AACzC,0BAA0B,uEAAoB;AAC9C,yBAAyB,uEAAoB;AAC7C,qBAAqB,uEAAoB;AACzC;AACA;AACA,kDAAkD,8EAA2B;AAC7E,gCAAgC,8DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,2BAA2B,8DAAW,mCAAmC,OAAO;AAChF,8BAA8B,8DAAW,OAAO,qEAAkB;AAClE;AACA;AACA,mCAAmC,6EAA0B;AAC7D,sCAAsC,aAAa;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B,cAAc,+DAAa;AAC3B;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAA0B;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,GAAG;AAChC;AACA,iCAAiC,GAAG;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,sDAAS;AACtC;AACA;AACA;AACA,yBAAyB,wDAAM;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,qEAAmB,EAAE,kCAAkC;AAC3E,oBAAoB,mEAAiB,EAAE,qCAAqC;AAC5E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS,GAAG,kDAAkD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAyB;AAChD,aAAa;AACb;AACA;AACA,sCAAsC,2EAAyB;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA,eAAe,gEAAW;AAC1B,eAAe,iEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,gEAAgE,gEAAc;AAC9E;AACA;AACA;AACA,yCAAyC,gEAAc;AACvD;AACA;AACA,aAAa;AACb;AACA;AACA,sCAAsC,gEAAc;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,6CAA6C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qCAAqC,UAAU,QAAQ;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,IAAI,UAAU,EAAE,kBAAkB,MAAM,OAAO,MAAM,KAAK;AAClG;AACA;AACA,gCAAgC,QAAQ,EAAE,iBAAiB,MAAM,QAAQ,KAAK,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAQ;AACtB,eAAe,2EAAsB,EAAE,4DAAO,EAAE,gEAAW;AAC3D,eAAe,iEAAe;AAC9B;AACA;AACA;AACA,uBAAuB,wDAAO;AAC9B;AACA;AACA,eAAe,iCAAiC;AAChD,eAAe,aAAa;AAC5B;AACA,8BAA8B,8DAAe;AAC7C,uBAAuB,wDAAO,EAAE,+BAA+B;AAC/D,yBAAyB,sDAAS;AAClC;AACA,8BAA8B;AAC9B;AACA,uCAAuC,iBAAiB;AACxD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C,uBAAuB,OAAO;AAC9B,8BAA8B,6EAA0B;AACxD;AACA;AACA,0BAA0B,8DAAW;AACrC,0BAA0B,8DAAW;AACrC;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0CAA0C;AACrF;AACA;AACA,wBAAwB,UAAU;AAClC,wDAAwD,UAAU;AAClE;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC;AAC5E;AACA;AACA;AACA;AACA;AACA,uCAAuC,6EAA0B;AACjE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,qBAAqB;AAC5C,8BAA8B,6EAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA,mCAAmC,6EAA0B;AAC7D;AACA;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAsB;AACpC;AACA;AACA,eAAe,uEAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAU;AACxB;AACA,eAAe,kEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAc;AAClB;AACA;AACA;AACA,IAAI,yDAAY;AAChB,IAAI,oEAAuB;AAC3B;AACA;AACA,IAAI,gEAAgB;AACpB;AACA,iEAAe,OAAO,EAAC;AACvB,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpgBA;AACA;AACA;AACA;AAC2D;AACF;AACkB;AAClC;AACU;AACK;AACP;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wCAAwC,mEAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAkB;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,iCAAiC,qEAAmB,EAAE,0BAA0B;AAChF;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B,uDAAI;AAChC;AACA,2BAA2B,6EAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAc;AACxC;AACA,0BAA0B,wFAAiC;AAC3D,aAAa;AACb;AACA,iCAAiC,kEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,mC;;;;;;;;;;;;;;;;;;;;;ACjLmD;AACC;AACR;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,8DAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAS;AAC1C;AACA;AACA;AACA;AACA,eAAe,yBAAyB,GAAG,uEAAoB;AAC/D,eAAe,cAAc;AAC7B;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACmD;AAC6B;AAC1B;AACtD;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,aAAa,GAAG,uEAAoB;AACnD,8BAA8B,+DAAgB;AAC9C,6BAA6B,wEAAe;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,GAAG;AACpE;AACA,0DAA0D,iBAAiB,OAAO,GAAG;AACrF;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA,cAAc,yEAAgB;AAC9B;AACA,0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AAC0D;AACyC;AACxC;AACV;AACc;AACT;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACO;AACP;AACA,eAAe,yEAAgB,EAAE,2EAAsB,EAAE,gEAAW;AACpE,eAAe,+DAAa;AAC5B;AACA;AACA;AACA;AACA,oBAAoB,8DAAW,CAAC,wEAAqB;AACrD;AACA,4BAA4B,8DAAY;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,cAAc,+DAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,+DAAa,EAAE,gEAAW;AACzC,eAAe,iEAAe,EAAE,2DAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB,mBAAmB,YAAY;AACrF,iBAAiB;AACjB;AACA,iCAAiC,gDAAgD;AACjF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrNA;AACA;AACmE;AACQ;AAC5B;AAC4B;AACb;AACf;AACuB;AAC7B;AACzC;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,wEAAmB;AAC3B,QAAQ,iEAAe;AACvB,QAAQ,yDAAQ;AAChB,QAAQ,gEAAW;AACnB,QAAQ,2EAAsB;AAC9B;AACA,eAAe,4DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAc;AAC/D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAW;AACvC;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAc,EAAE,cAAc,mDAAM,aAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA,wBAAwB,iEAAe,EAAE,0BAA0B;AACnE,6BAA6B,gEAAU;AACvC;AACA;AACA,sBAAsB,qEAAmB,EAAE,4BAA4B;AACvE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAM;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,4C","file":"vendors-node_modules_jupyterlab_apputils-extension_lib_index_js.b424c7ab7a96a099f520.js","sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module apputils-extension\n */\nimport { ILayoutRestorer, IRouter, JupyterFrontEnd } from '@jupyterlab/application';\nimport { defaultSanitizer, Dialog, ICommandPalette, ISanitizer, ISessionContextDialogs, ISplashScreen, IWindowResolver, MainAreaWidget, Printing, sessionContextDialogs, WindowResolver } from '@jupyterlab/apputils';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IStateDB, StateDB } from '@jupyterlab/statedb';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { jupyterFaviconIcon } from '@jupyterlab/ui-components';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Debouncer, Throttler } from '@lumino/polling';\nimport { Palette } from './palette';\nimport { settingsPlugin } from './settingsplugin';\nimport { themesPaletteMenuPlugin, themesPlugin } from './themesplugins';\nimport { workspacesPlugin } from './workspacesplugin';\n/**\n * The interval in milliseconds before recover options appear during splash.\n */\nconst SPLASH_RECOVER_TIMEOUT = 12000;\n/**\n * The command IDs used by the apputils plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.loadState = 'apputils:load-statedb';\n    CommandIDs.print = 'apputils:print';\n    CommandIDs.reset = 'apputils:reset';\n    CommandIDs.resetOnLoad = 'apputils:reset-on-load';\n    CommandIDs.runFirstEnabled = 'apputils:run-first-enabled';\n    CommandIDs.runAllEnabled = 'apputils:run-all-enabled';\n    CommandIDs.toggleHeader = 'apputils:toggle-header';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The default command palette extension.\n */\nconst palette = {\n    id: '@jupyterlab/apputils-extension:palette',\n    autoStart: true,\n    requires: [ITranslator],\n    provides: ICommandPalette,\n    optional: [ISettingRegistry],\n    activate: (app, translator, settingRegistry) => {\n        return Palette.activate(app, translator, settingRegistry);\n    }\n};\n/**\n * The default command palette's restoration extension.\n *\n * #### Notes\n * The command palette's restoration logic is handled separately from the\n * command palette provider extension because the layout restorer dependency\n * causes the command palette to be unavailable to other extensions earlier\n * in the application load cycle.\n */\nconst paletteRestorer = {\n    id: '@jupyterlab/apputils-extension:palette-restorer',\n    autoStart: true,\n    requires: [ILayoutRestorer, ITranslator],\n    activate: (app, restorer, translator) => {\n        Palette.restore(app, restorer, translator);\n    }\n};\n/**\n * The default window name resolver provider.\n */\nconst resolver = {\n    id: '@jupyterlab/apputils-extension:resolver',\n    autoStart: true,\n    provides: IWindowResolver,\n    requires: [JupyterFrontEnd.IPaths, IRouter],\n    activate: async (app, paths, router) => {\n        const { hash, search } = router.current;\n        const query = URLExt.queryStringToObject(search || '');\n        const solver = new WindowResolver();\n        const workspace = PageConfig.getOption('workspace');\n        const treePath = PageConfig.getOption('treePath');\n        const mode = PageConfig.getOption('mode') === 'multiple-document' ? 'lab' : 'doc';\n        // This is used as a key in local storage to refer to workspaces, either the name\n        // of the workspace or the string PageConfig.defaultWorkspace. Both lab and doc modes share the same workspace.\n        const candidate = workspace ? workspace : PageConfig.defaultWorkspace;\n        const rest = treePath ? URLExt.join('tree', treePath) : '';\n        try {\n            await solver.resolve(candidate);\n            return solver;\n        }\n        catch (error) {\n            // Window resolution has failed so the URL must change. Return a promise\n            // that never resolves to prevent the application from loading plugins\n            // that rely on `IWindowResolver`.\n            return new Promise(() => {\n                const { base } = paths.urls;\n                const pool = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n                const random = pool[Math.floor(Math.random() * pool.length)];\n                let path = URLExt.join(base, mode, 'workspaces', `auto-${random}`);\n                path = rest ? URLExt.join(path, URLExt.encodeParts(rest)) : path;\n                // Reset the workspace on load.\n                query['reset'] = '';\n                const url = path + URLExt.objectToQueryString(query) + (hash || '');\n                router.navigate(url, { hard: true });\n            });\n        }\n    }\n};\n/**\n * The default splash screen provider.\n */\nconst splash = {\n    id: '@jupyterlab/apputils-extension:splash',\n    autoStart: true,\n    requires: [ITranslator],\n    provides: ISplashScreen,\n    activate: (app, translator) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, restored } = app;\n        // Create splash element and populate it.\n        const splash = document.createElement('div');\n        const galaxy = document.createElement('div');\n        const logo = document.createElement('div');\n        splash.id = 'jupyterlab-splash';\n        galaxy.id = 'galaxy';\n        logo.id = 'main-logo';\n        jupyterFaviconIcon.element({\n            container: logo,\n            stylesheet: 'splash'\n        });\n        galaxy.appendChild(logo);\n        ['1', '2', '3'].forEach(id => {\n            const moon = document.createElement('div');\n            const planet = document.createElement('div');\n            moon.id = `moon${id}`;\n            moon.className = 'moon orbit';\n            planet.id = `planet${id}`;\n            planet.className = 'planet';\n            moon.appendChild(planet);\n            galaxy.appendChild(moon);\n        });\n        splash.appendChild(galaxy);\n        // Create debounced recovery dialog function.\n        let dialog;\n        const recovery = new Throttler(async () => {\n            if (dialog) {\n                return;\n            }\n            dialog = new Dialog({\n                title: trans.__('Loading…'),\n                body: trans.__(`The loading screen is taking a long time.\nWould you like to clear the workspace or keep waiting?`),\n                buttons: [\n                    Dialog.cancelButton({ label: trans.__('Keep Waiting') }),\n                    Dialog.warnButton({ label: trans.__('Clear Workspace') })\n                ]\n            });\n            try {\n                const result = await dialog.launch();\n                dialog.dispose();\n                dialog = null;\n                if (result.button.accept && commands.hasCommand(CommandIDs.reset)) {\n                    return commands.execute(CommandIDs.reset);\n                }\n                // Re-invoke the recovery timer in the next frame.\n                requestAnimationFrame(() => {\n                    // Because recovery can be stopped, handle invocation rejection.\n                    void recovery.invoke().catch(_ => undefined);\n                });\n            }\n            catch (error) {\n                /* no-op */\n            }\n        }, { limit: SPLASH_RECOVER_TIMEOUT, edge: 'trailing' });\n        // Return ISplashScreen.\n        let splashCount = 0;\n        return {\n            show: (light = true) => {\n                splash.classList.remove('splash-fade');\n                splash.classList.toggle('light', light);\n                splash.classList.toggle('dark', !light);\n                splashCount++;\n                document.body.appendChild(splash);\n                // Because recovery can be stopped, handle invocation rejection.\n                void recovery.invoke().catch(_ => undefined);\n                return new DisposableDelegate(async () => {\n                    await restored;\n                    if (--splashCount === 0) {\n                        void recovery.stop();\n                        if (dialog) {\n                            dialog.dispose();\n                            dialog = null;\n                        }\n                        splash.classList.add('splash-fade');\n                        window.setTimeout(() => {\n                            document.body.removeChild(splash);\n                        }, 200);\n                    }\n                });\n            }\n        };\n    }\n};\nconst print = {\n    id: '@jupyterlab/apputils-extension:print',\n    autoStart: true,\n    requires: [ITranslator],\n    activate: (app, translator) => {\n        const trans = translator.load('jupyterlab');\n        app.commands.addCommand(CommandIDs.print, {\n            label: trans.__('Print…'),\n            isEnabled: () => {\n                const widget = app.shell.currentWidget;\n                return Printing.getPrintFunction(widget) !== null;\n            },\n            execute: async () => {\n                const widget = app.shell.currentWidget;\n                const printFunction = Printing.getPrintFunction(widget);\n                if (printFunction) {\n                    await printFunction();\n                }\n            }\n        });\n    }\n};\nexport const toggleHeader = {\n    id: '@jupyterlab/apputils-extension:toggle-header',\n    autoStart: true,\n    requires: [ITranslator],\n    optional: [ICommandPalette],\n    activate: (app, translator, palette) => {\n        const trans = translator.load('jupyterlab');\n        const category = trans.__('Main Area');\n        app.commands.addCommand(CommandIDs.toggleHeader, {\n            label: trans.__('Show Header Above Content'),\n            isEnabled: () => app.shell.currentWidget instanceof MainAreaWidget &&\n                app.shell.currentWidget.contentHeader.widgets.length > 0,\n            isToggled: () => {\n                const widget = app.shell.currentWidget;\n                return widget instanceof MainAreaWidget\n                    ? !widget.contentHeader.isHidden\n                    : false;\n            },\n            execute: async () => {\n                const widget = app.shell.currentWidget;\n                if (widget instanceof MainAreaWidget) {\n                    widget.contentHeader.setHidden(!widget.contentHeader.isHidden);\n                }\n            }\n        });\n        if (palette) {\n            palette.addItem({ command: CommandIDs.toggleHeader, category });\n        }\n    }\n};\n/**\n * Update the browser title based on the workspace and the current\n * active item.\n */\nasync function updateTabTitle(workspace, db, name) {\n    var _a, _b;\n    const data = await db.toJSON();\n    let current = (_b = (_a = data['layout-restorer:data']) === null || _a === void 0 ? void 0 : _a.main) === null || _b === void 0 ? void 0 : _b.current;\n    if (current === undefined) {\n        document.title = `JupyterLab${workspace.startsWith('auto-') ? ` (${workspace})` : ``}`;\n    }\n    else {\n        // First 15 characters of current document name\n        current = current.split(':')[1].slice(0, 15);\n        // Number of restorable items that are either notebooks or editors\n        const count = Object.keys(data).filter(item => item.startsWith('notebook') || item.startsWith('editor')).length;\n        if (workspace.startsWith('auto-')) {\n            document.title = `${current} (${workspace}${count > 1 ? ` : ${count}` : ``}) - ${name}`;\n        }\n        else {\n            document.title = `${current}${count > 1 ? ` (${count})` : ``} - ${name}`;\n        }\n    }\n}\n/**\n * The default state database for storing application state.\n *\n * #### Notes\n * If this extension is loaded with a window resolver, it will automatically add\n * state management commands, URL support for `clone` and `reset`, and workspace\n * auto-saving. Otherwise, it will return a simple in-memory state database.\n */\nconst state = {\n    id: '@jupyterlab/apputils-extension:state',\n    autoStart: true,\n    provides: IStateDB,\n    requires: [JupyterFrontEnd.IPaths, IRouter, ITranslator],\n    optional: [IWindowResolver],\n    activate: (app, paths, router, translator, resolver) => {\n        const trans = translator.load('jupyterlab');\n        if (resolver === null) {\n            return new StateDB();\n        }\n        let resolved = false;\n        const { commands, name, serviceManager } = app;\n        const { workspaces } = serviceManager;\n        const workspace = resolver.name;\n        const transform = new PromiseDelegate();\n        const db = new StateDB({ transform: transform.promise });\n        const save = new Debouncer(async () => {\n            const id = workspace;\n            const metadata = { id };\n            const data = await db.toJSON();\n            await workspaces.save(id, { data, metadata });\n        });\n        // Any time the local state database changes, save the workspace.\n        db.changed.connect(() => void save.invoke(), db);\n        db.changed.connect(() => updateTabTitle(workspace, db, name));\n        commands.addCommand(CommandIDs.loadState, {\n            execute: async (args) => {\n                // Since the command can be executed an arbitrary number of times, make\n                // sure it is safe to call multiple times.\n                if (resolved) {\n                    return;\n                }\n                const { hash, path, search } = args;\n                const { urls } = paths;\n                const query = URLExt.queryStringToObject(search || '');\n                const clone = typeof query['clone'] === 'string'\n                    ? query['clone'] === ''\n                        ? URLExt.join(urls.base, urls.app)\n                        : URLExt.join(urls.base, urls.app, 'workspaces', query['clone'])\n                    : null;\n                const source = clone || workspace || null;\n                if (source === null) {\n                    console.error(`${CommandIDs.loadState} cannot load null workspace.`);\n                    return;\n                }\n                try {\n                    const saved = await workspaces.fetch(source);\n                    // If this command is called after a reset, the state database\n                    // will already be resolved.\n                    if (!resolved) {\n                        resolved = true;\n                        transform.resolve({ type: 'overwrite', contents: saved.data });\n                    }\n                }\n                catch ({ message }) {\n                    console.warn(`Fetching workspace \"${workspace}\" failed.`, message);\n                    // If the workspace does not exist, cancel the data transformation\n                    // and save a workspace with the current user state data.\n                    if (!resolved) {\n                        resolved = true;\n                        transform.resolve({ type: 'cancel', contents: null });\n                    }\n                }\n                if (source === clone) {\n                    // Maintain the query string parameters but remove `clone`.\n                    delete query['clone'];\n                    const url = path + URLExt.objectToQueryString(query) + hash;\n                    const cloned = save.invoke().then(() => router.stop);\n                    // After the state has been cloned, navigate to the URL.\n                    void cloned.then(() => {\n                        router.navigate(url);\n                    });\n                    return cloned;\n                }\n                // After the state database has finished loading, save it.\n                await save.invoke();\n            }\n        });\n        commands.addCommand(CommandIDs.reset, {\n            label: trans.__('Reset Application State'),\n            execute: async ({ reload }) => {\n                await db.clear();\n                await save.invoke();\n                if (reload) {\n                    router.reload();\n                }\n            }\n        });\n        commands.addCommand(CommandIDs.resetOnLoad, {\n            execute: (args) => {\n                const { hash, path, search } = args;\n                const query = URLExt.queryStringToObject(search || '');\n                const reset = 'reset' in query;\n                const clone = 'clone' in query;\n                if (!reset) {\n                    return;\n                }\n                // If the state database has already been resolved, resetting is\n                // impossible without reloading.\n                if (resolved) {\n                    return router.reload();\n                }\n                // Empty the state database.\n                resolved = true;\n                transform.resolve({ type: 'clear', contents: null });\n                // Maintain the query string parameters but remove `reset`.\n                delete query['reset'];\n                const url = path + URLExt.objectToQueryString(query) + hash;\n                const cleared = db.clear().then(() => save.invoke());\n                // After the state has been reset, navigate to the URL.\n                if (clone) {\n                    void cleared.then(() => {\n                        router.navigate(url, { hard: true });\n                    });\n                }\n                else {\n                    void cleared.then(() => {\n                        router.navigate(url);\n                    });\n                }\n                return cleared;\n            }\n        });\n        router.register({\n            command: CommandIDs.loadState,\n            pattern: /.?/,\n            rank: 30 // High priority: 30:100.\n        });\n        router.register({\n            command: CommandIDs.resetOnLoad,\n            pattern: /(\\?reset|\\&reset)($|&)/,\n            rank: 20 // High priority: 20:100.\n        });\n        return db;\n    }\n};\n/**\n * The default session context dialogs extension.\n */\nconst sessionDialogs = {\n    id: '@jupyterlab/apputils-extension:sessionDialogs',\n    provides: ISessionContextDialogs,\n    autoStart: true,\n    activate: () => {\n        return sessionContextDialogs;\n    }\n};\n/**\n * Utility commands\n */\nconst utilityCommands = {\n    id: '@jupyterlab/apputils-extension:utilityCommands',\n    requires: [ITranslator],\n    autoStart: true,\n    activate: (app, translator) => {\n        const trans = translator.load('jupyterlab');\n        const { commands } = app;\n        commands.addCommand(CommandIDs.runFirstEnabled, {\n            label: trans.__('Run First Enabled Command'),\n            execute: args => {\n                const commands = args.commands;\n                const commandArgs = args.args;\n                const argList = Array.isArray(args);\n                for (let i = 0; i < commands.length; i++) {\n                    const cmd = commands[i];\n                    const arg = argList ? commandArgs[i] : commandArgs;\n                    if (app.commands.isEnabled(cmd, arg)) {\n                        return app.commands.execute(cmd, arg);\n                    }\n                }\n            }\n        });\n        commands.addCommand(CommandIDs.runAllEnabled, {\n            label: trans.__('Run All Enabled Commands Passed as Args'),\n            execute: async (args) => {\n                const commands = args.commands;\n                const commandArgs = args.args;\n                const argList = Array.isArray(args);\n                const errorIfNotEnabled = args.errorIfNotEnabled;\n                for (let i = 0; i < commands.length; i++) {\n                    const cmd = commands[i];\n                    const arg = argList ? commandArgs[i] : commandArgs;\n                    if (app.commands.isEnabled(cmd, arg)) {\n                        await app.commands.execute(cmd, arg);\n                    }\n                    else {\n                        if (errorIfNotEnabled) {\n                            console.error(`${cmd} is not enabled.`);\n                        }\n                    }\n                }\n            }\n        });\n    }\n};\n/**\n * The default HTML sanitizer.\n */\nconst sanitizer = {\n    id: '@jupyter/apputils-extension:sanitizer',\n    autoStart: true,\n    provides: ISanitizer,\n    activate: () => {\n        return defaultSanitizer;\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    palette,\n    paletteRestorer,\n    print,\n    resolver,\n    sanitizer,\n    settingsPlugin,\n    state,\n    splash,\n    sessionDialogs,\n    themesPlugin,\n    themesPaletteMenuPlugin,\n    toggleHeader,\n    utilityCommands,\n    workspacesPlugin\n];\nexport default plugins;\n//# sourceMappingURL=index.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { ModalCommandPalette } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { CommandPaletteSvg, paletteIcon } from '@jupyterlab/ui-components';\nimport { find } from '@lumino/algorithm';\nimport { CommandRegistry } from '@lumino/commands';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { CommandPalette } from '@lumino/widgets';\n/**\n * The command IDs used by the apputils extension.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.activate = 'apputils:activate-command-palette';\n})(CommandIDs || (CommandIDs = {}));\nconst PALETTE_PLUGIN_ID = '@jupyterlab/apputils-extension:palette';\n/**\n * A thin wrapper around the `CommandPalette` class to conform with the\n * JupyterLab interface for the application-wide command palette.\n */\nexport class Palette {\n    /**\n     * Create a palette instance.\n     */\n    constructor(palette, translator) {\n        this.translator = translator || nullTranslator;\n        const trans = this.translator.load('jupyterlab');\n        this._palette = palette;\n        this._palette.title.label = '';\n        this._palette.title.caption = trans.__('Command Palette');\n    }\n    /**\n     * The placeholder text of the command palette's search input.\n     */\n    set placeholder(placeholder) {\n        this._palette.inputNode.placeholder = placeholder;\n    }\n    get placeholder() {\n        return this._palette.inputNode.placeholder;\n    }\n    /**\n     * Activate the command palette for user input.\n     */\n    activate() {\n        this._palette.activate();\n    }\n    /**\n     * Add a command item to the command palette.\n     *\n     * @param options - The options for creating the command item.\n     *\n     * @returns A disposable that will remove the item from the palette.\n     */\n    addItem(options) {\n        const item = this._palette.addItem(options);\n        return new DisposableDelegate(() => {\n            this._palette.removeItem(item);\n        });\n    }\n}\n/**\n * A namespace for `Palette` statics.\n */\n(function (Palette) {\n    /**\n     * Activate the command palette.\n     */\n    function activate(app, translator, settingRegistry) {\n        const { commands, shell } = app;\n        const trans = translator.load('jupyterlab');\n        const palette = Private.createPalette(app, translator);\n        const modalPalette = new ModalCommandPalette({ commandPalette: palette });\n        let modal = false;\n        palette.node.setAttribute('role', 'region');\n        palette.node.setAttribute('aria-label', trans.__('Command Palette Section'));\n        shell.add(palette, 'left', { rank: 300 });\n        if (settingRegistry) {\n            const loadSettings = settingRegistry.load(PALETTE_PLUGIN_ID);\n            const updateSettings = (settings) => {\n                const newModal = settings.get('modal').composite;\n                if (modal && !newModal) {\n                    palette.parent = null;\n                    modalPalette.detach();\n                    shell.add(palette, 'left', { rank: 300 });\n                }\n                else if (!modal && newModal) {\n                    palette.parent = null;\n                    modalPalette.palette = palette;\n                    palette.show();\n                    modalPalette.attach();\n                }\n                modal = newModal;\n            };\n            Promise.all([loadSettings, app.restored])\n                .then(([settings]) => {\n                updateSettings(settings);\n                settings.changed.connect(settings => {\n                    updateSettings(settings);\n                });\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n        // Show the current palette shortcut in its title.\n        const updatePaletteTitle = () => {\n            const binding = find(app.commands.keyBindings, b => b.command === CommandIDs.activate);\n            if (binding) {\n                const ks = CommandRegistry.formatKeystroke(binding.keys.join(' '));\n                palette.title.caption = trans.__('Commands (%1)', ks);\n            }\n            else {\n                palette.title.caption = trans.__('Commands');\n            }\n        };\n        updatePaletteTitle();\n        app.commands.keyBindingChanged.connect(() => {\n            updatePaletteTitle();\n        });\n        commands.addCommand(CommandIDs.activate, {\n            execute: () => {\n                if (modal) {\n                    modalPalette.activate();\n                }\n                else {\n                    shell.activateById(palette.id);\n                }\n            },\n            label: trans.__('Activate Command Palette')\n        });\n        palette.inputNode.placeholder = trans.__('SEARCH');\n        return new Palette(palette, translator);\n    }\n    Palette.activate = activate;\n    /**\n     * Restore the command palette.\n     */\n    function restore(app, restorer, translator) {\n        const palette = Private.createPalette(app, translator);\n        // Let the application restorer track the command palette for restoration of\n        // application state (e.g. setting the command palette as the current side bar\n        // widget).\n        restorer.add(palette, 'command-palette');\n    }\n    Palette.restore = restore;\n})(Palette || (Palette = {}));\n/**\n * The namespace for module private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The private command palette instance.\n     */\n    let palette;\n    /**\n     * Create the application-wide command palette.\n     */\n    function createPalette(app, translator) {\n        if (!palette) {\n            // use a renderer tweaked to use inline svg icons\n            palette = new CommandPalette({\n                commands: app.commands,\n                renderer: CommandPaletteSvg.defaultRenderer\n            });\n            palette.id = 'command-palette';\n            palette.title.icon = paletteIcon;\n            const trans = translator.load('jupyterlab');\n            palette.title.label = trans.__('Commands');\n        }\n        return palette;\n    }\n    Private.createPalette = createPalette;\n})(Private || (Private = {}));\n//# sourceMappingURL=palette.js.map","import { PageConfig } from '@jupyterlab/coreutils';\nimport { DataConnector } from '@jupyterlab/statedb';\nimport { Throttler } from '@lumino/polling';\n/**\n * A data connector for fetching settings.\n *\n * #### Notes\n * This connector adds a query parameter to the base services setting manager.\n */\nexport class SettingConnector extends DataConnector {\n    constructor(connector) {\n        super();\n        this._throttlers = Object.create(null);\n        this._connector = connector;\n    }\n    /**\n     * Fetch settings for a plugin.\n     * @param id - The plugin ID\n     *\n     * #### Notes\n     * The REST API requests are throttled at one request per plugin per 100ms.\n     */\n    fetch(id) {\n        const throttlers = this._throttlers;\n        if (!(id in throttlers)) {\n            throttlers[id] = new Throttler(() => this._connector.fetch(id), 100);\n        }\n        return throttlers[id].invoke();\n    }\n    async list(query = 'all') {\n        const { isDeferred, isDisabled } = PageConfig.Extension;\n        const { ids, values } = await this._connector.list();\n        if (query === 'all') {\n            return { ids, values };\n        }\n        return {\n            ids: ids.filter(id => !isDeferred(id) && !isDisabled(id)),\n            values: values.filter(({ id }) => !isDeferred(id) && !isDisabled(id))\n        };\n    }\n    async save(id, raw) {\n        await this._connector.save(id, raw);\n    }\n}\n//# sourceMappingURL=settingconnector.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { ISettingRegistry, SettingRegistry } from '@jupyterlab/settingregistry';\nimport { SettingConnector } from './settingconnector';\n/**\n * The default setting registry provider.\n */\nexport const settingsPlugin = {\n    id: '@jupyterlab/apputils-extension:settings',\n    activate: async (app) => {\n        const { isDisabled } = PageConfig.Extension;\n        const connector = new SettingConnector(app.serviceManager.settings);\n        const registry = new SettingRegistry({\n            connector,\n            plugins: (await connector.list('active')).values\n        });\n        // If there are plugins that have schemas that are not in the setting\n        // registry after the application has restored, try to load them manually\n        // because otherwise, its settings will never become available in the\n        // setting registry.\n        void app.restored.then(async () => {\n            const plugins = await connector.list('all');\n            plugins.ids.forEach(async (id, index) => {\n                if (isDisabled(id) || id in registry.plugins) {\n                    return;\n                }\n                try {\n                    await registry.load(id);\n                }\n                catch (error) {\n                    console.warn(`Settings failed to load for (${id})`, error);\n                    if (plugins.values[index].schema['jupyter.lab.transform']) {\n                        console.warn(`This may happen if {autoStart: false} in (${id}) ` +\n                            `or if it is one of the deferredExtensions in page config.`);\n                    }\n                }\n            });\n        });\n        return registry;\n    },\n    autoStart: true,\n    provides: ISettingRegistry\n};\n//# sourceMappingURL=settingsplugin.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JupyterFrontEnd } from '@jupyterlab/application';\nimport { ICommandPalette, ISplashScreen, IThemeManager, ThemeManager } from '@jupyterlab/apputils';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.changeTheme = 'apputils:change-theme';\n    CommandIDs.themeScrollbars = 'apputils:theme-scrollbars';\n    CommandIDs.changeFont = 'apputils:change-font';\n    CommandIDs.incrFontSize = 'apputils:incr-font-size';\n    CommandIDs.decrFontSize = 'apputils:decr-font-size';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The default theme manager provider.\n */\nexport const themesPlugin = {\n    id: '@jupyterlab/apputils-extension:themes',\n    requires: [ISettingRegistry, JupyterFrontEnd.IPaths, ITranslator],\n    optional: [ISplashScreen],\n    activate: (app, settings, paths, translator, splash) => {\n        const trans = translator.load('jupyterlab');\n        const host = app.shell;\n        const commands = app.commands;\n        const url = URLExt.join(PageConfig.getBaseUrl(), paths.urls.themes);\n        const key = themesPlugin.id;\n        const manager = new ThemeManager({\n            key,\n            host,\n            settings,\n            splash: splash !== null && splash !== void 0 ? splash : undefined,\n            url\n        });\n        // Keep a synchronously set reference to the current theme,\n        // since the asynchronous setting of the theme in `changeTheme`\n        // can lead to an incorrect toggle on the currently used theme.\n        let currentTheme;\n        manager.themeChanged.connect((sender, args) => {\n            // Set data attributes on the application shell for the current theme.\n            currentTheme = args.newValue;\n            document.body.dataset.jpThemeLight = String(manager.isLight(currentTheme));\n            document.body.dataset.jpThemeName = currentTheme;\n            if (document.body.dataset.jpThemeScrollbars !==\n                String(manager.themeScrollbars(currentTheme))) {\n                document.body.dataset.jpThemeScrollbars = String(manager.themeScrollbars(currentTheme));\n            }\n            commands.notifyCommandChanged(CommandIDs.changeTheme);\n        });\n        commands.addCommand(CommandIDs.changeTheme, {\n            label: args => {\n                const theme = args['theme'];\n                const displayName = manager.getDisplayName(theme);\n                return args['isPalette']\n                    ? trans.__('Use Theme: %1', displayName)\n                    : displayName;\n            },\n            isToggled: args => args['theme'] === currentTheme,\n            execute: args => {\n                const theme = args['theme'];\n                if (theme === manager.theme) {\n                    return;\n                }\n                return manager.setTheme(theme);\n            }\n        });\n        commands.addCommand(CommandIDs.themeScrollbars, {\n            label: trans.__('Theme Scrollbars'),\n            isToggled: () => manager.isToggledThemeScrollbars(),\n            execute: () => manager.toggleThemeScrollbars()\n        });\n        commands.addCommand(CommandIDs.changeFont, {\n            label: args => args['enabled'] ? `${args['font']}` : trans.__('waiting for fonts'),\n            isEnabled: args => args['enabled'],\n            isToggled: args => manager.getCSS(args['key']) === args['font'],\n            execute: args => manager.setCSSOverride(args['key'], args['font'])\n        });\n        commands.addCommand(CommandIDs.incrFontSize, {\n            label: args => {\n                switch (args.key) {\n                    case 'code-font-size':\n                        return trans.__('Increase Code Font Size');\n                    case 'content-font-size1':\n                        return trans.__('Increase Content Font Size');\n                    case 'ui-font-size1':\n                        return trans.__('Increase UI Font Size');\n                    default:\n                        return trans.__('Increase Font Size');\n                }\n            },\n            execute: args => manager.incrFontSize(args['key'])\n        });\n        commands.addCommand(CommandIDs.decrFontSize, {\n            label: args => {\n                switch (args.key) {\n                    case 'code-font-size':\n                        return trans.__('Decrease Code Font Size');\n                    case 'content-font-size1':\n                        return trans.__('Decrease Content Font Size');\n                    case 'ui-font-size1':\n                        return trans.__('Decrease UI Font Size');\n                    default:\n                        return trans.__('Decrease Font Size');\n                }\n            },\n            execute: args => manager.decrFontSize(args['key'])\n        });\n        return manager;\n    },\n    autoStart: true,\n    provides: IThemeManager\n};\n/**\n * The default theme manager's UI command palette and main menu functionality.\n *\n * #### Notes\n * This plugin loads separately from the theme manager plugin in order to\n * prevent blocking of the theme manager while it waits for the command palette\n * and main menu to become available.\n */\nexport const themesPaletteMenuPlugin = {\n    id: '@jupyterlab/apputils-extension:themes-palette-menu',\n    requires: [IThemeManager, ITranslator],\n    optional: [ICommandPalette, IMainMenu],\n    activate: (app, manager, translator, palette, mainMenu) => {\n        const trans = translator.load('jupyterlab');\n        // If we have a main menu, add the theme manager to the settings menu.\n        if (mainMenu) {\n            void app.restored.then(() => {\n                var _a;\n                const isPalette = false;\n                const themeMenu = (_a = mainMenu.settingsMenu.items.find(item => {\n                    var _a;\n                    return item.type === 'submenu' &&\n                        ((_a = item.submenu) === null || _a === void 0 ? void 0 : _a.id) === 'jp-mainmenu-settings-apputilstheme';\n                })) === null || _a === void 0 ? void 0 : _a.submenu;\n                // choose a theme\n                if (themeMenu) {\n                    manager.themes.forEach((theme, index) => {\n                        themeMenu.insertItem(index, {\n                            command: CommandIDs.changeTheme,\n                            args: { isPalette, theme }\n                        });\n                    });\n                }\n            });\n        }\n        // If we have a command palette, add theme switching options to it.\n        if (palette) {\n            void app.restored.then(() => {\n                const category = trans.__('Theme');\n                const command = CommandIDs.changeTheme;\n                const isPalette = true;\n                // choose a theme\n                manager.themes.forEach(theme => {\n                    palette.addItem({ command, args: { isPalette, theme }, category });\n                });\n                // toggle scrollbar theming\n                palette.addItem({ command: CommandIDs.themeScrollbars, category });\n                // increase/decrease code font size\n                palette.addItem({\n                    command: CommandIDs.incrFontSize,\n                    args: {\n                        key: 'code-font-size'\n                    },\n                    category\n                });\n                palette.addItem({\n                    command: CommandIDs.decrFontSize,\n                    args: {\n                        key: 'code-font-size'\n                    },\n                    category\n                });\n                // increase/decrease content font size\n                palette.addItem({\n                    command: CommandIDs.incrFontSize,\n                    args: {\n                        key: 'content-font-size1'\n                    },\n                    category\n                });\n                palette.addItem({\n                    command: CommandIDs.decrFontSize,\n                    args: {\n                        key: 'content-font-size1'\n                    },\n                    category\n                });\n                // increase/decrease ui font size\n                palette.addItem({\n                    command: CommandIDs.incrFontSize,\n                    args: {\n                        key: 'ui-font-size1'\n                    },\n                    category\n                });\n                palette.addItem({\n                    command: CommandIDs.decrFontSize,\n                    args: {\n                        key: 'ui-font-size1'\n                    },\n                    category\n                });\n            });\n        }\n    },\n    autoStart: true\n};\n//# sourceMappingURL=themesplugins.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { IRouter, JupyterFrontEnd } from '@jupyterlab/application';\nimport { Dialog, IWindowResolver, showDialog } from '@jupyterlab/apputils';\nimport { URLExt } from '@jupyterlab/coreutils';\nimport { ABCWidgetFactory, DocumentWidget } from '@jupyterlab/docregistry';\nimport { IFileBrowserFactory } from '@jupyterlab/filebrowser';\nimport { IStateDB } from '@jupyterlab/statedb';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\nimport { Widget } from '@lumino/widgets';\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.saveWorkspace = 'workspace-ui:save';\n    CommandIDs.saveWorkspaceAs = 'workspace-ui:save-as';\n})(CommandIDs || (CommandIDs = {}));\nconst WORKSPACE_NAME = 'jupyterlab-workspace';\nconst WORKSPACE_EXT = '.' + WORKSPACE_NAME;\nconst LAST_SAVE_ID = 'workspace-ui:lastSave';\nconst ICON_NAME = 'jp-JupyterIcon';\n/**\n * The workspace MIME renderer and save plugin.\n */\nexport const workspacesPlugin = {\n    id: '@jupyterlab/apputils-extension:workspaces',\n    autoStart: true,\n    requires: [\n        IFileBrowserFactory,\n        IWindowResolver,\n        IStateDB,\n        ITranslator,\n        JupyterFrontEnd.IPaths\n    ],\n    optional: [IRouter],\n    activate: (app, fbf, resolver, state, translator, paths, router) => {\n        // The workspace factory creates dummy widgets to load a new workspace.\n        const factory = new Private.WorkspaceFactory({\n            workspaces: app.serviceManager.workspaces,\n            router,\n            state,\n            translator,\n            paths\n        });\n        const trans = translator.load('jupyterlab');\n        app.docRegistry.addFileType({\n            name: WORKSPACE_NAME,\n            contentType: 'file',\n            fileFormat: 'text',\n            displayName: trans.__('JupyterLab workspace File'),\n            extensions: [WORKSPACE_EXT],\n            mimeTypes: ['text/json'],\n            iconClass: ICON_NAME\n        });\n        app.docRegistry.addWidgetFactory(factory);\n        app.commands.addCommand(CommandIDs.saveWorkspaceAs, {\n            label: trans.__('Save Current Workspace As…'),\n            execute: async () => {\n                const data = app.serviceManager.workspaces.fetch(resolver.name);\n                await Private.saveAs(fbf.defaultBrowser, app.serviceManager.contents, data, state, translator);\n            }\n        });\n        app.commands.addCommand(CommandIDs.saveWorkspace, {\n            label: trans.__('Save Current Workspace'),\n            execute: async () => {\n                const { contents } = app.serviceManager;\n                const data = app.serviceManager.workspaces.fetch(resolver.name);\n                const lastSave = (await state.fetch(LAST_SAVE_ID));\n                if (lastSave === undefined) {\n                    await Private.saveAs(fbf.defaultBrowser, contents, data, state, translator);\n                }\n                else {\n                    await Private.save(lastSave, contents, data, state);\n                }\n            }\n        });\n    }\n};\nvar Private;\n(function (Private) {\n    /**\n     * Save workspace to a user provided location\n     */\n    async function save(userPath, contents, data, state) {\n        let name = userPath.split('/').pop();\n        // Add extension if not provided or remove extension from name if it was.\n        if (name !== undefined && name.includes('.')) {\n            name = name.split('.')[0];\n        }\n        else {\n            userPath = userPath + WORKSPACE_EXT;\n        }\n        // Save last save location, for save button to work\n        await state.save(LAST_SAVE_ID, userPath);\n        const resolvedData = await data;\n        resolvedData.metadata.id = `${name}`;\n        await contents.save(userPath, {\n            type: 'file',\n            format: 'text',\n            content: JSON.stringify(resolvedData)\n        });\n    }\n    Private.save = save;\n    /**\n     * Ask user for location, and save workspace.\n     * Default location is the current directory in the file browser\n     */\n    async function saveAs(browser, contents, data, state, translator) {\n        var _a;\n        translator = translator || nullTranslator;\n        const lastSave = await state.fetch(LAST_SAVE_ID);\n        let defaultName;\n        if (lastSave === undefined) {\n            defaultName = 'new-workspace';\n        }\n        else {\n            defaultName = (_a = lastSave.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0];\n        }\n        const defaultPath = browser.model.path + '/' + defaultName + WORKSPACE_EXT;\n        const userPath = await getSavePath(defaultPath, translator);\n        if (userPath) {\n            await save(userPath, contents, data, state);\n        }\n    }\n    Private.saveAs = saveAs;\n    /**\n     * This widget factory is used to handle double click on workspace\n     */\n    class WorkspaceFactory extends ABCWidgetFactory {\n        /**\n         * Construct a widget factory that uploads a workspace and navigates to it.\n         *\n         * @param options - The instantiation options for a `WorkspaceFactory`.\n         */\n        constructor(options) {\n            const trans = (options.translator || nullTranslator).load('jupyterlab');\n            super({\n                name: trans.__('Workspace loader'),\n                fileTypes: [WORKSPACE_NAME],\n                defaultFor: [WORKSPACE_NAME],\n                readOnly: true\n            });\n            this._application = options.paths.urls.app;\n            this._router = options.router;\n            this._state = options.state;\n            this._workspaces = options.workspaces;\n        }\n        /**\n         * Loads the workspace into load, and jump to it\n         * @param context This is used queried to query the workspace content\n         */\n        createNewWidget(context) {\n            // Save a file's contents as a workspace and navigate to that workspace.\n            void context.ready.then(async () => {\n                const file = context.model;\n                const workspace = file.toJSON();\n                const path = context.path;\n                const id = workspace.metadata.id;\n                // Save the file contents as a workspace.\n                await this._workspaces.save(id, workspace);\n                // Save last save location for the save command.\n                await this._state.save(LAST_SAVE_ID, path);\n                // Navigate to new workspace.\n                const url = URLExt.join(this._application, 'workspaces', id);\n                if (this._router) {\n                    this._router.navigate(url, { hard: true });\n                }\n                else {\n                    document.location.href = url;\n                }\n            });\n            return dummyWidget(context);\n        }\n    }\n    Private.WorkspaceFactory = WorkspaceFactory;\n    /**\n     * Returns a dummy widget with disposed content that doesn't render in the UI.\n     *\n     * @param context - The file context.\n     */\n    function dummyWidget(context) {\n        const widget = new DocumentWidget({ content: new Widget(), context });\n        widget.content.dispose();\n        return widget;\n    }\n    /**\n     * Ask user for a path to save to.\n     * @param defaultPath Path already present when the dialog is shown\n     */\n    async function getSavePath(defaultPath, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const saveBtn = Dialog.okButton({ label: trans.__('Save') });\n        const result = await showDialog({\n            title: trans.__('Save Current Workspace As…'),\n            body: new SaveWidget(defaultPath),\n            buttons: [Dialog.cancelButton({ label: trans.__('Cancel') }), saveBtn]\n        });\n        if (result.button.label === trans.__('Save')) {\n            return result.value;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * A widget that gets a file path from a user.\n     */\n    class SaveWidget extends Widget {\n        /**\n         * Gets a modal node for getting save location. Will have a default to the current opened directory\n         * @param path Default location\n         */\n        constructor(path) {\n            super({ node: createSaveNode(path) });\n        }\n        /**\n         * Gets the save path entered by the user\n         */\n        getValue() {\n            return this.node.value;\n        }\n    }\n    /**\n     * Create the node for a save widget.\n     */\n    function createSaveNode(path) {\n        const input = document.createElement('input');\n        input.value = path;\n        return input;\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=workspacesplugin.js.map"],"sourceRoot":""}