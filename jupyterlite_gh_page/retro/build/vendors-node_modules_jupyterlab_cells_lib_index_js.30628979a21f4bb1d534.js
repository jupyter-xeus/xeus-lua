(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_cells_lib_index_js"],{

/***/ 19830:
/*!***************************************************************!*\
  !*** ../../node_modules/@jupyterlab/attachments/lib/model.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachmentsModel": () => (/* binding */ AttachmentsModel),
/* harmony export */   "AttachmentsResolver": () => (/* binding */ AttachmentsResolver)
/* harmony export */ });
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/observables */ 86780);
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/rendermime */ 34410);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ 58137);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The default implementation of the IAttachmentsModel.
 */
class AttachmentsModel {
    /**
     * Construct a new observable outputs instance.
     */
    constructor(options = {}) {
        this._map = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__.ObservableMap();
        this._isDisposed = false;
        this._stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        this._modelDB = null;
        this._serialized = null;
        this._changeGuard = false;
        this.contentFactory =
            options.contentFactory || AttachmentsModel.defaultContentFactory;
        if (options.values) {
            for (const key of Object.keys(options.values)) {
                if (options.values[key] !== undefined) {
                    this.set(key, options.values[key]);
                }
            }
        }
        this._map.changed.connect(this._onMapChanged, this);
        // If we are given a IModelDB, keep an up-to-date
        // serialized copy of the AttachmentsModel in it.
        if (options.modelDB) {
            this._modelDB = options.modelDB;
            this._serialized = this._modelDB.createValue('attachments');
            if (this._serialized.get()) {
                this.fromJSON(this._serialized.get());
            }
            else {
                this._serialized.set(this.toJSON());
            }
            this._serialized.changed.connect(this._onSerializedChanged, this);
        }
    }
    /**
     * A signal emitted when the model state changes.
     */
    get stateChanged() {
        return this._stateChanged;
    }
    /**
     * A signal emitted when the model changes.
     */
    get changed() {
        return this._changed;
    }
    /**
     * The keys of the attachments in the model.
     */
    get keys() {
        return this._map.keys();
    }
    /**
     * Get the length of the items in the model.
     */
    get length() {
        return this._map.keys().length;
    }
    /**
     * Test whether the model is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Dispose of the resources used by the model.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._map.dispose();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal.clearData(this);
    }
    /**
     * Whether the specified key is set.
     */
    has(key) {
        return this._map.has(key);
    }
    /**
     * Get an item at the specified key.
     */
    get(key) {
        return this._map.get(key);
    }
    /**
     * Set the value at the specified key.
     */
    set(key, value) {
        // Normalize stream data.
        const item = this._createItem({ value });
        this._map.set(key, item);
    }
    /**
     * Remove the attachment whose name is the specified key
     */
    remove(key) {
        this._map.delete(key);
    }
    /**
     * Clear all of the attachments.
     */
    clear() {
        this._map.values().forEach((item) => {
            item.dispose();
        });
        this._map.clear();
    }
    /**
     * Deserialize the model from JSON.
     *
     * #### Notes
     * This will clear any existing data.
     */
    fromJSON(values) {
        this.clear();
        Object.keys(values).forEach(key => {
            if (values[key] !== undefined) {
                this.set(key, values[key]);
            }
        });
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const ret = {};
        for (const key of this._map.keys()) {
            ret[key] = this._map.get(key).toJSON();
        }
        return ret;
    }
    /**
     * Create an attachment item and hook up its signals.
     */
    _createItem(options) {
        const factory = this.contentFactory;
        const item = factory.createAttachmentModel(options);
        item.changed.connect(this._onGenericChange, this);
        return item;
    }
    /**
     * Handle a change to the list.
     */
    _onMapChanged(sender, args) {
        if (this._serialized && !this._changeGuard) {
            this._changeGuard = true;
            this._serialized.set(this.toJSON());
            this._changeGuard = false;
        }
        this._changed.emit(args);
        this._stateChanged.emit(void 0);
    }
    /**
     * If the serialized version of the outputs have changed due to a remote
     * action, then update the model accordingly.
     */
    _onSerializedChanged(sender, args) {
        if (!this._changeGuard) {
            this._changeGuard = true;
            this.fromJSON(args.newValue);
            this._changeGuard = false;
        }
    }
    /**
     * Handle a change to an item.
     */
    _onGenericChange() {
        this._stateChanged.emit(void 0);
    }
}
/**
 * The namespace for AttachmentsModel class statics.
 */
(function (AttachmentsModel) {
    /**
     * The default implementation of a `IAttachmentsModel.IContentFactory`.
     */
    class ContentFactory {
        /**
         * Create an attachment model.
         */
        createAttachmentModel(options) {
            return new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__.AttachmentModel(options);
        }
    }
    AttachmentsModel.ContentFactory = ContentFactory;
    /**
     * The default attachment model factory.
     */
    AttachmentsModel.defaultContentFactory = new ContentFactory();
})(AttachmentsModel || (AttachmentsModel = {}));
/**
 * A resolver for cell attachments 'attachment:filename'.
 *
 * Will resolve to a data: url.
 */
class AttachmentsResolver {
    /**
     * Create an attachments resolver object.
     */
    constructor(options) {
        this._parent = options.parent || null;
        this._model = options.model;
    }
    /**
     * Resolve a relative url to a correct server path.
     */
    async resolveUrl(url) {
        if (this._parent && !url.startsWith('attachment:')) {
            return this._parent.resolveUrl(url);
        }
        return url;
    }
    /**
     * Get the download url of a given absolute server path.
     *
     * #### Notes
     * The returned URL may include a query parameter.
     */
    async getDownloadUrl(path) {
        if (this._parent && !path.startsWith('attachment:')) {
            return this._parent.getDownloadUrl(path);
        }
        // Return a data URL with the data of the url
        const key = path.slice('attachment:'.length);
        const attachment = this._model.get(key);
        if (attachment === undefined) {
            // Resolve with unprocessed path, to show as broken image
            return path;
        }
        const { data } = attachment;
        const mimeType = Object.keys(data)[0];
        // Only support known safe types:
        if (mimeType === undefined ||
            _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__.imageRendererFactory.mimeTypes.indexOf(mimeType) === -1) {
            throw new Error(`Cannot render unknown image mime type "${mimeType}".`);
        }
        const dataUrl = `data:${mimeType};base64,${data[mimeType]}`;
        return dataUrl;
    }
    /**
     * Whether the URL should be handled by the resolver
     * or not.
     */
    isLocal(url) {
        var _a, _b, _c;
        if (this._parent && !url.startsWith('attachment:')) {
            return (_c = (_b = (_a = this._parent).isLocal) === null || _b === void 0 ? void 0 : _b.call(_a, url)) !== null && _c !== void 0 ? _c : true;
        }
        return true;
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ 34850:
/*!*****************************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/celldragutils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellDragUtils": () => (/* binding */ CellDragUtils)
/* harmony export */ });
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/algorithm */ 79028);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/virtualdom */ 52522);
/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
/**
 * This module contains some utility functions to operate on cells. This
 * could be shared by widgets that contain cells, like the CodeConsole or
 * Notebook widgets.
 */


/**
 * Constants for drag
 */
/**
 * The threshold in pixels to start a drag event.
 */
const DRAG_THRESHOLD = 5;
/**
 * The class name added to drag images.
 */
const DRAG_IMAGE_CLASS = 'jp-dragImage';
/**
 * The class name added to singular drag images
 */
const SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';
/**
 * The class name added to the drag image cell content.
 */
const CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';
/**
 * The class name added to the drag image cell content.
 */
const CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';
/**
 * The class name added to the drag image cell content.
 */
const CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';
var CellDragUtils;
(function (CellDragUtils) {
    /**
     * Find the cell index containing the target html element.
     * This function traces up the DOM hierarchy to find the root cell
     * node. Then find the corresponding child and select it.
     *
     * @param node - the cell node or a child of the cell node.
     * @param cells - an iterable of Cells
     * @param isCellNode - a function that takes in a node and checks if
     * it is a cell node.
     *
     * @returns index of the cell we're looking for. Returns -1 if
     * the cell is not founds
     */
    function findCell(node, cells, isCellNode) {
        let cellIndex = -1;
        while (node && node.parentElement) {
            if (isCellNode(node)) {
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(cells, (cell, index) => {
                    if (cell.node === node) {
                        cellIndex = index;
                        return false;
                    }
                });
                break;
            }
            node = node.parentElement;
        }
        return cellIndex;
    }
    CellDragUtils.findCell = findCell;
    /**
     * Detect which part of the cell triggered the MouseEvent
     *
     * @param cell - The cell which contains the MouseEvent's target
     * @param target - The DOM node which triggered the MouseEvent
     */
    function detectTargetArea(cell, target) {
        let targetArea;
        if (cell) {
            if (cell.editorWidget.node.contains(target)) {
                targetArea = 'input';
            }
            else if (cell.promptNode.contains(target)) {
                targetArea = 'prompt';
            }
            else {
                targetArea = 'cell';
            }
        }
        else {
            targetArea = 'unknown';
        }
        return targetArea;
    }
    CellDragUtils.detectTargetArea = detectTargetArea;
    /**
     * Detect if a drag event should be started. This is down if the
     * mouse is moved beyond a certain distance (DRAG_THRESHOLD).
     *
     * @param prevX - X Coordinate of the mouse pointer during the mousedown event
     * @param prevY - Y Coordinate of the mouse pointer during the mousedown event
     * @param nextX - Current X Coordinate of the mouse pointer
     * @param nextY - Current Y Coordinate of the mouse pointer
     */
    function shouldStartDrag(prevX, prevY, nextX, nextY) {
        const dx = Math.abs(nextX - prevX);
        const dy = Math.abs(nextY - prevY);
        return dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD;
    }
    CellDragUtils.shouldStartDrag = shouldStartDrag;
    /**
     * Create an image for the cell(s) to be dragged
     *
     * @param activeCell - The cell from where the drag event is triggered
     * @param selectedCells - The cells to be dragged
     */
    function createCellDragImage(activeCell, selectedCells) {
        const count = selectedCells.length;
        let promptNumber;
        if (activeCell.model.type === 'code') {
            const executionCount = activeCell.model
                .executionCount;
            promptNumber = ' ';
            if (executionCount) {
                promptNumber = executionCount.toString();
            }
        }
        else {
            promptNumber = '';
        }
        const cellContent = activeCell.model.value.text.split('\n')[0].slice(0, 26);
        if (count > 1) {
            if (promptNumber !== '') {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div({ className: DRAG_IMAGE_CLASS }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));
            }
            else {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div({ className: DRAG_IMAGE_CLASS }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_PROMPT_CLASS }), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));
            }
        }
        else {
            if (promptNumber !== '') {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));
            }
            else {
                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_PROMPT_CLASS }), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_1__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));
            }
        }
    }
    CellDragUtils.createCellDragImage = createCellDragImage;
})(CellDragUtils || (CellDragUtils = {}));
//# sourceMappingURL=celldragutils.js.map

/***/ }),

/***/ 41037:
/*!*************************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/collapser.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Collapser": () => (/* binding */ Collapser),
/* harmony export */   "InputCollapser": () => (/* binding */ InputCollapser),
/* harmony export */   "OutputCollapser": () => (/* binding */ OutputCollapser)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/domutils */ 69656);
/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ 96927);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/



/**
 * The CSS class added to all collapsers.
 */
const COLLAPSER_CLASS = 'jp-Collapser';
/**
 * The CSS class added to the collapser child.
 */
const COLLAPSER_CHILD_CLASS = 'jp-Collapser-child';
/**
 * The CSS class added to input collapsers.
 */
const INPUT_COLLAPSER = 'jp-InputCollapser';
/**
 * The CSS class added to output collapsers.
 */
const OUTPUT_COLLAPSER = 'jp-OutputCollapser';
/**
 * Abstract collapser base class.
 *
 * ### Notes
 * A collapser is a visible div to the left of a cell's
 * input/output that a user can click on to collapse the
 * input/output.
 */
class Collapser extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {
    /**
     * Construct a new collapser.
     */
    constructor() {
        super();
        this.addClass(COLLAPSER_CLASS);
    }
    /**
     * Is the input/output of the parent collapsed.
     */
    get collapsed() {
        return false;
    }
    /**
     * Render the collapser with the virtual DOM.
     */
    render() {
        const childClass = COLLAPSER_CHILD_CLASS;
        return react__WEBPACK_IMPORTED_MODULE_2__.createElement("div", { className: childClass, onClick: e => this.handleClick(e) });
    }
}
/**
 * A collapser subclass to collapse a cell's input area.
 */
class InputCollapser extends Collapser {
    /**
     * Construct a new input collapser.
     */
    constructor() {
        super();
        this.addClass(INPUT_COLLAPSER);
    }
    /**
     * Is the cell's input collapsed?
     */
    get collapsed() {
        var _a;
        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
        if (cell) {
            return cell.inputHidden;
        }
        else {
            return false;
        }
    }
    /**
     * Handle a click event for the user to collapse the cell's input.
     */
    handleClick(e) {
        var _a;
        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
        if (cell) {
            cell.inputHidden = !cell.inputHidden;
        }
        /* We need this until we watch the cell state */
        this.update();
    }
}
/**
 * A collapser subclass to collapse a cell's output area.
 */
class OutputCollapser extends Collapser {
    /**
     * Construct a new output collapser.
     */
    constructor() {
        super();
        this.addClass(OUTPUT_COLLAPSER);
    }
    /**
     * Is the cell's output collapsed?
     */
    get collapsed() {
        var _a;
        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
        if (cell) {
            return cell.outputHidden;
        }
        else {
            return false;
        }
    }
    /**
     * Handle a click event for the user to collapse the cell's output.
     */
    handleClick(e) {
        var _a, _b;
        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
        if (cell) {
            cell.outputHidden = !cell.outputHidden;
            /* Scroll cell into view after output collapse */
            if (cell.outputHidden) {
                let area = (_b = cell.parent) === null || _b === void 0 ? void 0 : _b.node;
                if (area) {
                    _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.scrollIntoViewIfNeeded(area, cell.node);
                }
            }
        }
        /* We need this until we watch the cell state */
        this.update();
    }
}
//# sourceMappingURL=collapser.js.map

/***/ }),

/***/ 87849:
/*!****************************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/headerfooter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellHeader": () => (/* binding */ CellHeader),
/* harmony export */   "CellFooter": () => (/* binding */ CellFooter)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ 77031);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * The CSS class added to the cell header.
 */
const CELL_HEADER_CLASS = 'jp-CellHeader';
/**
 * The CSS class added to the cell footer.
 */
const CELL_FOOTER_CLASS = 'jp-CellFooter';
/**
 * Default implementation of a cell header.
 */
class CellHeader extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {
    /**
     * Construct a new cell header.
     */
    constructor() {
        super();
        this.addClass(CELL_HEADER_CLASS);
    }
}
/**
 * Default implementation of a cell footer.
 */
class CellFooter extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {
    /**
     * Construct a new cell footer.
     */
    constructor() {
        super();
        this.addClass(CELL_FOOTER_CLASS);
    }
}
//# sourceMappingURL=headerfooter.js.map

/***/ }),

/***/ 62600:
/*!*********************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellDragUtils": () => (/* reexport safe */ _celldragutils__WEBPACK_IMPORTED_MODULE_0__.CellDragUtils),
/* harmony export */   "Collapser": () => (/* reexport safe */ _collapser__WEBPACK_IMPORTED_MODULE_1__.Collapser),
/* harmony export */   "InputCollapser": () => (/* reexport safe */ _collapser__WEBPACK_IMPORTED_MODULE_1__.InputCollapser),
/* harmony export */   "OutputCollapser": () => (/* reexport safe */ _collapser__WEBPACK_IMPORTED_MODULE_1__.OutputCollapser),
/* harmony export */   "CellFooter": () => (/* reexport safe */ _headerfooter__WEBPACK_IMPORTED_MODULE_2__.CellFooter),
/* harmony export */   "CellHeader": () => (/* reexport safe */ _headerfooter__WEBPACK_IMPORTED_MODULE_2__.CellHeader),
/* harmony export */   "InputArea": () => (/* reexport safe */ _inputarea__WEBPACK_IMPORTED_MODULE_3__.InputArea),
/* harmony export */   "InputPrompt": () => (/* reexport safe */ _inputarea__WEBPACK_IMPORTED_MODULE_3__.InputPrompt),
/* harmony export */   "AttachmentsCellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.AttachmentsCellModel),
/* harmony export */   "CellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.CellModel),
/* harmony export */   "CodeCellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.CodeCellModel),
/* harmony export */   "MarkdownCellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.MarkdownCellModel),
/* harmony export */   "RawCellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.RawCellModel),
/* harmony export */   "isCodeCellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.isCodeCellModel),
/* harmony export */   "isMarkdownCellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.isMarkdownCellModel),
/* harmony export */   "isRawCellModel": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.isRawCellModel),
/* harmony export */   "InputPlaceholder": () => (/* reexport safe */ _placeholder__WEBPACK_IMPORTED_MODULE_5__.InputPlaceholder),
/* harmony export */   "OutputPlaceholder": () => (/* reexport safe */ _placeholder__WEBPACK_IMPORTED_MODULE_5__.OutputPlaceholder),
/* harmony export */   "Placeholder": () => (/* reexport safe */ _placeholder__WEBPACK_IMPORTED_MODULE_5__.Placeholder),
/* harmony export */   "AttachmentsCell": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_6__.AttachmentsCell),
/* harmony export */   "Cell": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_6__.Cell),
/* harmony export */   "CodeCell": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_6__.CodeCell),
/* harmony export */   "MARKDOWN_HEADING_COLLAPSED": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_6__.MARKDOWN_HEADING_COLLAPSED),
/* harmony export */   "MarkdownCell": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_6__.MarkdownCell),
/* harmony export */   "RawCell": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_6__.RawCell)
/* harmony export */ });
/* harmony import */ var _celldragutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./celldragutils */ 34850);
/* harmony import */ var _collapser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collapser */ 41037);
/* harmony import */ var _headerfooter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./headerfooter */ 87849);
/* harmony import */ var _inputarea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inputarea */ 3348);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model */ 734);
/* harmony import */ var _placeholder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./placeholder */ 65026);
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./widget */ 62124);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
/**
 * @packageDocumentation
 * @module cells
 */







//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3348:
/*!*************************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/inputarea.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputArea": () => (/* binding */ InputArea),
/* harmony export */   "InputPrompt": () => (/* binding */ InputPrompt)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ 77031);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/codeeditor */ 6256);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/codemirror */ 63804);
/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/




/**
 * The class name added to input area widgets.
 */
const INPUT_AREA_CLASS = 'jp-InputArea';
/**
 * The class name added to the prompt area of cell.
 */
const INPUT_AREA_PROMPT_CLASS = 'jp-InputArea-prompt';
/**
 * The class name added to OutputPrompt.
 */
const INPUT_PROMPT_CLASS = 'jp-InputPrompt';
/**
 * The class name added to the editor area of the cell.
 */
const INPUT_AREA_EDITOR_CLASS = 'jp-InputArea-editor';
/** ****************************************************************************
 * InputArea
 ******************************************************************************/
/**
 * An input area widget, which hosts a prompt and an editor widget.
 */
class InputArea extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {
    /**
     * Construct an input area widget.
     */
    constructor(options) {
        super();
        this.addClass(INPUT_AREA_CLASS);
        const model = (this.model = options.model);
        const contentFactory = (this.contentFactory =
            options.contentFactory || InputArea.defaultContentFactory);
        // Prompt
        const prompt = (this._prompt = contentFactory.createInputPrompt());
        prompt.addClass(INPUT_AREA_PROMPT_CLASS);
        // Editor
        const editorOptions = {
            model,
            factory: contentFactory.editorFactory,
            updateOnShow: options.updateOnShow
        };
        const editor = (this._editor = new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditorWrapper(editorOptions));
        editor.addClass(INPUT_AREA_EDITOR_CLASS);
        const layout = (this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.PanelLayout());
        layout.addWidget(prompt);
        if (!options.placeholder) {
            layout.addWidget(editor);
        }
    }
    /**
     * Get the CodeEditorWrapper used by the cell.
     */
    get editorWidget() {
        return this._editor;
    }
    /**
     * Get the CodeEditor used by the cell.
     */
    get editor() {
        return this._editor.editor;
    }
    /**
     * Get the prompt node used by the cell.
     */
    get promptNode() {
        return this._prompt.node;
    }
    /**
     * Render an input instead of the text editor.
     */
    renderInput(widget) {
        const layout = this.layout;
        if (this._rendered) {
            this._rendered.parent = null;
        }
        this._editor.hide();
        this._rendered = widget;
        layout.addWidget(widget);
    }
    /**
     * Show the text editor.
     */
    showEditor() {
        if (this._rendered) {
            this._rendered.parent = null;
        }
        this._editor.show();
    }
    /**
     * Set the prompt of the input area.
     */
    setPrompt(value) {
        this._prompt.executionCount = value;
    }
    /**
     * Dispose of the resources held by the widget.
     */
    dispose() {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._prompt = null;
        this._editor = null;
        this._rendered = null;
        super.dispose();
    }
}
/**
 * A namespace for `InputArea` statics.
 */
(function (InputArea) {
    /**
     * Default implementation of `IContentFactory`.
     *
     * This defaults to using an `editorFactory` based on CodeMirror.
     */
    class ContentFactory {
        /**
         * Construct a `ContentFactory`.
         */
        constructor(options = {}) {
            this._editor = options.editorFactory || InputArea.defaultEditorFactory;
        }
        /**
         * Return the `CodeEditor.Factory` being used.
         */
        get editorFactory() {
            return this._editor;
        }
        /**
         * Create an input prompt.
         */
        createInputPrompt() {
            return new InputPrompt();
        }
    }
    InputArea.ContentFactory = ContentFactory;
    /**
     * A function to create the default CodeMirror editor factory.
     */
    function _createDefaultEditorFactory() {
        const editorServices = new _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.CodeMirrorEditorFactory();
        return editorServices.newInlineEditor;
    }
    /**
     * The default editor factory singleton based on CodeMirror.
     */
    InputArea.defaultEditorFactory = _createDefaultEditorFactory();
    /**
     * The default `ContentFactory` instance.
     */
    InputArea.defaultContentFactory = new ContentFactory({});
})(InputArea || (InputArea = {}));
/**
 * The default input prompt implementation.
 */
class InputPrompt extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {
    /*
     * Create an output prompt widget.
     */
    constructor() {
        super();
        this._executionCount = null;
        this.addClass(INPUT_PROMPT_CLASS);
    }
    /**
     * The execution count for the prompt.
     */
    get executionCount() {
        return this._executionCount;
    }
    set executionCount(value) {
        this._executionCount = value;
        if (value === null) {
            this.node.textContent = ' ';
        }
        else {
            this.node.textContent = `[${value || ' '}]:`;
        }
    }
}
//# sourceMappingURL=inputarea.js.map

/***/ }),

/***/ 734:
/*!*********************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/model.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isCodeCellModel": () => (/* binding */ isCodeCellModel),
/* harmony export */   "isMarkdownCellModel": () => (/* binding */ isMarkdownCellModel),
/* harmony export */   "isRawCellModel": () => (/* binding */ isRawCellModel),
/* harmony export */   "CellModel": () => (/* binding */ CellModel),
/* harmony export */   "AttachmentsCellModel": () => (/* binding */ AttachmentsCellModel),
/* harmony export */   "RawCellModel": () => (/* binding */ RawCellModel),
/* harmony export */   "MarkdownCellModel": () => (/* binding */ MarkdownCellModel),
/* harmony export */   "CodeCellModel": () => (/* binding */ CodeCellModel)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ 66065);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ 58137);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/attachments */ 19830);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/codeeditor */ 6256);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/shared-models */ 49634);
/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/outputarea */ 18943);
/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_3__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







function isCodeCellModel(model) {
    return model.type === 'code';
}
function isMarkdownCellModel(model) {
    return model.type === 'markdown';
}
function isRawCellModel(model) {
    return model.type === 'raw';
}
/**
 * An implementation of the cell model.
 */
class CellModel extends _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2__.CodeEditor.Model {
    /**
     * Construct a cell model from optional cell content.
     */
    constructor(options) {
        var _a;
        super({
            modelDB: options.modelDB,
            id: options.id || ((_a = options.cell) === null || _a === void 0 ? void 0 : _a.id) || _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4()
        });
        /**
         * A signal emitted when the state of the model changes.
         */
        this.contentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        /**
         * A signal emitted when a model state changes.
         */
        this.stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        /**
         * A mutex to update the shared model.
         */
        this._modelDBMutex = _jupyterlab_shared_models__WEBPACK_IMPORTED_MODULE_4__.createMutex();
        this.value.changed.connect(this.onGenericChange, this);
        const cellType = this.modelDB.createValue('type');
        cellType.set(this.type);
        const observableMetadata = this.modelDB.createMap('metadata');
        observableMetadata.changed.connect(this.onModelDBMetadataChange, this);
        observableMetadata.changed.connect(this.onGenericChange, this);
        const cell = options.cell;
        const trusted = this.modelDB.createValue('trusted');
        trusted.changed.connect(this.onTrustedChanged, this);
        if (!cell) {
            trusted.set(false);
            return;
        }
        trusted.set(!!cell.metadata['trusted']);
        delete cell.metadata['trusted'];
        if (Array.isArray(cell.source)) {
            this.value.text = cell.source.join('');
        }
        else {
            this.value.text = cell.source;
        }
        const metadata = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(cell.metadata);
        if (this.type !== 'raw') {
            delete metadata['format'];
        }
        if (this.type !== 'code') {
            delete metadata['collapsed'];
            delete metadata['scrolled'];
        }
        for (const key in metadata) {
            observableMetadata.set(key, metadata[key]);
        }
    }
    /**
     * The type of cell.
     */
    get type() {
        // This getter really should be abstract, but our current constructor
        // depends on .type working
        return 'raw';
    }
    /**
     * The id for the cell.
     */
    get id() {
        return this.sharedModel.getId();
    }
    /**
     * The metadata associated with the cell.
     */
    get metadata() {
        return this.modelDB.get('metadata');
    }
    /**
     * Get the trusted state of the model.
     */
    get trusted() {
        return this.modelDB.getValue('trusted');
    }
    /**
     * Set the trusted state of the model.
     */
    set trusted(newValue) {
        const oldValue = this.trusted;
        if (oldValue === newValue) {
            return;
        }
        this.modelDB.setValue('trusted', newValue);
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const metadata = Object.create(null);
        for (const key of this.metadata.keys()) {
            const value = JSON.parse(JSON.stringify(this.metadata.get(key)));
            metadata[key] = value;
        }
        if (this.trusted) {
            metadata['trusted'] = true;
        }
        return {
            cell_type: this.type,
            source: this.value.text,
            metadata
        };
    }
    /**
     * Handle a change to the trusted state.
     *
     * The default implementation is a no-op.
     */
    onTrustedChanged(trusted, args) {
        /* no-op */
    }
    /**
     * Handle a change to the cell metadata modelDB and reflect it in the shared model.
     */
    onModelDBMetadataChange(sender, event) {
        const metadata = this.sharedModel.getMetadata();
        this._modelDBMutex(() => {
            switch (event.type) {
                case 'add':
                    this._changeCellMetadata(metadata, event);
                    break;
                case 'change':
                    this._changeCellMetadata(metadata, event);
                    break;
                case 'remove':
                    delete metadata[event.key];
                    break;
                default:
                    throw new Error(`Invalid event type: ${event.type}`);
            }
            this.sharedModel.setMetadata(metadata);
        });
    }
    /**
     * Change the cell metadata for a given event.
     *
     * @param metadata The cell metadata.
     * @param event The event to handle.
     */
    _changeCellMetadata(metadata, event) {
        switch (event.key) {
            case 'jupyter':
                metadata.jupyter = event.newValue;
                break;
            case 'collapsed':
                metadata.collapsed = event.newValue;
                break;
            case 'name':
                metadata.name = event.newValue;
                break;
            case 'scrolled':
                metadata.scrolled = event.newValue;
                break;
            case 'tags':
                metadata.tags = event.newValue;
                break;
            case 'trusted':
                metadata.trusted = event.newValue;
                break;
            default:
                // The default is applied for custom metadata that are not
                // defined in the official nbformat but which are defined
                // by the user.
                metadata[event.key] = event.newValue;
        }
    }
    /**
     * Handle a change to the cell shared model and reflect it in modelDB.
     * We update the modeldb metadata when the shared model changes.
     *
     * This method overrides the CodeEditor protected _onSharedModelChanged
     * so we first call super._onSharedModelChanged
     *
     * @override CodeEditor._onSharedModelChanged
     */
    _onSharedModelChanged(sender, change) {
        super._onSharedModelChanged(sender, change);
        this._modelDBMutex(() => {
            var _a;
            if (change.metadataChange) {
                const newValue = (_a = change.metadataChange) === null || _a === void 0 ? void 0 : _a.newValue;
                if (newValue) {
                    Object.keys(newValue).map(key => {
                        switch (key) {
                            case 'collapsed':
                                this.metadata.set('collapsed', newValue.jupyter);
                                break;
                            case 'jupyter':
                                this.metadata.set('jupyter', newValue.jupyter);
                                break;
                            case 'name':
                                this.metadata.set('name', newValue.name);
                                break;
                            case 'scrolled':
                                this.metadata.set('scrolled', newValue.scrolled);
                                break;
                            case 'tags':
                                this.metadata.set('tags', newValue.tags);
                                break;
                            case 'trusted':
                                this.metadata.set('trusted', newValue.trusted);
                                break;
                            default:
                                // The default is applied for custom metadata that are not
                                // defined in the official nbformat but which are defined
                                // by the user.
                                this.metadata.set(key, newValue[key]);
                        }
                    });
                }
            }
        });
    }
    /**
     * Handle a change to the observable value.
     */
    onGenericChange() {
        this.contentChanged.emit(void 0);
    }
}
/**
 * A base implementation for cell models with attachments.
 */
class AttachmentsCellModel extends CellModel {
    /**
     * Construct a new cell with optional attachments.
     */
    constructor(options) {
        super(options);
        const factory = options.contentFactory || AttachmentsCellModel.defaultContentFactory;
        let attachments;
        const cell = options.cell;
        if (cell && (cell.cell_type === 'raw' || cell.cell_type === 'markdown')) {
            attachments = cell
                .attachments;
        }
        this._attachments = factory.createAttachmentsModel({
            values: attachments,
            modelDB: this.modelDB
        });
        this._attachments.stateChanged.connect(this.onGenericChange, this);
    }
    /**
     * Get the attachments of the model.
     */
    get attachments() {
        return this._attachments;
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const cell = super.toJSON();
        if (this.attachments.length) {
            cell.attachments = this.attachments.toJSON();
        }
        return cell;
    }
}
/**
 * The namespace for `AttachmentsCellModel` statics.
 */
(function (AttachmentsCellModel) {
    /**
     * The default implementation of an `IContentFactory`.
     */
    class ContentFactory {
        /**
         * Create an attachments model.
         */
        createAttachmentsModel(options) {
            return new _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_5__.AttachmentsModel(options);
        }
    }
    AttachmentsCellModel.ContentFactory = ContentFactory;
    /**
     * The shared `ContentFactory` instance.
     */
    AttachmentsCellModel.defaultContentFactory = new ContentFactory();
})(AttachmentsCellModel || (AttachmentsCellModel = {}));
/**
 * An implementation of a raw cell model.
 */
class RawCellModel extends AttachmentsCellModel {
    /**
     * The type of the cell.
     */
    get type() {
        return 'raw';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const cell = super.toJSON();
        cell.id = this.id;
        return cell;
    }
}
/**
 * An implementation of a markdown cell model.
 */
class MarkdownCellModel extends AttachmentsCellModel {
    /**
     * Construct a markdown cell model from optional cell content.
     */
    constructor(options) {
        super(options);
        // Use the Github-flavored markdown mode.
        this.mimeType = 'text/x-ipythongfm';
    }
    /**
     * The type of the cell.
     */
    get type() {
        return 'markdown';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const cell = super.toJSON();
        cell.id = this.id;
        return cell;
    }
}
/**
 * An implementation of a code cell Model.
 */
class CodeCellModel extends CellModel {
    /**
     * Construct a new code cell with optional original cell content.
     */
    constructor(options) {
        var _a;
        super(options);
        this._executedCode = '';
        this._isDirty = false;
        const factory = options.contentFactory || CodeCellModel.defaultContentFactory;
        const trusted = this.trusted;
        const cell = options.cell;
        let outputs = [];
        const executionCount = this.modelDB.createValue('executionCount');
        if (!executionCount.get()) {
            if (cell && cell.cell_type === 'code') {
                executionCount.set(cell.execution_count || null);
                outputs = (_a = cell.outputs) !== null && _a !== void 0 ? _a : [];
                // If output is not empty presume it results of the input code execution
                // TODO load from the notebook file when the dirty state is stored in it
                if (outputs.length > 0) {
                    this._executedCode = this.value.text.trim();
                }
            }
            else {
                executionCount.set(null);
            }
        }
        executionCount.changed.connect(this._onExecutionCountChanged, this);
        this._modelDBMutex(() => {
            const sharedCell = this.sharedModel;
            sharedCell.setOutputs(outputs);
        });
        this._outputs = factory.createOutputArea({ trusted, values: outputs });
        this._outputs.changed.connect(this.onGenericChange, this);
        this._outputs.changed.connect(this.onModelDBOutputsChange, this);
        // We keep `collapsed` and `jupyter.outputs_hidden` metadata in sync, since
        // they are redundant in nbformat 4.4. See
        // https://github.com/jupyter/nbformat/issues/137
        this.metadata.changed.connect(Private.collapseChanged, this);
        // Sync `collapsed` and `jupyter.outputs_hidden` for the first time, giving
        // preference to `collapsed`.
        if (this.metadata.has('collapsed')) {
            const collapsed = this.metadata.get('collapsed');
            Private.collapseChanged(this.metadata, {
                type: 'change',
                key: 'collapsed',
                oldValue: collapsed,
                newValue: collapsed
            });
        }
        else if (this.metadata.has('jupyter')) {
            const jupyter = this.metadata.get('jupyter');
            if (jupyter.hasOwnProperty('outputs_hidden')) {
                Private.collapseChanged(this.metadata, {
                    type: 'change',
                    key: 'jupyter',
                    oldValue: jupyter,
                    newValue: jupyter
                });
            }
        }
    }
    switchSharedModel(sharedModel, reinitialize) {
        if (reinitialize) {
            this.clearExecution();
            sharedModel.getOutputs().forEach(output => this._outputs.add(output));
        }
        super.switchSharedModel(sharedModel, reinitialize);
    }
    /**
     * The type of the cell.
     */
    get type() {
        return 'code';
    }
    /**
     * The execution count of the cell.
     */
    get executionCount() {
        return this.modelDB.has('executionCount')
            ? this.modelDB.getValue('executionCount')
            : null;
    }
    set executionCount(newValue) {
        const oldValue = this.executionCount;
        if (newValue === oldValue) {
            return;
        }
        this.modelDB.setValue('executionCount', newValue || null);
    }
    /**
     * Whether the cell is dirty or not.
     *
     * A cell is dirty if it is output is not empty and does not
     * result of the input code execution.
     */
    get isDirty() {
        // Test could be done dynamically with this._executedCode
        // but for performance reason, the diff status is stored in a boolean.
        return this._isDirty;
    }
    /**
     * Set whether the cell is dirty or not.
     */
    _setDirty(v) {
        if (v !== this._isDirty) {
            if (!v) {
                this._executedCode = this.value.text.trim();
            }
            this._isDirty = v;
            this.stateChanged.emit({
                name: 'isDirty',
                oldValue: !v,
                newValue: v
            });
        }
    }
    clearExecution() {
        this.outputs.clear();
        this.executionCount = null;
        this._setDirty(false);
        this.metadata.delete('execution');
    }
    /**
     * The cell outputs.
     */
    get outputs() {
        return this._outputs;
    }
    /**
     * Dispose of the resources held by the model.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._outputs.dispose();
        this._outputs = null;
        super.dispose();
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const cell = super.toJSON();
        cell.execution_count = this.executionCount || null;
        cell.outputs = this.outputs.toJSON();
        cell.id = this.id;
        return cell;
    }
    /**
     * Handle a change to the trusted state.
     */
    onTrustedChanged(trusted, args) {
        if (this._outputs) {
            this._outputs.trusted = args.newValue;
        }
        this.stateChanged.emit({
            name: 'trusted',
            oldValue: args.oldValue,
            newValue: args.newValue
        });
    }
    /**
     * Handle a change to the cell outputs modelDB and reflect it in the shared model.
     */
    onModelDBOutputsChange(sender, event) {
        const codeCell = this.sharedModel;
        this._modelDBMutex(() => {
            switch (event.type) {
                case 'add': {
                    const outputs = event.newValues.map(output => output.toJSON());
                    codeCell.updateOutputs(event.newIndex, event.newIndex + outputs.length, outputs);
                    break;
                }
                case 'set': {
                    const newValues = event.newValues.map(output => output.toJSON());
                    codeCell.updateOutputs(event.oldIndex, event.oldValues.length, newValues);
                    break;
                }
                case 'remove':
                    codeCell.updateOutputs(event.oldIndex, event.oldValues.length);
                    break;
                default:
                    throw new Error(`Invalid event type: ${event.type}`);
            }
        });
    }
    /**
     * Handle a change to the observable value.
     */
    onGenericChange() {
        if (this.executionCount !== null) {
            this._setDirty(this._executedCode !== this.value.text.trim());
        }
        this.contentChanged.emit(void 0);
    }
    /**
     * Handle a change to the output shared model and reflect it in modelDB.
     * We update the modeldb metadata when the nbcell changes.
     *
     * This method overrides the CellModel protected _onSharedModelChanged
     * so we first call super._onSharedModelChanged
     *
     * @override CellModel._onSharedModelChanged
     */
    _onSharedModelChanged(sender, change) {
        super._onSharedModelChanged(sender, change);
        this._modelDBMutex(() => {
            if (change.outputsChange) {
                this.clearExecution();
                sender.getOutputs().forEach(output => this._outputs.add(output));
            }
            if (change.executionCountChange) {
                this.executionCount = change.executionCountChange.newValue
                    ? change.executionCountChange.newValue
                    : null;
            }
        });
    }
    /**
     * Handle a change to the execution count.
     */
    _onExecutionCountChanged(count, args) {
        const codeCell = this.sharedModel;
        this._modelDBMutex(() => {
            codeCell.execution_count = args.newValue
                ? args.newValue
                : null;
        });
        this.contentChanged.emit(void 0);
        this.stateChanged.emit({
            name: 'executionCount',
            oldValue: args.oldValue,
            newValue: args.newValue
        });
        if (args.newValue && this.isDirty) {
            this._setDirty(false);
        }
    }
}
/**
 * The namespace for `CodeCellModel` statics.
 */
(function (CodeCellModel) {
    /**
     * The default implementation of an `IContentFactory`.
     */
    class ContentFactory {
        /**
         * Create an output area.
         */
        createOutputArea(options) {
            return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_3__.OutputAreaModel(options);
        }
    }
    CodeCellModel.ContentFactory = ContentFactory;
    /**
     * The shared `ContentFactory` instance.
     */
    CodeCellModel.defaultContentFactory = new ContentFactory();
})(CodeCellModel || (CodeCellModel = {}));
var Private;
(function (Private) {
    function collapseChanged(metadata, args) {
        if (args.key === 'collapsed') {
            const jupyter = (metadata.get('jupyter') || {});
            const { outputs_hidden } = jupyter, newJupyter = __rest(jupyter, ["outputs_hidden"]);
            if (outputs_hidden !== args.newValue) {
                if (args.newValue !== undefined) {
                    newJupyter['outputs_hidden'] = args.newValue;
                }
                if (Object.keys(newJupyter).length === 0) {
                    metadata.delete('jupyter');
                }
                else {
                    metadata.set('jupyter', newJupyter);
                }
            }
        }
        else if (args.key === 'jupyter') {
            const jupyter = (args.newValue || {});
            if (jupyter.hasOwnProperty('outputs_hidden')) {
                metadata.set('collapsed', jupyter.outputs_hidden);
            }
            else {
                metadata.delete('collapsed');
            }
        }
    }
    Private.collapseChanged = collapseChanged;
})(Private || (Private = {}));
//# sourceMappingURL=model.js.map

/***/ }),

/***/ 65026:
/*!***************************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/placeholder.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Placeholder": () => (/* binding */ Placeholder),
/* harmony export */   "InputPlaceholder": () => (/* binding */ InputPlaceholder),
/* harmony export */   "OutputPlaceholder": () => (/* binding */ OutputPlaceholder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ 96927);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ 65995);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/



/**
 * The CSS class added to placeholders.
 */
const PLACEHOLDER_CLASS = 'jp-Placeholder';
/**
 * The CSS classes added to input placeholder prompts.
 */
const INPUT_PROMPT_CLASS = 'jp-Placeholder-prompt jp-InputPrompt';
/**
 * The CSS classes added to output placeholder prompts.
 */
const OUTPUT_PROMPT_CLASS = 'jp-Placeholder-prompt jp-OutputPrompt';
/**
 * The CSS class added to placeholder content.
 */
const CONTENT_CLASS = 'jp-Placeholder-content';
/**
 * The CSS class added to input placeholders.
 */
const INPUT_PLACEHOLDER_CLASS = 'jp-InputPlaceholder';
/**
 * The CSS class added to output placeholders.
 */
const OUTPUT_PLACEHOLDER_CLASS = 'jp-OutputPlaceholder';
/**
 * An abstract base class for placeholders
 *
 * ### Notes
 * A placeholder is the element that is shown when input/output
 * is hidden.
 */
class Placeholder extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ReactWidget {
    /**
     * Construct a new placeholder.
     */
    constructor(callback) {
        super();
        this.addClass(PLACEHOLDER_CLASS);
        this._callback = callback;
    }
    /**
     * Handle the click event.
     */
    handleClick(e) {
        const callback = this._callback;
        callback(e);
    }
}
/**
 * The input placeholder class.
 */
class InputPlaceholder extends Placeholder {
    /**
     * Construct a new input placeholder.
     */
    constructor(callback) {
        super(callback);
        this.addClass(INPUT_PLACEHOLDER_CLASS);
    }
    /**
     * Render the input placeholder using the virtual DOM.
     */
    render() {
        return [
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: INPUT_PROMPT_CLASS, key: "input" }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: CONTENT_CLASS, onClick: e => this.handleClick(e), key: "content" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.ellipsesIcon.react, { className: "jp-MoreHorizIcon", elementPosition: "center", height: "auto", width: "32px" }))
        ];
    }
}
/**
 * The output placeholder class.
 */
class OutputPlaceholder extends Placeholder {
    /**
     * Construct a new output placeholder.
     */
    constructor(callback) {
        super(callback);
        this.addClass(OUTPUT_PLACEHOLDER_CLASS);
    }
    /**
     * Render the output placeholder using the virtual DOM.
     */
    render() {
        return [
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: OUTPUT_PROMPT_CLASS, key: "output" }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: CONTENT_CLASS, onClick: e => this.handleClick(e), key: "content" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.ellipsesIcon.react, { className: "jp-MoreHorizIcon", elementPosition: "center", height: "auto", width: "32px" }))
        ];
    }
}
//# sourceMappingURL=placeholder.js.map

/***/ }),

/***/ 62124:
/*!**********************************************************!*\
  !*** ../../node_modules/@jupyterlab/cells/lib/widget.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MARKDOWN_HEADING_COLLAPSED": () => (/* binding */ MARKDOWN_HEADING_COLLAPSED),
/* harmony export */   "Cell": () => (/* binding */ Cell),
/* harmony export */   "CodeCell": () => (/* binding */ CodeCell),
/* harmony export */   "AttachmentsCell": () => (/* binding */ AttachmentsCell),
/* harmony export */   "MarkdownCell": () => (/* binding */ MarkdownCell),
/* harmony export */   "RawCell": () => (/* binding */ RawCell)
/* harmony export */ });
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! marked */ 13917);
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(marked__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @jupyterlab/attachments */ 19830);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/coreutils */ 78548);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/outputarea */ 18943);
/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/rendermime */ 34410);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/coreutils */ 66065);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/algorithm */ 79028);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/widgets */ 77031);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _collapser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./collapser */ 41037);
/* harmony import */ var _headerfooter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./headerfooter */ 87849);
/* harmony import */ var _inputarea__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./inputarea */ 3348);
/* harmony import */ var _placeholder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./placeholder */ 65026);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lumino/signaling */ 58137);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jupyterlab/ui-components */ 65995);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/














/**
 * The CSS class added to cell widgets.
 */
const CELL_CLASS = 'jp-Cell';
/**
 * The CSS class added to the cell header.
 */
const CELL_HEADER_CLASS = 'jp-Cell-header';
/**
 * The CSS class added to the cell footer.
 */
const CELL_FOOTER_CLASS = 'jp-Cell-footer';
/**
 * The CSS class added to the cell input wrapper.
 */
const CELL_INPUT_WRAPPER_CLASS = 'jp-Cell-inputWrapper';
/**
 * The CSS class added to the cell output wrapper.
 */
const CELL_OUTPUT_WRAPPER_CLASS = 'jp-Cell-outputWrapper';
/**
 * The CSS class added to the cell input area.
 */
const CELL_INPUT_AREA_CLASS = 'jp-Cell-inputArea';
/**
 * The CSS class added to the cell output area.
 */
const CELL_OUTPUT_AREA_CLASS = 'jp-Cell-outputArea';
/**
 * The CSS class added to the cell input collapser.
 */
const CELL_INPUT_COLLAPSER_CLASS = 'jp-Cell-inputCollapser';
/**
 * The CSS class added to the cell output collapser.
 */
const CELL_OUTPUT_COLLAPSER_CLASS = 'jp-Cell-outputCollapser';
/**
 * The class name added to the cell when readonly.
 */
const READONLY_CLASS = 'jp-mod-readOnly';
/**
 * The class name added to the cell when dirty.
 */
const DIRTY_CLASS = 'jp-mod-dirty';
/**
 * The class name added to code cells.
 */
const CODE_CELL_CLASS = 'jp-CodeCell';
/**
 * The class name added to markdown cells.
 */
const MARKDOWN_CELL_CLASS = 'jp-MarkdownCell';
/**
 * The class name added to rendered markdown output widgets.
 */
const MARKDOWN_OUTPUT_CLASS = 'jp-MarkdownOutput';
const MARKDOWN_HEADING_COLLAPSED = 'jp-MarkdownHeadingCollapsed';
const HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';
const SHOW_HIDDEN_CELLS_CLASS = 'jp-showHiddenCellsButton';
/**
 * The class name added to raw cells.
 */
const RAW_CELL_CLASS = 'jp-RawCell';
/**
 * The class name added to a rendered input area.
 */
const RENDERED_CLASS = 'jp-mod-rendered';
const NO_OUTPUTS_CLASS = 'jp-mod-noOutputs';
/**
 * The text applied to an empty markdown cell.
 */
const DEFAULT_MARKDOWN_TEXT = 'Type Markdown and LaTeX: $ ^2 $';
/**
 * The timeout to wait for change activity to have ceased before rendering.
 */
const RENDER_TIMEOUT = 1000;
/**
 * The mime type for a rich contents drag object.
 */
const CONTENTS_MIME_RICH = 'application/x-jupyter-icontentsrich';
/** ****************************************************************************
 * Cell
 ******************************************************************************/
/**
 * A base cell widget.
 */
class Cell extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_6__.Widget {
    /**
     * Construct a new base cell widget.
     */
    constructor(options) {
        super();
        this._readOnly = false;
        this._inputHidden = false;
        this._syncCollapse = false;
        this._syncEditable = false;
        this.addClass(CELL_CLASS);
        const model = (this._model = options.model);
        const contentFactory = (this.contentFactory =
            options.contentFactory || Cell.defaultContentFactory);
        this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_6__.PanelLayout();
        // Header
        const header = contentFactory.createCellHeader();
        header.addClass(CELL_HEADER_CLASS);
        this.layout.addWidget(header);
        // Input
        const inputWrapper = (this._inputWrapper = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_6__.Panel());
        inputWrapper.addClass(CELL_INPUT_WRAPPER_CLASS);
        const inputCollapser = new _collapser__WEBPACK_IMPORTED_MODULE_9__.InputCollapser();
        inputCollapser.addClass(CELL_INPUT_COLLAPSER_CLASS);
        const input = (this._input = new _inputarea__WEBPACK_IMPORTED_MODULE_10__.InputArea({
            model,
            contentFactory,
            updateOnShow: options.updateEditorOnShow,
            placeholder: options.placeholder
        }));
        input.addClass(CELL_INPUT_AREA_CLASS);
        inputWrapper.addWidget(inputCollapser);
        inputWrapper.addWidget(input);
        this.layout.addWidget(inputWrapper);
        this._inputPlaceholder = new _placeholder__WEBPACK_IMPORTED_MODULE_11__.InputPlaceholder(() => {
            this.inputHidden = !this.inputHidden;
        });
        // Footer
        const footer = this.contentFactory.createCellFooter();
        footer.addClass(CELL_FOOTER_CLASS);
        this.layout.addWidget(footer);
        // Editor settings
        if (options.editorConfig) {
            let editorOptions = {};
            Object.keys(options.editorConfig).forEach((key) => {
                var _a, _b;
                editorOptions[key] = (_b = (_a = options.editorConfig) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : null;
            });
            this.editor.setOptions(editorOptions);
        }
        model.metadata.changed.connect(this.onMetadataChanged, this);
    }
    /**
     * Initialize view state from model.
     *
     * #### Notes
     * Should be called after construction. For convenience, returns this, so it
     * can be chained in the construction, like `new Foo().initializeState();`
     */
    initializeState() {
        this.loadCollapseState();
        this.loadEditableState();
        return this;
    }
    /**
     * Get the prompt node used by the cell.
     */
    get promptNode() {
        if (!this._inputHidden) {
            return this._input.promptNode;
        }
        else {
            return this._inputPlaceholder.node
                .firstElementChild;
        }
    }
    /**
     * Get the CodeEditorWrapper used by the cell.
     */
    get editorWidget() {
        return this._input.editorWidget;
    }
    /**
     * Get the CodeEditor used by the cell.
     */
    get editor() {
        return this._input.editor;
    }
    /**
     * Get the model used by the cell.
     */
    get model() {
        return this._model;
    }
    /**
     * Get the input area for the cell.
     */
    get inputArea() {
        return this._input;
    }
    /**
     * The read only state of the cell.
     */
    get readOnly() {
        return this._readOnly;
    }
    set readOnly(value) {
        if (value === this._readOnly) {
            return;
        }
        this._readOnly = value;
        if (this.syncEditable) {
            this.saveEditableState();
        }
        this.update();
    }
    /**
     * Save view editable state to model
     */
    saveEditableState() {
        const { metadata } = this.model;
        const current = metadata.get('editable');
        if ((this.readOnly && current === false) ||
            (!this.readOnly && current === undefined)) {
            return;
        }
        if (this.readOnly) {
            this.model.metadata.set('editable', false);
        }
        else {
            this.model.metadata.delete('editable');
        }
    }
    /**
     * Load view editable state from model.
     */
    loadEditableState() {
        this.readOnly = this.model.metadata.get('editable') === false;
    }
    /**
     * A promise that resolves when the widget renders for the first time.
     */
    get ready() {
        return Promise.resolve(undefined);
    }
    /**
     * Set the prompt for the widget.
     */
    setPrompt(value) {
        this._input.setPrompt(value);
    }
    /**
     * The view state of input being hidden.
     */
    get inputHidden() {
        return this._inputHidden;
    }
    set inputHidden(value) {
        if (this._inputHidden === value) {
            return;
        }
        const layout = this._inputWrapper.layout;
        if (value) {
            this._input.parent = null;
            layout.addWidget(this._inputPlaceholder);
        }
        else {
            this._inputPlaceholder.parent = null;
            layout.addWidget(this._input);
        }
        this._inputHidden = value;
        if (this.syncCollapse) {
            this.saveCollapseState();
        }
        this.handleInputHidden(value);
    }
    /**
     * Save view collapse state to model
     */
    saveCollapseState() {
        const jupyter = Object.assign({}, this.model.metadata.get('jupyter'));
        if ((this.inputHidden && jupyter.source_hidden === true) ||
            (!this.inputHidden && jupyter.source_hidden === undefined)) {
            return;
        }
        if (this.inputHidden) {
            jupyter.source_hidden = true;
        }
        else {
            delete jupyter.source_hidden;
        }
        if (Object.keys(jupyter).length === 0) {
            this.model.metadata.delete('jupyter');
        }
        else {
            this.model.metadata.set('jupyter', jupyter);
        }
    }
    /**
     * Revert view collapse state from model.
     */
    loadCollapseState() {
        const jupyter = this.model.metadata.get('jupyter') || {};
        this.inputHidden = !!jupyter.source_hidden;
    }
    /**
     * Handle the input being hidden.
     *
     * #### Notes
     * This is called by the `inputHidden` setter so that subclasses
     * can perform actions upon the input being hidden without accessing
     * private state.
     */
    handleInputHidden(value) {
        return;
    }
    /**
     * Whether to sync the collapse state to the cell model.
     */
    get syncCollapse() {
        return this._syncCollapse;
    }
    set syncCollapse(value) {
        if (this._syncCollapse === value) {
            return;
        }
        this._syncCollapse = value;
        if (value) {
            this.loadCollapseState();
        }
    }
    /**
     * Whether to sync the editable state to the cell model.
     */
    get syncEditable() {
        return this._syncEditable;
    }
    set syncEditable(value) {
        if (this._syncEditable === value) {
            return;
        }
        this._syncEditable = value;
        if (value) {
            this.loadEditableState();
        }
    }
    /**
     * Clone the cell, using the same model.
     */
    clone() {
        const constructor = this.constructor;
        return new constructor({
            model: this.model,
            contentFactory: this.contentFactory,
            placeholder: false
        });
    }
    /**
     * Dispose of the resources held by the widget.
     */
    dispose() {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._input = null;
        this._model = null;
        this._inputWrapper = null;
        this._inputPlaceholder = null;
        super.dispose();
    }
    /**
     * Handle `after-attach` messages.
     */
    onAfterAttach(msg) {
        this.update();
    }
    /**
     * Handle `'activate-request'` messages.
     */
    onActivateRequest(msg) {
        this.editor.focus();
    }
    /**
     * Handle `fit-request` messages.
     */
    onFitRequest(msg) {
        // need this for for when a theme changes font size
        this.editor.refresh();
    }
    /**
     * Handle `update-request` messages.
     */
    onUpdateRequest(msg) {
        if (!this._model) {
            return;
        }
        // Handle read only state.
        if (this.editor.getOption('readOnly') !== this._readOnly) {
            this.editor.setOption('readOnly', this._readOnly);
            this.toggleClass(READONLY_CLASS, this._readOnly);
        }
    }
    /**
     * Handle changes in the metadata.
     */
    onMetadataChanged(model, args) {
        switch (args.key) {
            case 'jupyter':
                if (this.syncCollapse) {
                    this.loadCollapseState();
                }
                break;
            case 'editable':
                if (this.syncEditable) {
                    this.loadEditableState();
                }
                break;
            default:
                break;
        }
    }
}
/**
 * The namespace for the `Cell` class statics.
 */
(function (Cell) {
    /**
     * The default implementation of an `IContentFactory`.
     *
     * This includes a CodeMirror editor factory to make it easy to use out of the box.
     */
    class ContentFactory {
        /**
         * Create a content factory for a cell.
         */
        constructor(options = {}) {
            this._editorFactory =
                options.editorFactory || _inputarea__WEBPACK_IMPORTED_MODULE_10__.InputArea.defaultEditorFactory;
        }
        /**
         * The readonly editor factory that create code editors
         */
        get editorFactory() {
            return this._editorFactory;
        }
        /**
         * Create a new cell header for the parent widget.
         */
        createCellHeader() {
            return new _headerfooter__WEBPACK_IMPORTED_MODULE_12__.CellHeader();
        }
        /**
         * Create a new cell header for the parent widget.
         */
        createCellFooter() {
            return new _headerfooter__WEBPACK_IMPORTED_MODULE_12__.CellFooter();
        }
        /**
         * Create an input prompt.
         */
        createInputPrompt() {
            return new _inputarea__WEBPACK_IMPORTED_MODULE_10__.InputPrompt();
        }
        /**
         * Create the output prompt for the widget.
         */
        createOutputPrompt() {
            return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__.OutputPrompt();
        }
        /**
         * Create an stdin widget.
         */
        createStdin(options) {
            return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__.Stdin(options);
        }
    }
    Cell.ContentFactory = ContentFactory;
    /**
     * The default content factory for cells.
     */
    Cell.defaultContentFactory = new ContentFactory();
})(Cell || (Cell = {}));
/** ****************************************************************************
 * CodeCell
 ******************************************************************************/
/**
 * A widget for a code cell.
 */
class CodeCell extends Cell {
    /**
     * Construct a code cell widget.
     */
    constructor(options) {
        super(options);
        this._outputHidden = false;
        this._syncScrolled = false;
        this._savingMetadata = false;
        this.addClass(CODE_CELL_CLASS);
        // Only save options not handled by parent constructor.
        const rendermime = (this._rendermime = options.rendermime);
        const contentFactory = this.contentFactory;
        const model = this.model;
        if (!options.placeholder) {
            // Insert the output before the cell footer.
            const outputWrapper = (this._outputWrapper = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_6__.Panel());
            outputWrapper.addClass(CELL_OUTPUT_WRAPPER_CLASS);
            const outputCollapser = new _collapser__WEBPACK_IMPORTED_MODULE_9__.OutputCollapser();
            outputCollapser.addClass(CELL_OUTPUT_COLLAPSER_CLASS);
            const output = (this._output = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__.OutputArea({
                model: model.outputs,
                rendermime,
                contentFactory: contentFactory,
                maxNumberOutputs: options.maxNumberOutputs
            }));
            output.addClass(CELL_OUTPUT_AREA_CLASS);
            // Set a CSS if there are no outputs, and connect a signal for future
            // changes to the number of outputs. This is for conditional styling
            // if there are no outputs.
            if (model.outputs.length === 0) {
                this.addClass(NO_OUTPUTS_CLASS);
            }
            output.outputLengthChanged.connect(this._outputLengthHandler, this);
            outputWrapper.addWidget(outputCollapser);
            outputWrapper.addWidget(output);
            this.layout.insertWidget(2, outputWrapper);
            if (model.isDirty) {
                this.addClass(DIRTY_CLASS);
            }
            this._outputPlaceholder = new _placeholder__WEBPACK_IMPORTED_MODULE_11__.OutputPlaceholder(() => {
                this.outputHidden = !this.outputHidden;
            });
        }
        model.stateChanged.connect(this.onStateChanged, this);
    }
    /**
     * Initialize view state from model.
     *
     * #### Notes
     * Should be called after construction. For convenience, returns this, so it
     * can be chained in the construction, like `new Foo().initializeState();`
     */
    initializeState() {
        super.initializeState();
        this.loadScrolledState();
        this.setPrompt(`${this.model.executionCount || ''}`);
        return this;
    }
    /**
     * Get the output area for the cell.
     */
    get outputArea() {
        return this._output;
    }
    /**
     * The view state of output being collapsed.
     */
    get outputHidden() {
        return this._outputHidden;
    }
    set outputHidden(value) {
        if (this._outputHidden === value) {
            return;
        }
        const layout = this._outputWrapper.layout;
        if (value) {
            layout.removeWidget(this._output);
            layout.addWidget(this._outputPlaceholder);
            if (this.inputHidden && !this._outputWrapper.isHidden) {
                this._outputWrapper.hide();
            }
        }
        else {
            if (this._outputWrapper.isHidden) {
                this._outputWrapper.show();
            }
            layout.removeWidget(this._outputPlaceholder);
            layout.addWidget(this._output);
        }
        this._outputHidden = value;
        if (this.syncCollapse) {
            this.saveCollapseState();
        }
    }
    /**
     * Save view collapse state to model
     */
    saveCollapseState() {
        // Because collapse state for a code cell involves two different pieces of
        // metadata (the `collapsed` and `jupyter` metadata keys), we block reacting
        // to changes in metadata until we have fully committed our changes.
        // Otherwise setting one key can trigger a write to the other key to
        // maintain the synced consistency.
        this._savingMetadata = true;
        try {
            super.saveCollapseState();
            const metadata = this.model.metadata;
            const collapsed = this.model.metadata.get('collapsed');
            if ((this.outputHidden && collapsed === true) ||
                (!this.outputHidden && collapsed === undefined)) {
                return;
            }
            // Do not set jupyter.outputs_hidden since it is redundant. See
            // and https://github.com/jupyter/nbformat/issues/137
            if (this.outputHidden) {
                metadata.set('collapsed', true);
            }
            else {
                metadata.delete('collapsed');
            }
        }
        finally {
            this._savingMetadata = false;
        }
    }
    /**
     * Revert view collapse state from model.
     *
     * We consider the `collapsed` metadata key as the source of truth for outputs
     * being hidden.
     */
    loadCollapseState() {
        super.loadCollapseState();
        this.outputHidden = !!this.model.metadata.get('collapsed');
    }
    /**
     * Whether the output is in a scrolled state?
     */
    get outputsScrolled() {
        return this._outputsScrolled;
    }
    set outputsScrolled(value) {
        this.toggleClass('jp-mod-outputsScrolled', value);
        this._outputsScrolled = value;
        if (this.syncScrolled) {
            this.saveScrolledState();
        }
    }
    /**
     * Save view collapse state to model
     */
    saveScrolledState() {
        const { metadata } = this.model;
        const current = metadata.get('scrolled');
        if ((this.outputsScrolled && current === true) ||
            (!this.outputsScrolled && current === undefined)) {
            return;
        }
        if (this.outputsScrolled) {
            metadata.set('scrolled', true);
        }
        else {
            metadata.delete('scrolled');
        }
    }
    /**
     * Revert view collapse state from model.
     */
    loadScrolledState() {
        const metadata = this.model.metadata;
        // We don't have the notion of 'auto' scrolled, so we make it false.
        if (metadata.get('scrolled') === 'auto') {
            this.outputsScrolled = false;
        }
        else {
            this.outputsScrolled = !!metadata.get('scrolled');
        }
    }
    /**
     * Whether to sync the scrolled state to the cell model.
     */
    get syncScrolled() {
        return this._syncScrolled;
    }
    set syncScrolled(value) {
        if (this._syncScrolled === value) {
            return;
        }
        this._syncScrolled = value;
        if (value) {
            this.loadScrolledState();
        }
    }
    /**
     * Handle the input being hidden.
     *
     * #### Notes
     * This method is called by the case cell implementation and is
     * subclasses here so the code cell can watch to see when input
     * is hidden without accessing private state.
     */
    handleInputHidden(value) {
        if (!value && this._outputWrapper.isHidden) {
            this._outputWrapper.show();
        }
        else if (value && !this._outputWrapper.isHidden && this._outputHidden) {
            this._outputWrapper.hide();
        }
    }
    /**
     * Clone the cell, using the same model.
     */
    clone() {
        const constructor = this.constructor;
        return new constructor({
            model: this.model,
            contentFactory: this.contentFactory,
            rendermime: this._rendermime,
            placeholder: false
        });
    }
    /**
     * Clone the OutputArea alone, returning a simplified output area, using the same model.
     */
    cloneOutputArea() {
        return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__.SimplifiedOutputArea({
            model: this.model.outputs,
            contentFactory: this.contentFactory,
            rendermime: this._rendermime
        });
    }
    /**
     * Dispose of the resources used by the widget.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._output.outputLengthChanged.disconnect(this._outputLengthHandler, this);
        this._rendermime = null;
        this._output = null;
        this._outputWrapper = null;
        this._outputPlaceholder = null;
        super.dispose();
    }
    /**
     * Handle changes in the model.
     */
    onStateChanged(model, args) {
        switch (args.name) {
            case 'executionCount':
                this.setPrompt(`${model.executionCount || ''}`);
                break;
            case 'isDirty':
                if (model.isDirty) {
                    this.addClass(DIRTY_CLASS);
                }
                else {
                    this.removeClass(DIRTY_CLASS);
                }
                break;
            default:
                break;
        }
    }
    /**
     * Handle changes in the metadata.
     */
    onMetadataChanged(model, args) {
        if (this._savingMetadata) {
            // We are in middle of a metadata transaction, so don't react to it.
            return;
        }
        switch (args.key) {
            case 'scrolled':
                if (this.syncScrolled) {
                    this.loadScrolledState();
                }
                break;
            case 'collapsed':
                if (this.syncCollapse) {
                    this.loadCollapseState();
                }
                break;
            default:
                break;
        }
        super.onMetadataChanged(model, args);
    }
    /**
     * Handle changes in the number of outputs in the output area.
     */
    _outputLengthHandler(sender, args) {
        const force = args === 0 ? true : false;
        this.toggleClass(NO_OUTPUTS_CLASS, force);
    }
}
/**
 * The namespace for the `CodeCell` class statics.
 */
(function (CodeCell) {
    /**
     * Execute a cell given a client session.
     */
    async function execute(cell, sessionContext, metadata) {
        var _a;
        const model = cell.model;
        const code = model.value.text;
        if (!code.trim() || !((_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel)) {
            model.clearExecution();
            return;
        }
        const cellId = { cellId: model.id };
        metadata = Object.assign(Object.assign(Object.assign({}, model.metadata.toJSON()), metadata), cellId);
        const { recordTiming } = metadata;
        model.clearExecution();
        cell.outputHidden = false;
        cell.setPrompt('*');
        model.trusted = true;
        let future;
        try {
            const msgPromise = _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__.OutputArea.execute(code, cell.outputArea, sessionContext, metadata);
            // cell.outputArea.future assigned synchronously in `execute`
            if (recordTiming) {
                const recordTimingHook = (msg) => {
                    let label;
                    switch (msg.header.msg_type) {
                        case 'status':
                            label = `status.${msg.content.execution_state}`;
                            break;
                        case 'execute_input':
                            label = 'execute_input';
                            break;
                        default:
                            return true;
                    }
                    // If the data is missing, estimate it to now
                    // Date was added in 5.1: https://jupyter-client.readthedocs.io/en/stable/messaging.html#message-header
                    const value = msg.header.date || new Date().toISOString();
                    const timingInfo = Object.assign({}, model.metadata.get('execution'));
                    timingInfo[`iopub.${label}`] = value;
                    model.metadata.set('execution', timingInfo);
                    return true;
                };
                cell.outputArea.future.registerMessageHook(recordTimingHook);
            }
            else {
                model.metadata.delete('execution');
            }
            // Save this execution's future so we can compare in the catch below.
            future = cell.outputArea.future;
            const msg = (await msgPromise);
            model.executionCount = msg.content.execution_count;
            if (recordTiming) {
                const timingInfo = Object.assign({}, model.metadata.get('execution'));
                const started = msg.metadata.started;
                // Started is not in the API, but metadata IPyKernel sends
                if (started) {
                    timingInfo['shell.execute_reply.started'] = started;
                }
                // Per above, the 5.0 spec does not assume date, so we estimate is required
                const finished = msg.header.date;
                timingInfo['shell.execute_reply'] =
                    finished || new Date().toISOString();
                model.metadata.set('execution', timingInfo);
            }
            return msg;
        }
        catch (e) {
            // If we started executing, and the cell is still indicating this
            // execution, clear the prompt.
            if (future && !cell.isDisposed && cell.outputArea.future === future) {
                cell.setPrompt('');
            }
            throw e;
        }
    }
    CodeCell.execute = execute;
})(CodeCell || (CodeCell = {}));
/**
 * `AttachmentsCell` - A base class for a cell widget that allows
 *  attachments to be drag/drop'd or pasted onto it
 */
class AttachmentsCell extends Cell {
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the notebook panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'paste':
                this._evtPaste(event);
                break;
            case 'dragenter':
                event.preventDefault();
                break;
            case 'dragover':
                event.preventDefault();
                break;
            case 'drop':
                this._evtNativeDrop(event);
                break;
            case 'lm-dragover':
                this._evtDragOver(event);
                break;
            case 'lm-drop':
                this._evtDrop(event);
                break;
            default:
                break;
        }
    }
    /**
     * Handle `after-attach` messages for the widget.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        const node = this.node;
        node.addEventListener('lm-dragover', this);
        node.addEventListener('lm-drop', this);
        node.addEventListener('dragenter', this);
        node.addEventListener('dragover', this);
        node.addEventListener('drop', this);
        node.addEventListener('paste', this);
    }
    /**
     * A message handler invoked on a `'before-detach'`
     * message
     */
    onBeforeDetach(msg) {
        const node = this.node;
        node.removeEventListener('drop', this);
        node.removeEventListener('dragover', this);
        node.removeEventListener('dragenter', this);
        node.removeEventListener('paste', this);
        node.removeEventListener('lm-dragover', this);
        node.removeEventListener('lm-drop', this);
    }
    _evtDragOver(event) {
        const supportedMimeType = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__.some)(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__.imageRendererFactory.mimeTypes, mimeType => {
            if (!event.mimeData.hasData(CONTENTS_MIME_RICH)) {
                return false;
            }
            const data = event.mimeData.getData(CONTENTS_MIME_RICH);
            return data.model.mimetype === mimeType;
        });
        if (!supportedMimeType) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.dropAction = event.proposedAction;
    }
    /**
     * Handle the `paste` event for the widget
     */
    _evtPaste(event) {
        if (event.clipboardData) {
            const items = event.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type === 'text/plain') {
                    // Skip if this text is the path to a file
                    if (i < items.length - 1 && items[i + 1].kind === 'file') {
                        continue;
                    }
                    items[i].getAsString(text => {
                        var _a, _b;
                        (_b = (_a = this.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, text);
                    });
                }
                this._attachFiles(event.clipboardData.items);
            }
        }
        event.preventDefault();
    }
    /**
     * Handle the `drop` event for the widget
     */
    _evtNativeDrop(event) {
        if (event.dataTransfer) {
            this._attachFiles(event.dataTransfer.items);
        }
        event.preventDefault();
    }
    /**
     * Handle the `'lm-drop'` event for the widget.
     */
    _evtDrop(event) {
        const supportedMimeTypes = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__.toArray)((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__.filter)(event.mimeData.types(), mimeType => {
            if (mimeType === CONTENTS_MIME_RICH) {
                const data = event.mimeData.getData(CONTENTS_MIME_RICH);
                return (_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__.imageRendererFactory.mimeTypes.indexOf(data.model.mimetype) !== -1);
            }
            return _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__.imageRendererFactory.mimeTypes.indexOf(mimeType) !== -1;
        }));
        if (supportedMimeTypes.length === 0) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.proposedAction === 'none') {
            event.dropAction = 'none';
            return;
        }
        event.dropAction = 'copy';
        for (const mimeType of supportedMimeTypes) {
            if (mimeType === CONTENTS_MIME_RICH) {
                const { model, withContent } = event.mimeData.getData(CONTENTS_MIME_RICH);
                if (model.type === 'file') {
                    const URI = this._generateURI(model.name);
                    this.updateCellSourceWithAttachment(model.name, URI);
                    void withContent().then(fullModel => {
                        this.model.attachments.set(URI, {
                            [fullModel.mimetype]: fullModel.content
                        });
                    });
                }
            }
            else {
                // Pure mimetype, no useful name to infer
                const URI = this._generateURI();
                this.model.attachments.set(URI, {
                    [mimeType]: event.mimeData.getData(mimeType)
                });
                this.updateCellSourceWithAttachment(URI, URI);
            }
        }
    }
    /**
     * Attaches all DataTransferItems (obtained from
     * clipboard or native drop events) to the cell
     */
    _attachFiles(items) {
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const blob = item.getAsFile();
                if (blob) {
                    this._attachFile(blob);
                }
            }
        }
    }
    /**
     * Takes in a file object and adds it to
     * the cell attachments
     */
    _attachFile(blob) {
        const reader = new FileReader();
        reader.onload = evt => {
            const { href, protocol } = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.URLExt.parse(reader.result);
            if (protocol !== 'data:') {
                return;
            }
            const dataURIRegex = /([\w+\/\+]+)?(?:;(charset=[\w\d-]*|base64))?,(.*)/;
            const matches = dataURIRegex.exec(href);
            if (!matches || matches.length !== 4) {
                return;
            }
            const mimeType = matches[1];
            const encodedData = matches[3];
            const bundle = { [mimeType]: encodedData };
            const URI = this._generateURI(blob.name);
            if (mimeType.startsWith('image/')) {
                this.model.attachments.set(URI, bundle);
                this.updateCellSourceWithAttachment(blob.name, URI);
            }
        };
        reader.onerror = evt => {
            console.error(`Failed to attach ${blob.name}` + evt);
        };
        reader.readAsDataURL(blob);
    }
    /**
     * Generates a unique URI for a file
     * while preserving the file extension.
     */
    _generateURI(name = '') {
        const lastIndex = name.lastIndexOf('.');
        return lastIndex !== -1
            ? _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.UUID.uuid4().concat(name.substring(lastIndex))
            : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.UUID.uuid4();
    }
}
/** ****************************************************************************
 * MarkdownCell
 ******************************************************************************/
/**
 * A widget for a Markdown cell.
 *
 * #### Notes
 * Things get complicated if we want the rendered text to update
 * any time the text changes, the text editor model changes,
 * or the input area model changes.  We don't support automatically
 * updating the rendered text in all of these cases.
 */
class MarkdownCell extends AttachmentsCell {
    /**
     * Construct a Markdown cell widget.
     */
    constructor(options) {
        var _a, _b;
        super(options);
        this._toggleCollapsedSignal = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal(this);
        this._renderer = null;
        this._rendered = true;
        this._prevText = '';
        this._ready = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.PromiseDelegate();
        this.addClass(MARKDOWN_CELL_CLASS);
        // Ensure we can resolve attachments:
        this._rendermime = options.rendermime.clone({
            resolver: new _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_13__.AttachmentsResolver({
                parent: (_a = options.rendermime.resolver) !== null && _a !== void 0 ? _a : undefined,
                model: this.model.attachments
            })
        });
        // Stop codemirror handling paste
        this.editor.setOption('handlePaste', false);
        // Check if heading cell is set to be collapsed
        this._headingCollapsed = ((_b = this.model.metadata.get(MARKDOWN_HEADING_COLLAPSED)) !== null && _b !== void 0 ? _b : false);
        // Throttle the rendering rate of the widget.
        this._monitor = new _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.ActivityMonitor({
            signal: this.model.contentChanged,
            timeout: RENDER_TIMEOUT
        });
        this._monitor.activityStopped.connect(() => {
            if (this._rendered) {
                this.update();
            }
        }, this);
        void this._updateRenderedInput().then(() => {
            this._ready.resolve(void 0);
        });
        this.renderCollapseButtons(this._renderer);
        this.renderInput(this._renderer);
    }
    /**
     * A promise that resolves when the widget renders for the first time.
     */
    get ready() {
        return this._ready.promise;
    }
    /**
     * Text that represents the heading if cell is a heading.
     * Returns empty string if not a heading.
     */
    get headingInfo() {
        let text = this.model.value.text;
        const lines = marked__WEBPACK_IMPORTED_MODULE_0___default().lexer(text);
        let line;
        for (line of lines) {
            if (line.type === 'heading') {
                return { text: line.text, level: line.depth };
            }
            else if (line.type === 'html') {
                let match = line.raw.match(/<h([1-6])(.*?)>(.*?)<\/h\1>/);
                if (match === null || match === void 0 ? void 0 : match[3]) {
                    return { text: match[3], level: parseInt(match[1]) };
                }
                return { text: '', level: -1 };
            }
        }
        return { text: '', level: -1 };
    }
    get headingCollapsed() {
        return this._headingCollapsed;
    }
    set headingCollapsed(value) {
        this._headingCollapsed = value;
        if (value) {
            this.model.metadata.set(MARKDOWN_HEADING_COLLAPSED, value);
        }
        else if (this.model.metadata.has(MARKDOWN_HEADING_COLLAPSED)) {
            this.model.metadata.delete(MARKDOWN_HEADING_COLLAPSED);
        }
        const collapseButton = this.inputArea.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS)[0];
        if (collapseButton) {
            collapseButton.setAttribute('style', `background:
      ${value ? 'var(--jp-icon-caret-right)' : 'var(--jp-icon-caret-down)'} no-repeat center`);
        }
        this.renderCollapseButtons(this._renderer);
    }
    get numberChildNodes() {
        return this._numberChildNodes;
    }
    set numberChildNodes(value) {
        this._numberChildNodes = value;
        this.renderCollapseButtons(this._renderer);
    }
    get toggleCollapsedSignal() {
        return this._toggleCollapsedSignal;
    }
    /**
     * Whether the cell is rendered.
     */
    get rendered() {
        return this._rendered;
    }
    set rendered(value) {
        if (value === this._rendered) {
            return;
        }
        this._rendered = value;
        this._handleRendered();
        // Refreshing an editor can be really expensive, so we don't call it from
        // _handleRendered, since _handledRendered is also called on every update
        // request.
        if (!this._rendered) {
            this.editor.refresh();
        }
    }
    maybeCreateCollapseButton() {
        if (this.headingInfo.level > 0 &&
            this.inputArea.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS)
                .length == 0) {
            let collapseButton = this.inputArea.promptNode.appendChild(document.createElement('button'));
            collapseButton.className = `bp3-button bp3-minimal jp-Button minimal ${HEADING_COLLAPSER_CLASS}`;
            collapseButton.style.background = `${this._headingCollapsed
                ? 'var(--jp-icon-caret-right)'
                : 'var(--jp-icon-caret-down)'} no-repeat center`;
            collapseButton.onclick = (event) => {
                this.headingCollapsed = !this.headingCollapsed;
                this._toggleCollapsedSignal.emit(this._headingCollapsed);
            };
        }
    }
    maybeCreateOrUpdateExpandButton() {
        var _a, _b;
        const expandButton = this.node.getElementsByClassName(SHOW_HIDDEN_CELLS_CLASS);
        // Create the "show hidden" button if not already created
        if (this.headingCollapsed &&
            expandButton.length === 0 &&
            this._numberChildNodes > 0) {
            const numberChildNodes = document.createElement('button');
            numberChildNodes.className = `bp3-button bp3-minimal jp-Button ${SHOW_HIDDEN_CELLS_CLASS}`;
            _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__.addIcon.render(numberChildNodes);
            const numberChildNodesText = document.createElement('div');
            numberChildNodesText.nodeValue = `${this._numberChildNodes} cell${this._numberChildNodes > 1 ? 's' : ''} hidden`;
            numberChildNodes.appendChild(numberChildNodesText);
            numberChildNodes.onclick = () => {
                this.headingCollapsed = false;
                this._toggleCollapsedSignal.emit(this._headingCollapsed);
            };
            this.node.appendChild(numberChildNodes);
        }
        else if (((_b = (_a = expandButton === null || expandButton === void 0 ? void 0 : expandButton[0]) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) > 1) {
            // If the heading is collapsed, update text
            if (this._headingCollapsed) {
                expandButton[0].childNodes[1].textContent = `${this._numberChildNodes} cell${this._numberChildNodes > 1 ? 's' : ''} hidden`;
                // If the heading isn't collapsed, remove the button
            }
            else {
                for (const el of expandButton) {
                    this.node.removeChild(el);
                }
            }
        }
    }
    /**
     * Render the collapse button for heading cells,
     * and for collapsed heading cells render the "expand hidden cells"
     * button.
     */
    renderCollapseButtons(widget) {
        this.node.classList.toggle(MARKDOWN_HEADING_COLLAPSED, this._headingCollapsed);
        this.maybeCreateCollapseButton();
        this.maybeCreateOrUpdateExpandButton();
    }
    /**
     * Render an input instead of the text editor.
     */
    renderInput(widget) {
        this.addClass(RENDERED_CLASS);
        this.renderCollapseButtons(widget);
        this.inputArea.renderInput(widget);
    }
    /**
     * Show the text editor instead of rendered input.
     */
    showEditor() {
        this.removeClass(RENDERED_CLASS);
        this.inputArea.showEditor();
    }
    /*
     * Handle `update-request` messages.
     */
    onUpdateRequest(msg) {
        // Make sure we are properly rendered.
        this._handleRendered();
        super.onUpdateRequest(msg);
    }
    /**
     * Modify the cell source to include a reference to the attachment.
     */
    updateCellSourceWithAttachment(attachmentName, URI) {
        var _a, _b;
        const textToBeAppended = `![${attachmentName}](attachment:${URI !== null && URI !== void 0 ? URI : attachmentName})`;
        (_b = (_a = this.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, textToBeAppended);
    }
    /**
     * Handle the rendered state.
     */
    _handleRendered() {
        if (!this._rendered) {
            this.showEditor();
        }
        else {
            // TODO: It would be nice for the cell to provide a way for
            // its consumers to hook into when the rendering is done.
            void this._updateRenderedInput();
            this.renderInput(this._renderer);
        }
    }
    /**
     * Update the rendered input.
     */
    _updateRenderedInput() {
        const model = this.model;
        const text = (model && model.value.text) || DEFAULT_MARKDOWN_TEXT;
        // Do not re-render if the text has not changed.
        if (text !== this._prevText) {
            const mimeModel = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__.MimeModel({ data: { 'text/markdown': text } });
            if (!this._renderer) {
                this._renderer = this._rendermime.createRenderer('text/markdown');
                this._renderer.addClass(MARKDOWN_OUTPUT_CLASS);
            }
            this._prevText = text;
            return this._renderer.renderModel(mimeModel);
        }
        return Promise.resolve(void 0);
    }
    /**
     * Clone the cell, using the same model.
     */
    clone() {
        const constructor = this.constructor;
        return new constructor({
            model: this.model,
            contentFactory: this.contentFactory,
            rendermime: this._rendermime,
            placeholder: false
        });
    }
}
/** ****************************************************************************
 * RawCell
 ******************************************************************************/
/**
 * A widget for a raw cell.
 */
class RawCell extends Cell {
    /**
     * Construct a raw cell widget.
     */
    constructor(options) {
        super(options);
        this.addClass(RAW_CELL_CLASS);
    }
    /**
     * Clone the cell, using the same model.
     */
    clone() {
        const constructor = this.constructor;
        return new constructor({
            model: this.model,
            contentFactory: this.contentFactory,
            placeholder: false
        });
    }
}
//# sourceMappingURL=widget.js.map

/***/ }),

/***/ 49634:
/*!*****************************************************************!*\
  !*** ../../node_modules/@jupyterlab/shared-models/lib/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertYMapEventToMapChange": () => (/* binding */ convertYMapEventToMapChange),
/* harmony export */   "createMutex": () => (/* binding */ createMutex)
/* harmony export */ });
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
function convertYMapEventToMapChange(event) {
    let changes = new Map();
    event.changes.keys.forEach((event, key) => {
        changes.set(key, {
            action: event.action,
            oldValue: event.oldValue,
            newValue: this.ymeta.get(key)
        });
    });
    return changes;
}
/**
 * Creates a mutual exclude function with the following property:
 *
 * ```js
 * const mutex = createMutex()
 * mutex(() => {
 *   // This function is immediately executed
 *   mutex(() => {
 *     // This function is not executed, as the mutex is already active.
 *   })
 * })
 * ```
 */
const createMutex = () => {
    let token = true;
    return (f) => {
        if (token) {
            token = false;
            try {
                f();
            }
            finally {
                token = true;
            }
        }
    };
};
//# sourceMappingURL=utils.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jupyterlab_cells_lib_index_js.30628979a21f4bb1d534.js.map