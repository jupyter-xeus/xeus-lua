{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/tooltip-extension/lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACsD;AACT;AACW;AACA;AACK;AACE;AACb;AACT;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gEAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA,kCAAkC,wDAAO,EAAE,qCAAqC;AAChF,oBAAoB,0DAAa;AACjC,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAe,EAAE,gEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qCAAqC;AAChF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAe,EAAE,kEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qCAAqC;AAChF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAe,EAAE,kEAAc,EAAE,uEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC,0DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qCAAqC;AAChF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC,0BAA0B;AAC3B,iC","file":"node_modules_jupyterlab_tooltip-extension_lib_index_js.06ff0c8b3d6cd2e4b76d.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module tooltip-extension\n */\nimport { IConsoleTracker } from '@jupyterlab/console';\nimport { Text } from '@jupyterlab/coreutils';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ITooltipManager, Tooltip } from '@jupyterlab/tooltip';\nimport { find, toArray } from '@lumino/algorithm';\nimport { Widget } from '@lumino/widgets';\n/**\n * The command IDs used by the tooltip plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.dismiss = 'tooltip:dismiss';\n    CommandIDs.launchConsole = 'tooltip:launch-console';\n    CommandIDs.launchNotebook = 'tooltip:launch-notebook';\n    CommandIDs.launchFile = 'tooltip:launch-file';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The main tooltip manager plugin.\n */\nconst manager = {\n    id: '@jupyterlab/tooltip-extension:manager',\n    autoStart: true,\n    provides: ITooltipManager,\n    activate: (app) => {\n        let tooltip = null;\n        // Add tooltip dismiss command.\n        app.commands.addCommand(CommandIDs.dismiss, {\n            execute: () => {\n                if (tooltip) {\n                    tooltip.dispose();\n                    tooltip = null;\n                }\n            }\n        });\n        return {\n            invoke(options) {\n                const detail = 0;\n                const { anchor, editor, kernel, rendermime } = options;\n                if (tooltip) {\n                    tooltip.dispose();\n                    tooltip = null;\n                }\n                return Private.fetch({ detail, editor, kernel })\n                    .then(bundle => {\n                    tooltip = new Tooltip({ anchor, bundle, editor, rendermime });\n                    Widget.attach(tooltip, document.body);\n                })\n                    .catch(() => {\n                    /* Fails silently. */\n                });\n            }\n        };\n    }\n};\n/**\n * The console tooltip plugin.\n */\nconst consoles = {\n    id: '@jupyterlab/tooltip-extension:consoles',\n    autoStart: true,\n    requires: [ITooltipManager, IConsoleTracker],\n    activate: (app, manager, consoles) => {\n        // Add tooltip launch command.\n        app.commands.addCommand(CommandIDs.launchConsole, {\n            execute: () => {\n                var _a, _b;\n                const parent = consoles.currentWidget;\n                if (!parent) {\n                    return;\n                }\n                const anchor = parent.console;\n                const editor = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor;\n                const kernel = (_b = anchor.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel;\n                const rendermime = anchor.rendermime;\n                // If all components necessary for rendering exist, create a tooltip.\n                if (!!editor && !!kernel && !!rendermime) {\n                    return manager.invoke({ anchor, editor, kernel, rendermime });\n                }\n            }\n        });\n    }\n};\n/**\n * The notebook tooltip plugin.\n */\nconst notebooks = {\n    id: '@jupyterlab/tooltip-extension:notebooks',\n    autoStart: true,\n    requires: [ITooltipManager, INotebookTracker],\n    activate: (app, manager, notebooks) => {\n        // Add tooltip launch command.\n        app.commands.addCommand(CommandIDs.launchNotebook, {\n            execute: () => {\n                var _a, _b;\n                const parent = notebooks.currentWidget;\n                if (!parent) {\n                    return;\n                }\n                const anchor = parent.content;\n                const editor = (_a = anchor.activeCell) === null || _a === void 0 ? void 0 : _a.editor;\n                const kernel = (_b = parent.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel;\n                const rendermime = anchor.rendermime;\n                // If all components necessary for rendering exist, create a tooltip.\n                if (!!editor && !!kernel && !!rendermime) {\n                    return manager.invoke({ anchor, editor, kernel, rendermime });\n                }\n            }\n        });\n    }\n};\n/**\n * The file editor tooltip plugin.\n */\nconst files = {\n    id: '@jupyterlab/tooltip-extension:files',\n    autoStart: true,\n    requires: [ITooltipManager, IEditorTracker, IRenderMimeRegistry],\n    activate: (app, manager, editorTracker, rendermime) => {\n        // Keep a list of active ISessions so that we can\n        // clean them up when they are no longer needed.\n        const activeSessions = {};\n        const sessions = app.serviceManager.sessions;\n        // When the list of running sessions changes,\n        // check to see if there are any kernels with a\n        // matching path for the file editors.\n        const onRunningChanged = (sender, models) => {\n            editorTracker.forEach(file => {\n                const model = find(models, m => file.context.path === m.path);\n                if (model) {\n                    const oldSession = activeSessions[file.id];\n                    // If there is a matching path, but it is the same\n                    // session as we previously had, do nothing.\n                    if (oldSession && oldSession.id === model.id) {\n                        return;\n                    }\n                    // Otherwise, dispose of the old session and reset to\n                    // a new CompletionConnector.\n                    if (oldSession) {\n                        delete activeSessions[file.id];\n                        oldSession.dispose();\n                    }\n                    const session = sessions.connectTo({ model });\n                    activeSessions[file.id] = session;\n                }\n                else {\n                    const session = activeSessions[file.id];\n                    if (session) {\n                        session.dispose();\n                        delete activeSessions[file.id];\n                    }\n                }\n            });\n        };\n        onRunningChanged(sessions, toArray(sessions.running()));\n        sessions.runningChanged.connect(onRunningChanged);\n        // Clean up after a widget when it is disposed\n        editorTracker.widgetAdded.connect((sender, widget) => {\n            widget.disposed.connect(w => {\n                const session = activeSessions[w.id];\n                if (session) {\n                    session.dispose();\n                    delete activeSessions[w.id];\n                }\n            });\n        });\n        // Add tooltip launch command.\n        app.commands.addCommand(CommandIDs.launchFile, {\n            execute: async () => {\n                const parent = editorTracker.currentWidget;\n                const kernel = parent &&\n                    activeSessions[parent.id] &&\n                    activeSessions[parent.id].kernel;\n                if (!kernel) {\n                    return;\n                }\n                const anchor = parent.content;\n                const editor = anchor === null || anchor === void 0 ? void 0 : anchor.editor;\n                // If all components necessary for rendering exist, create a tooltip.\n                if (!!editor && !!kernel && !!rendermime) {\n                    return manager.invoke({ anchor, editor, kernel, rendermime });\n                }\n            }\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    manager,\n    consoles,\n    notebooks,\n    files\n];\nexport default plugins;\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A counter for outstanding requests.\n     */\n    let pending = 0;\n    /**\n     * Fetch a tooltip's content from the API server.\n     */\n    function fetch(options) {\n        const { detail, editor, kernel } = options;\n        const code = editor.model.value.text;\n        const position = editor.getCursorPosition();\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), code);\n        // Clear hints if the new text value is empty or kernel is unavailable.\n        if (!code || !kernel) {\n            return Promise.reject(void 0);\n        }\n        const contents = {\n            code,\n            cursor_pos: offset,\n            detail_level: detail || 0\n        };\n        const current = ++pending;\n        return kernel.requestInspect(contents).then(msg => {\n            const value = msg.content;\n            // If a newer request is pending, bail.\n            if (current !== pending) {\n                return Promise.reject(void 0);\n            }\n            // If request fails or returns negative results, bail.\n            if (value.status !== 'ok' || !value.found) {\n                return Promise.reject(void 0);\n            }\n            return Promise.resolve(value.data);\n        });\n    }\n    Private.fetch = fetch;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}