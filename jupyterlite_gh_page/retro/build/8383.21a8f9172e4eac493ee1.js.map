{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/actions.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/default-toolbar.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/celllist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modelfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modestatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebooktools.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/panel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tracker.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/truststatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widgetfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shared-models/lib/utils.js"],"names":["JUPYTER_CELL_MIME","KernelError","Error","constructor","content","errorContent","errorName","ename","errorValue","evalue","super","this","traceback","Object","setPrototypeOf","prototype","NotebookActions","Private","executed","executionScheduled","selectionExecuted","setHeadingCollapse","cell","collapsing","notebook","which","findIndex","widgets","possibleCell","index","model","id","length","selectedHeadingInfo","getHeadingInfo","isHidden","MarkdownCell","isHeading","cellNum","localCollapsed","localCollapsedLevel","subCell","subCellHeadingInfo","headingLevel","setHidden","collapsed","numberChildNodes","setCellCollapse","level","headingInfo","headingCollapsed","splitCell","activeCell","state","getState","deselectAll","nbModel","activeCellIndex","child","editor","selections","getSelections","orig","value","text","offsets","start","end","i","getOffsetAt","push","clones","clone","cloneCell","type","outputs","clear","slice","replace","cells","beginCompoundOperation","set","insert","endCompoundOperation","activeCellDelta","focusedEditor","focus","setCursorPosition","line","lineCount","column","handleState","mergeCells","mergeAbove","toMerge","toDelete","primary","active","attachments","forEach","isSelectedOrActive","isRawCellModel","isMarkdownCellModel","key","keys","get","toJSON","cellModel","unshift","newModel","join","isCodeCellModel","fromJSON","removeValue","rendered","deleteCells","insertAbove","contentFactory","createCell","notebookConfig","defaultCell","insertBelow","moveDown","move","select","deselect","moveUp","changeCellType","run","sessionContext","Promise","resolve","promise","runSelected","handleRunState","runAndAdvance","mode","runAndInsert","runAll","renderAllMarkdown","previousIndex","runAllAbove","runAllBelow","replaceSelection","_a","_b","call","selectAbove","possibleNextCellIndex","possibleNextCell","inputHidden","selectBelow","maxCellIndex","extendSelectionAbove","toTop","extendContiguousSelectionTo","extendSelectionBelow","toBottom","selectAll","copy","copyOrCut","cut","paste","clipboard","Clipboard","hasData","values","getData","newCells","map","cell_type","createCodeCell","createMarkdownCell","createRawCell","deletable","metadata","reverse","remove","undo","sharedModel","redo","toggleAllLineNumbers","config","editorConfig","lineNumbers","code","markdown","raw","newConfig","assign","clearOutputs","each","clearExecution","outputHidden","clearAllOutputs","hideCode","showCode","hideAllCode","showAllCode","hideOutput","showOutput","hideAllOutputs","showAllOutputs","enableOutputScrolling","outputsScrolled","disableOutputScrolling","selectLastRunCell","latestTime","latestCellIdx","cellIndx","execution","JSONExt","undefined","timestamp","toString","startTime","Date","setMarkdownHeader","Math","min","max","collapseAll","expandAllHeadings","expandParent","nearestParentCell","childHeaderInfo","cellN","hInfo","findNearestParentHeader","findNextParentHeading","toggleCurrentHeadingCollapse","ElementExt","node","trust","translator","trans","nullTranslator","load","toArray","trusted","every","trustMessage","__","showDialog","body","buttons","Dialog","label","then","title","result","button","accept","wasFocused","contains","document","activeElement","scrollIfNeeded","activate","deletedCells","Signal","scroll","rect","inputArea","getBoundingClientRect","scrollToPosition","bottom","lastIndex","selected","filter","all","_c","emit","success","isTerminating","session","path","pendingInput","CodeCell","recordTiming","reply","splice","isDisposed","status","payload","setNextInput","source","newCell","ArrayExt","handlePayload","catch","reason","message","startsWith","error","ran","runCell","results","lastCell","update","executionCount","setPrompt","data","cellJSON","setData","newHeader","Array","matches","exec","ToolbarItems","createSaveButton","panel","onClick","context","readOnly","save","createCheckpoint","addToolbarButtonClass","ReactWidget","UseSignal","signal","fileChanged","ToolbarButtonComponent","icon","saveIcon","tooltip","enabled","contentsModel","writable","createInsertButton","ToolbarButton","addIcon","createCutButton","cutIcon","createCopyButton","copyIcon","createPasteButton","pasteIcon","createRunButton","runIcon","createRestartRunAllButton","dialogs","fastForwardIcon","sessionContextDialogs","restart","restarted","createCellTypeItem","CellTypeSwitcher","getDefaultItems","sessionDialogs","name","widget","Toolbar","handleChange","event","target","_notebook","handleKeyDown","keyCode","_trans","addClass","activeCellChanged","connect","selectionChanged","render","HTMLSelect","className","onChange","onKeyDown","CellList","modelDB","factory","_mutex","_isDisposed","_changed","_factory","_cellOrder","createList","_cellMap","ObservableMap","changed","_onOrderChanged","nbmodel","onSharedModelChanged","onModelDBChanged","self","change","transact","deleteCellRange","oldIndex","oldValues","newValues","insertLocation","newIndex","insertCells","switchSharedModel","from","currpos","cellsChange","delta","nbcell","insertAll","delete","removeRange","retain","iter","arr","ArrayIterator","dispose","fromIndex","toIndex","pushAll","startIndex","endIndex","canRedo","canUndo","isUndoAble","clearUndo","clearUndoHistory","order","existingCell","createValue","isStandalone","freshCell","NotebookModel","options","_dirty","_readOnly","_contentChanged","_stateChanged","_nbformat","_nbformatMinor","ModelDB","_isInitialized","isInitialized","defaultContentFactory","view","_cells","_onCellsChanged","createMap","has","languagePreference","_ensureMetadata","triggerContentChange","_deletedCells","newValue","oldValue","triggerStateChange","spec","info","JSON","stringify","fromString","parse","create","nbformat_minor","nbformat","useId","origNbformat","orig_nbformat","msg","dirty","initialize","list","contentChanged","display_name","args","ContentFactory","codeCellContentFactory","CodeCellModel","UUID","MarkdownCellModel","RawCellModel","NotebookModelFactory","_disposed","createNew","preferredLanguage","CommandEditComponent","props","TextItem","Text","notebookMode","CommandEditStatus","VDomRenderer","Model","VDomModel","arguments","_onChanged","oldMode","_notebookMode","_triggerChange","oldNotebook","stateChanged","disconnect","modelContentChanged","oldState","newState","RankedPanel","Widget","_items","layout","PanelLayout","addWidget","rank","rankItem","itemCmp","insertWidget","onChildRemoved","item","NotebookTools","_commonTools","_advancedTools","Collapse","_tracker","tracker","currentChanged","_onActiveNotebookPanelChanged","_onActiveCellChanged","_onSelectionChanged","currentWidget","addItem","tool","section","notebookTools","MessageLoop","ActiveNotebookPanelMessage","ActiveCellMessage","_prevActiveNotebookModel","_onActiveNotebookPanelMetadataChanged","activeNBModel","activeNotebookPanel","_toolChildren","_prevActiveCell","_onActiveCellMetadataChanged","SelectionMessage","sender","ObservableJSON","chain","children","ConflatableMessage","Tool","processMessage","onActiveNotebookPanelChanged","onActiveCellChanged","onSelectionChanged","onActiveCellMetadataChanged","onActiveNotebookPanelMetadataChanged","ActiveCellTool","_model","CodeEditor","count","_cellModel","_onValueChanged","mimeTypeChanged","_onMimeTypeChanged","promptNode","cloneNode","prompt","editorFactory","split","mimeType","editorWidget","CodeEditorWrapper","setOption","MetadataEditorTool","JSONEditor","titleNode","createElement","textContent","NotebookMetadataEditorTool","_update","nb","CellMetadataEditorTool","KeySelector","createSelectorNode","_getValue","_default","_setValue","_changeGuard","default","_validCellTypes","validCellTypes","_getter","getter","_setter","setter","getElementsByTagName","handleEvent","onValueChanged","onAfterAttach","selectNode","addEventListener","onBeforeDetach","removeEventListener","disabled","cellType","indexOf","createSlideShowSelector","optionValueArray","slide_type","createNBConvertSelector","first","second","toLocaleUpperCase","optionNodes","option","h","VirtualDOM","Styling","NB_CELL_CLASS","EDIT_CLASS","COMMAND_CLASS","ACTIVE_CLASS","SELECTED_CLASS","OTHER_SELECTED_CLASS","DROP_TARGET_CLASS","DROP_SOURCE_CLASS","DRAG_IMAGE_CLASS","CELL_DRAG_CONTENT_CLASS","CELL_DRAG_PROMPT_CLASS","CELL_DRAG_MULTIPLE_BACK","window","requestIdleCallback","handler","now","setTimeout","didTimeout","timeRemaining","cancelIdleCallback","clearTimeout","StaticNotebook","_editorConfig","defaultEditorConfig","_notebookConfig","defaultNotebookConfig","_mimetype","_modelChanged","_modelContentChanged","_fullyRendered","_placeholderCellRendered","_renderedCellsCount","dataset","rendermime","NotebookPanelLayout","_mimetypeService","mimeTypeService","_toRenderMap","Map","_cellsArray","_observer","IntersectionObserver","entries","observer","o","isIntersecting","unobserve","ci","_renderPlaceholderCell","root","threshold","rootMargin","observedTopMargin","observedBottomMargin","isCollaborative","connected","collaborators","_onCollaboratorsChanged","_onModelChanged","onModelChanged","_updateEditorConfig","_updateNotebookConfig","onModelContentChanged","onMetadataChanged","_updateMimetype","onCellInserted","onCellMoved","onCellRemoved","_removeCell","_insertCell","insertType","_moveCell","requestAnimationFrame","_createCodeCell","_createMarkdownCell","_createRawCell","numberCellsToRenderDirectly","placeholder","_createPlaceholderCell","observe","_incrementRenderedCount","renderCellOnIdle","renderPlaceholderCells","_renderPlaceholderCells","bind","timeout","deadline","pl","removeWidgetAt","updateEditorOnShow","maxNumberOutputs","syncCollapse","syncEditable","syncScrolled","innerHTML","parent","getMimeTypeByLanguage","editorOptions","setOptions","refresh","toggleClass","scrollPastEnd","size","lineWrap","matchBrackets","autoClosingBrackets","Cell","initializeState","RawCell","Notebook","processNotebookOptions","_activeCellIndex","_activeCell","_mode","_drag","_fragment","_dragData","_mouseMode","_activeCellChanged","_selectionChanged","_checkCacheOnNextResize","tabIndex","setAttribute","_ensureFocus","_trimSelections","selectedProperty","isSelected","head","anchor","getContiguousSelection","c","last","activeIndex","position","ar","top","height","abs","scrollTop","scrollToCell","setFragment","fragment","ready","eventPhase","Event","CAPTURING_PHASE","_evtContextMenuCapture","_evtMouseDownCapture","_evtMouseDown","currentTarget","_evtDocumentMouseup","_evtDocumentMousemove","_evtDblClick","_evtFocusIn","_evtFocusOut","_evtDragEnter","_evtDragLeave","_evtDragOver","_evtDrop","onAfterShow","onResize","cache","_cellLayoutStateCache","width","parseInt","style","w","onBeforeHide","onActivateRequest","onUpdateRequest","removeClass","el","querySelector","console","warn","scrollIntoView","localCollaborator","uuid","sessionId","selectionStyle","color","edgeRequested","_onEdgeRequest","location","prev","lastLine","force","hasFocus","_findCell","n","classList","parentElement","_findEventTargetAndCell","elementFromPoint","clientX","clientY","shiftKey","preventDefault","targetArea","hasSelection","getSelection","e","pressX","pressY","stopPropagation","dx","dy","_startDrag","mimeData","add","elements","getElementsByClassName","dropAction","proposedAction","toMove","nextParent","cellWidget","countString","dragImage","createDragImage","Drag","MimeData","supportedActions","action","relatedTarget","localName","toggle","AttachedProperty","promptNumber","cellContent","SEARCH_DOCUMENT_LOADED_CLASS","NotebookPanel","DocumentWidget","_autorestarting","toolbar","kernelChanged","_onKernelChanged","statusChanged","_onSessionStatusChanged","fullyRendered","_onFullyRendered","saveState","_onSave","revealed","includes","setConfig","kernelPreference","shutdownOnDispose","kernelShutdown","Printing","async","PageConfig","format","download","kernel","_updateLanguage","language_info","_updateSpec","language","createNotebook","IContentFactory","Token","INotebookWidgetFactory","INotebookTools","INotebookTracker","NotebookTracker","WidgetTracker","onCurrentChanged","NotebookTrustComponent","allCellsTrusted","trustedIcon","stylesheet","notTrustedIcon","NotebookTrustStatus","trustedCells","totalCells","activeCellTrusted","cellTrust","_trustedCells","_totalCells","_activeCellTrusted","_getAllState","total","_deriveCellTrustState","reduce","accum","current","NotebookWidgetFactory","ABCWidgetFactory","_sessionDialogs","createNewWidget","nbOptions","resolver","urlResolver","defaultToolbarFactory","createMutex","token","f"],"mappings":"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","file":"8383.21a8f9172e4eac493ee1.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Clipboard, Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCell, isCodeCellModel, isMarkdownCellModel, isRawCellModel, MarkdownCell } from '@jupyterlab/cells';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, each, findIndex, toArray } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Signal } from '@lumino/signaling';\nimport * as React from 'react';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\nexport class KernelError extends Error {\n    /**\n     * Construct the kernel error.\n     */\n    constructor(content) {\n        const errorContent = content;\n        const errorName = errorContent.ename;\n        const errorValue = errorContent.evalue;\n        super(`KernelReplyNotOK: ${errorName} ${errorValue}`);\n        this.errorName = errorName;\n        this.errorValue = errorValue;\n        this.traceback = errorContent.traceback;\n        Object.setPrototypeOf(this, KernelError.prototype);\n    }\n}\n/**\n * A collection of actions that run against notebooks.\n *\n * #### Notes\n * All of the actions are a no-op if there is no model on the notebook.\n * The actions set the widget `mode` to `'command'` unless otherwise specified.\n * The actions will preserve the selection on the notebook widget unless\n * otherwise specified.\n */\nexport class NotebookActions {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    static get executed() {\n        return Private.executed;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get executionScheduled() {\n        return Private.executionScheduled;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get selectionExecuted() {\n        return Private.selectionExecuted;\n    }\n    /**\n     * A private constructor for the `NotebookActions` class.\n     *\n     * #### Notes\n     * This class can never be instantiated. Its static member `executed` will be\n     * merged with the `NotebookActions` namespace. The reason it exists as a\n     * standalone class is because at run time, the `Private.executed` variable\n     * does not yet exist, so it needs to be referenced via a getter.\n     */\n    constructor() {\n        // Intentionally empty.\n    }\n}\n/**\n * A namespace for `NotebookActions` static methods.\n */\n(function (NotebookActions) {\n    /**\n     * Split the active cell into two or more cells.\n     *\n     * @param widget - The target notebook widget.\n     *\n     * #### Notes\n     * It will preserve the existing mode.\n     * The last cell will be activated if no selection is found.\n     * If text was selected, the cell containing the selection will\n       be activated.\n     * The existing selection will be cleared.\n     * The activated cell will have focus and the cursor will move\n       to the end of the cell.\n     * The leading whitespace in the second cell will be removed.\n     * If there is no content, two empty cells will be created.\n     * Both cells will have the same type as the original cell.\n     * This action can be undone.\n     */\n    function splitCell(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        const nbModel = notebook.model;\n        const index = notebook.activeCellIndex;\n        const child = notebook.widgets[index];\n        const editor = child.editor;\n        const selections = editor.getSelections();\n        const orig = child.model.value.text;\n        const offsets = [0];\n        let start = -1;\n        let end = -1;\n        for (let i = 0; i < selections.length; i++) {\n            // append start and end to handle selections\n            // cursors will have same start and end\n            start = editor.getOffsetAt(selections[i].start);\n            end = editor.getOffsetAt(selections[i].end);\n            if (start < end) {\n                offsets.push(start);\n                offsets.push(end);\n            }\n            else if (end < start) {\n                offsets.push(end);\n                offsets.push(start);\n            }\n            else {\n                offsets.push(start);\n            }\n        }\n        offsets.push(orig.length);\n        const clones = [];\n        for (let i = 0; i + 1 < offsets.length; i++) {\n            const clone = Private.cloneCell(nbModel, child.model);\n            clones.push(clone);\n        }\n        for (let i = 0; i < clones.length; i++) {\n            if (i !== clones.length - 1 && clones[i].type === 'code') {\n                clones[i].outputs.clear();\n            }\n            clones[i].value.text = orig\n                .slice(offsets[i], offsets[i + 1])\n                .replace(/^\\n+/, '')\n                .replace(/\\n+$/, '');\n        }\n        const cells = nbModel.cells;\n        cells.beginCompoundOperation();\n        for (let i = 0; i < clones.length; i++) {\n            if (i === 0) {\n                cells.set(index, clones[i]);\n            }\n            else {\n                cells.insert(index + i, clones[i]);\n            }\n        }\n        cells.endCompoundOperation();\n        // If there is a selection the selected cell will be activated\n        const activeCellDelta = start !== end ? 2 : 1;\n        notebook.activeCellIndex = index + clones.length - activeCellDelta;\n        const focusedEditor = notebook.activeCell.editor;\n        focusedEditor.focus();\n        // Move to the end of the cell that now contains the cursor\n        focusedEditor.setCursorPosition({ line: editor.lineCount, column: 0 });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.splitCell = splitCell;\n    /**\n     * Merge the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mergeAbove - If only one cell is selected, indicates whether to merge it\n     *    with the cell above (true) or below (false, default).\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * If only one cell is selected and `mergeAbove` is true, the above cell will be selected.\n     * If only one cell is selected and `mergeAbove` is false, the below cell will be selected.\n     * If the active cell is a code cell, its outputs will be cleared.\n     * This action can be undone.\n     * The final cell will have the same type as the active cell.\n     * If the active cell is a markdown cell, it will be unrendered.\n     */\n    function mergeCells(notebook, mergeAbove = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const toMerge = [];\n        const toDelete = [];\n        const model = notebook.model;\n        const cells = model.cells;\n        const primary = notebook.activeCell;\n        const active = notebook.activeCellIndex;\n        const attachments = {};\n        // Get the cells to merge.\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                toMerge.push(child.model.value.text);\n                if (index !== active) {\n                    toDelete.push(child.model);\n                }\n                // Collect attachments if the cell is a markdown cell or a raw cell\n                const model = child.model;\n                if (isRawCellModel(model) || isMarkdownCellModel(model)) {\n                    for (const key of model.attachments.keys) {\n                        attachments[key] = model.attachments.get(key).toJSON();\n                    }\n                }\n            }\n        });\n        // Check for only a single cell selected.\n        if (toMerge.length === 1) {\n            // Merge with the cell above when mergeAbove is true\n            if (mergeAbove === true) {\n                // Bail if it is the first cell.\n                if (active === 0) {\n                    return;\n                }\n                // Otherwise merge with the previous cell.\n                const cellModel = cells.get(active - 1);\n                toMerge.unshift(cellModel.value.text);\n                toDelete.push(cellModel);\n            }\n            else if (mergeAbove === false) {\n                // Bail if it is the last cell.\n                if (active === cells.length - 1) {\n                    return;\n                }\n                // Otherwise merge with the next cell.\n                const cellModel = cells.get(active + 1);\n                toMerge.push(cellModel.value.text);\n                toDelete.push(cellModel);\n            }\n        }\n        notebook.deselectAll();\n        // Create a new cell for the source to preserve history.\n        const newModel = Private.cloneCell(model, primary.model);\n        newModel.value.text = toMerge.join('\\n\\n');\n        if (isCodeCellModel(newModel)) {\n            newModel.outputs.clear();\n        }\n        else if (isMarkdownCellModel(newModel) || isRawCellModel(newModel)) {\n            newModel.attachments.fromJSON(attachments);\n        }\n        // Make the changes while preserving history.\n        cells.beginCompoundOperation();\n        cells.set(active, newModel);\n        toDelete.forEach(cell => {\n            cells.removeValue(cell);\n        });\n        cells.endCompoundOperation();\n        // If the original cell is a markdown cell, make sure\n        // the new cell is unrendered.\n        if (primary instanceof MarkdownCell) {\n            notebook.activeCell.rendered = false;\n        }\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.mergeCells = mergeCells;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.deleteCells(notebook);\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.deleteCells = deleteCells;\n    /**\n     * Insert a new code cell above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will the active cell.\n     */\n    function insertAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        const active = notebook.activeCellIndex;\n        model.cells.insert(active, cell);\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex = active;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertAbove = insertAbove;\n    /**\n     * Insert a new code cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will be the active cell.\n     */\n    function insertBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        model.cells.insert(notebook.activeCellIndex + 1, cell);\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex++;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertBelow = insertBelow;\n    /**\n     * Move the selected cell(s) down.\n     *\n     * @param notebook = The target notebook widget.\n     */\n    function moveDown(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        const widgets = notebook.widgets;\n        cells.beginCompoundOperation();\n        for (let i = cells.length - 2; i > -1; i--) {\n            if (notebook.isSelectedOrActive(widgets[i])) {\n                if (!notebook.isSelectedOrActive(widgets[i + 1])) {\n                    cells.move(i, i + 1);\n                    if (notebook.activeCellIndex === i) {\n                        notebook.activeCellIndex++;\n                    }\n                    notebook.select(widgets[i + 1]);\n                    notebook.deselect(widgets[i]);\n                }\n            }\n        }\n        cells.endCompoundOperation();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.moveDown = moveDown;\n    /**\n     * Move the selected cell(s) up.\n     *\n     * @param widget - The target notebook widget.\n     */\n    function moveUp(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        const widgets = notebook.widgets;\n        cells.beginCompoundOperation();\n        for (let i = 1; i < cells.length; i++) {\n            if (notebook.isSelectedOrActive(widgets[i])) {\n                if (!notebook.isSelectedOrActive(widgets[i - 1])) {\n                    cells.move(i, i - 1);\n                    if (notebook.activeCellIndex === i) {\n                        notebook.activeCellIndex--;\n                    }\n                    notebook.select(widgets[i - 1]);\n                    notebook.deselect(widgets[i]);\n                }\n            }\n        }\n        cells.endCompoundOperation();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.moveUp = moveUp;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.changeCellType(notebook, value);\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.changeCellType = changeCellType;\n    /**\n     * Run the selected cell(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The last selected cell will be activated, but not scrolled into view.\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     */\n    function run(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, false);\n        return promise;\n    }\n    NotebookActions.run = run;\n    /**\n     * Run the selected cell(s) and advance to the next cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * The cell after the last selected cell will be activated and scrolled into view.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * If the last selected cell is the last cell, a new code cell\n     * will be created in `'edit'` mode.  The new cell creation can be undone.\n     */\n    function runAndAdvance(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n            // Do not use push here, as we want an widget insertion\n            // to make sure no placeholder widget is rendered.\n            model.cells.insert(notebook.widgets.length, cell);\n            notebook.activeCellIndex++;\n            notebook.mode = 'edit';\n        }\n        else {\n            notebook.activeCellIndex++;\n        }\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndAdvance = runAndAdvance;\n    /**\n     * Run the selected cell(s) and insert a new code cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The widget mode will be set to `'edit'` after running.\n     * The existing selection will be cleared.\n     * The cell insert can be undone.\n     * The new cell will be scrolled into view.\n     */\n    function runAndInsert(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        model.cells.insert(notebook.activeCellIndex + 1, cell);\n        notebook.activeCellIndex++;\n        notebook.mode = 'edit';\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndInsert = runAndInsert;\n    /**\n     * Run all of the cells in the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAll(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAll = runAll;\n    function renderAllMarkdown(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const previousIndex = notebook.activeCellIndex;\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach((child, index) => {\n            if (child.model.type === 'markdown') {\n                notebook.select(child);\n                // This is to make sure that the activeCell\n                // does not get executed\n                notebook.activeCellIndex = index;\n            }\n        });\n        if (notebook.activeCell.model.type !== 'markdown') {\n            return Promise.resolve(true);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex = previousIndex;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.renderAllMarkdown = renderAllMarkdown;\n    /**\n     * Run all of the cells before the currently active cell (exclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The currently active cell will remain selected.\n     */\n    function runAllAbove(notebook, sessionContext) {\n        const { activeCell, activeCellIndex, model } = notebook;\n        if (!model || !activeCell || activeCellIndex < 1) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex--;\n        notebook.deselectAll();\n        for (let i = 0; i < notebook.activeCellIndex; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex++;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllAbove = runAllAbove;\n    /**\n     * Run all of the cells after the currently active cell (inclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAllBelow(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        for (let i = notebook.activeCellIndex; i < notebook.widgets.length; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllBelow = runAllBelow;\n    /**\n     * Replaces the selection in the active cell of the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     * @param text - The text to replace the selection.\n     */\n    function replaceSelection(notebook, text) {\n        var _a, _b;\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        (_b = (_a = notebook.activeCell.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, text);\n    }\n    NotebookActions.replaceSelection = replaceSelection;\n    /**\n     * Select the above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the first cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex - 1;\n        // find first non hidden cell above current cell\n        while (possibleNextCellIndex >= 0) {\n            const possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex -= 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectAbove = selectAbove;\n    /**\n     * Select the cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the last cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let maxCellIndex = notebook.widgets.length - 1;\n        // Find last non-hidden cell\n        while (notebook.widgets[maxCellIndex].isHidden ||\n            notebook.widgets[maxCellIndex].inputHidden) {\n            maxCellIndex -= 1;\n        }\n        if (notebook.activeCellIndex === maxCellIndex) {\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex + 1;\n        // find first non hidden cell below current cell\n        while (possibleNextCellIndex < maxCellIndex) {\n            let possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex += 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectBelow = selectBelow;\n    /**\n     * Extend the selection to the cell above.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toTop - If true, denotes selection to extend to the top.\n     *\n     * #### Notes\n     * This is a no-op if the first cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionAbove(notebook, toTop = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toTop is true, if yes, selection is made to the top.\n        if (toTop) {\n            notebook.extendContiguousSelectionTo(0);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex - 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionAbove = extendSelectionAbove;\n    /**\n     * Extend the selection to the cell below.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toBottom - If true, denotes selection to extend to the bottom.\n     *\n     * #### Notes\n     * This is a no-op if the last cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionBelow(notebook, toBottom = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toBottom is true, if yes selection is made to the bottom.\n        if (toBottom) {\n            notebook.extendContiguousSelectionTo(notebook.widgets.length - 1);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex + 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionBelow = extendSelectionBelow;\n    /**\n     * Select all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function selectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n    }\n    NotebookActions.selectAll = selectAll;\n    /**\n     * Deselect all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function deselectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.deselectAll();\n    }\n    NotebookActions.deselectAll = deselectAll;\n    /**\n     * Copy the selected cell data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function copy(notebook) {\n        Private.copyOrCut(notebook, false);\n    }\n    NotebookActions.copy = copy;\n    /**\n     * Cut the selected cell data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This action can be undone.\n     * A new code cell is added if all cells are cut.\n     */\n    function cut(notebook) {\n        Private.copyOrCut(notebook, true);\n    }\n    NotebookActions.cut = cut;\n    /**\n     * Paste cells from the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of the paste operation: 'below' pastes cells\n     *   below the active cell, 'above' pastes cells above the active cell,\n     *   and 'replace' removes the currently selected cells and pastes cells\n     *   in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function paste(notebook, mode = 'below') {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const clipboard = Clipboard.getInstance();\n        if (!clipboard.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const values = clipboard.getData(JUPYTER_CELL_MIME);\n        const model = notebook.model;\n        notebook.mode = 'command';\n        const newCells = values.map(cell => {\n            switch (cell.cell_type) {\n                case 'code':\n                    return model.contentFactory.createCodeCell({ cell });\n                case 'markdown':\n                    return model.contentFactory.createMarkdownCell({ cell });\n                default:\n                    return model.contentFactory.createRawCell({ cell });\n            }\n        });\n        const cells = notebook.model.cells;\n        let index;\n        cells.beginCompoundOperation();\n        // Set the starting index of the paste operation depending upon the mode.\n        switch (mode) {\n            case 'below':\n                index = notebook.activeCellIndex;\n                break;\n            case 'above':\n                index = notebook.activeCellIndex - 1;\n                break;\n            case 'replace': {\n                // Find the cells to delete.\n                const toDelete = [];\n                notebook.widgets.forEach((child, index) => {\n                    const deletable = child.model.metadata.get('deletable') !== false;\n                    if (notebook.isSelectedOrActive(child) && deletable) {\n                        toDelete.push(index);\n                    }\n                });\n                // If cells are not deletable, we may not have anything to delete.\n                if (toDelete.length > 0) {\n                    // Delete the cells as one undo event.\n                    toDelete.reverse().forEach(i => {\n                        cells.remove(i);\n                    });\n                }\n                index = toDelete[0];\n                break;\n            }\n            default:\n                break;\n        }\n        newCells.forEach(cell => {\n            cells.insert(++index, cell);\n        });\n        cells.endCompoundOperation();\n        notebook.activeCellIndex += newCells.length;\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.paste = paste;\n    /**\n     * Undo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if if there are no cell actions to undo.\n     */\n    function undo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.undo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.undo = undo;\n    /**\n     * Redo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if there are no cell actions to redo.\n     */\n    function redo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.redo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.redo = redo;\n    /**\n     * Toggle the line number of all cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The original state is based on the state of the active cell.\n     * The `mode` of the widget will be preserved.\n     */\n    function toggleAllLineNumbers(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const config = notebook.editorConfig;\n        const lineNumbers = !(config.code.lineNumbers &&\n            config.markdown.lineNumbers &&\n            config.raw.lineNumbers);\n        const newConfig = {\n            code: Object.assign(Object.assign({}, config.code), { lineNumbers }),\n            markdown: Object.assign(Object.assign({}, config.markdown), { lineNumbers }),\n            raw: Object.assign(Object.assign({}, config.raw), { lineNumbers })\n        };\n        notebook.editorConfig = newConfig;\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;\n    /**\n     * Clear the code outputs of the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        each(notebook.model.cells, (cell, index) => {\n            const child = notebook.widgets[index];\n            if (notebook.isSelectedOrActive(child) && cell.type === 'code') {\n                cell.clearExecution();\n                child.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearOutputs = clearOutputs;\n    /**\n     * Clear all the code outputs on the widget.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        each(notebook.model.cells, (cell, index) => {\n            const child = notebook.widgets[index];\n            if (cell.type === 'code') {\n                cell.clearExecution();\n                child.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearAllOutputs = clearAllOutputs;\n    /**\n     * Hide the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideCode = hideCode;\n    /**\n     * Show the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showCode = showCode;\n    /**\n     * Hide the code on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideAllCode = hideAllCode;\n    /**\n     * Show the code on all code cells.\n     *\n     * @param widget - The target notebook widget.\n     */\n    function showAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllCode = showAllCode;\n    /**\n     * Hide the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideOutput = hideOutput;\n    /**\n     * Show the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showOutput = showOutput;\n    /**\n     * Hide the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideAllOutputs = hideAllOutputs;\n    /**\n     * Show the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllOutputs = showAllOutputs;\n    /**\n     * Enable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function enableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.enableOutputScrolling = enableOutputScrolling;\n    /**\n     * Disable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function disableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.disableOutputScrolling = disableOutputScrolling;\n    /**\n     * Go to the last cell that is run or current if it is running.\n     *\n     * Note: This requires execution timing to be toggled on or this will have\n     * no effect.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function selectLastRunCell(notebook) {\n        let latestTime = null;\n        let latestCellIdx = null;\n        notebook.widgets.forEach((cell, cellIndx) => {\n            if (cell.model.type === 'code') {\n                const execution = cell.model.metadata.get('execution');\n                if (execution &&\n                    JSONExt.isObject(execution) &&\n                    execution['iopub.status.busy'] !== undefined) {\n                    // The busy status is used as soon as a request is received:\n                    // https://jupyter-client.readthedocs.io/en/stable/messaging.html\n                    const timestamp = execution['iopub.status.busy'].toString();\n                    if (timestamp) {\n                        const startTime = new Date(timestamp);\n                        if (!latestTime || startTime >= latestTime) {\n                            latestTime = startTime;\n                            latestCellIdx = cellIndx;\n                        }\n                    }\n                }\n            }\n        });\n        if (latestCellIdx !== null) {\n            notebook.activeCellIndex = latestCellIdx;\n        }\n    }\n    NotebookActions.selectLastRunCell = selectLastRunCell;\n    /**\n     * Set the markdown header level.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param level - The header level.\n     *\n     * #### Notes\n     * All selected cells will be switched to markdown.\n     * The level will be clamped between 1 and 6.\n     * If there is an existing header, it will be replaced.\n     * There will always be one blank space after the header.\n     * The cells will be unrendered.\n     */\n    function setMarkdownHeader(notebook, level) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        level = Math.min(Math.max(level, 1), 6);\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                Private.setMarkdownHeader(cells.get(index), level);\n            }\n        });\n        Private.changeCellType(notebook, 'markdown');\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.setMarkdownHeader = setMarkdownHeader;\n    /**\n     * Collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function collapseAll(notebook) {\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, true, notebook);\n                NotebookActions.setCellCollapse(cell, true);\n            }\n        }\n    }\n    NotebookActions.collapseAll = collapseAll;\n    /**\n     * Un-collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function expandAllHeadings(notebook) {\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, false, notebook);\n                // similar to collapseAll.\n                NotebookActions.setCellCollapse(cell, false);\n            }\n        }\n    }\n    NotebookActions.expandAllHeadings = expandAllHeadings;\n    function findNearestParentHeader(cell, notebook) {\n        const index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return;\n        }\n        // Finds the nearest header above the given cell. If the cell is a header itself, it does not return itself;\n        // this can be checked directly by calling functions.\n        if (index >= notebook.widgets.length) {\n            return;\n        }\n        let childHeaderInfo = getHeadingInfo(notebook.widgets[index]);\n        for (let cellN = index - 1; cellN >= 0; cellN--) {\n            if (cellN < notebook.widgets.length) {\n                let hInfo = getHeadingInfo(notebook.widgets[cellN]);\n                if (hInfo.isHeading &&\n                    hInfo.headingLevel < childHeaderInfo.headingLevel) {\n                    return notebook.widgets[cellN];\n                }\n            }\n        }\n        // else no parent header found.\n        return;\n    }\n    /**\n     * Finds the \"parent\" heading of the given cell and expands.\n     * Used for the case that a cell becomes active that is within a collapsed heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function expandParent(cell, notebook) {\n        let nearestParentCell = findNearestParentHeader(cell, notebook);\n        if (!nearestParentCell) {\n            return;\n        }\n        if (!getHeadingInfo(nearestParentCell).collapsed &&\n            !nearestParentCell.isHidden) {\n            return;\n        }\n        if (nearestParentCell.isHidden) {\n            expandParent(nearestParentCell, notebook);\n        }\n        if (getHeadingInfo(nearestParentCell).collapsed) {\n            setHeadingCollapse(nearestParentCell, false, notebook);\n        }\n    }\n    NotebookActions.expandParent = expandParent;\n    /**\n     * Finds the next heading that isn't a child of the given markdown heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function findNextParentHeading(cell, notebook) {\n        let index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return -1;\n        }\n        let childHeaderInfo = getHeadingInfo(cell);\n        for (index = index + 1; index < notebook.widgets.length; index++) {\n            let hInfo = getHeadingInfo(notebook.widgets[index]);\n            if (hInfo.isHeading &&\n                hInfo.headingLevel <= childHeaderInfo.headingLevel) {\n                return index;\n            }\n        }\n        // else no parent header found. return the index of the last cell\n        return notebook.widgets.length;\n    }\n    NotebookActions.findNextParentHeading = findNextParentHeading;\n    /**\n     * Set the given cell and ** all \"child\" cells **\n     * to the given collapse / expand if cell is\n     * a markdown header.\n     *\n     * @param cell - The cell\n     * @param collapsing - Whether to collapse or expand the cell\n     * @param notebook - The target notebook widget.\n     */\n    function setHeadingCollapse(cell, collapsing, notebook) {\n        const which = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (which === -1) {\n            return -1;\n        }\n        if (!notebook.widgets.length) {\n            return which + 1;\n        }\n        let selectedHeadingInfo = NotebookActions.getHeadingInfo(cell);\n        if (cell.isHidden ||\n            !(cell instanceof MarkdownCell) ||\n            !selectedHeadingInfo.isHeading) {\n            // otherwise collapsing and uncollapsing already hidden stuff can\n            // cause some funny looking bugs.\n            return which + 1;\n        }\n        let localCollapsed = false;\n        let localCollapsedLevel = 0;\n        // iterate through all cells after the active cell.\n        let cellNum;\n        for (cellNum = which + 1; cellNum < notebook.widgets.length; cellNum++) {\n            let subCell = notebook.widgets[cellNum];\n            let subCellHeadingInfo = NotebookActions.getHeadingInfo(subCell);\n            if (subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= selectedHeadingInfo.headingLevel) {\n                // then reached an equivalent or higher heading level than the\n                // original the end of the collapse.\n                cellNum -= 1;\n                break;\n            }\n            if (localCollapsed &&\n                subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= localCollapsedLevel) {\n                // then reached the end of the local collapsed, so unset NotebookActions.\n                localCollapsed = false;\n            }\n            if (collapsing || localCollapsed) {\n                // then no extra handling is needed for further locally collapsed\n                // headings.\n                subCell.setHidden(true);\n                continue;\n            }\n            if (subCellHeadingInfo.collapsed && subCellHeadingInfo.isHeading) {\n                localCollapsed = true;\n                localCollapsedLevel = subCellHeadingInfo.headingLevel;\n                // but don't collapse the locally collapsed heading, so continue to\n                // expand the heading. This will get noticed in the next round.\n            }\n            subCell.setHidden(false);\n        }\n        if (cellNum === notebook.widgets.length) {\n            cell.numberChildNodes = cellNum - which - 1;\n        }\n        else {\n            cell.numberChildNodes = cellNum - which;\n        }\n        NotebookActions.setCellCollapse(cell, collapsing);\n        return cellNum + 1;\n    }\n    NotebookActions.setHeadingCollapse = setHeadingCollapse;\n    /**\n     * Toggles the collapse state of the active cell of the given notebook\n     * and ** all of its \"child\" cells ** if the cell is a heading.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function toggleCurrentHeadingCollapse(notebook) {\n        if (!notebook.activeCell || notebook.activeCellIndex === undefined) {\n            return;\n        }\n        let headingInfo = NotebookActions.getHeadingInfo(notebook.activeCell);\n        if (headingInfo.isHeading) {\n            // Then toggle!\n            NotebookActions.setHeadingCollapse(notebook.activeCell, !headingInfo.collapsed, notebook);\n        }\n        ElementExt.scrollIntoViewIfNeeded(notebook.node, notebook.activeCell.node);\n    }\n    NotebookActions.toggleCurrentHeadingCollapse = toggleCurrentHeadingCollapse;\n    /**\n     * If cell is a markdown heading, sets the headingCollapsed field,\n     * and otherwise hides the cell.\n     *\n     * @param cell - The cell to collapse / expand\n     * @param collapsing - Whether to collapse or expand the given cell\n     */\n    function setCellCollapse(cell, collapsing) {\n        if (cell instanceof MarkdownCell) {\n            cell.headingCollapsed = collapsing;\n        }\n        else {\n            cell.setHidden(collapsing);\n        }\n    }\n    NotebookActions.setCellCollapse = setCellCollapse;\n    /**\n     * If given cell is a markdown heading, returns the heading level.\n     * If given cell is not markdown, returns 7 (there are only 6 levels of markdown headings)\n     *\n     * @param cell - The target cell widget.\n     */\n    function getHeadingInfo(cell) {\n        if (!(cell instanceof MarkdownCell)) {\n            return { isHeading: false, headingLevel: 7 };\n        }\n        let level = cell.headingInfo.level;\n        let collapsed = cell.headingCollapsed;\n        return { isHeading: level > 0, headingLevel: level, collapsed: collapsed };\n    }\n    NotebookActions.getHeadingInfo = getHeadingInfo;\n    /**\n     * Trust the notebook after prompting the user.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns a promise that resolves when the transaction is finished.\n     *\n     * #### Notes\n     * No dialog will be presented if the notebook is already trusted.\n     */\n    function trust(notebook, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        if (!notebook.model) {\n            return Promise.resolve();\n        }\n        // Do nothing if already trusted.\n        const cells = toArray(notebook.model.cells);\n        const trusted = cells.every(cell => cell.trusted);\n        // FIXME\n        const trustMessage = (React.createElement(\"p\", null,\n            trans.__('A trusted Jupyter notebook may execute hidden malicious code when you open it.'),\n            React.createElement(\"br\", null),\n            trans.__('Selecting trust will re-render this notebook in a trusted state.'),\n            React.createElement(\"br\", null),\n            trans.__('For more information, see the <a href=\"https://jupyter-server.readthedocs.io/en/stable/operators/security.html\">%1</a>', trans.__('Jupyter security documentation'))));\n        if (trusted) {\n            return showDialog({\n                body: trans.__('Notebook is already trusted'),\n                buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n            }).then(() => undefined);\n        }\n        return showDialog({\n            body: trustMessage,\n            title: trans.__('Trust this notebook?'),\n            buttons: [\n                Dialog.cancelButton({ label: trans.__('Cancel') }),\n                Dialog.warnButton({ label: trans.__('Ok') })\n            ] // FIXME?\n        }).then(result => {\n            if (result.button.accept) {\n                cells.forEach(cell => {\n                    cell.trusted = true;\n                });\n            }\n        });\n    }\n    NotebookActions.trust = trust;\n})(NotebookActions || (NotebookActions = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    Private.executed = new Signal({});\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    Private.executionScheduled = new Signal({});\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    Private.selectionExecuted = new Signal({});\n    /**\n     * Get the state of a widget before running an action.\n     */\n    function getState(notebook) {\n        return {\n            wasFocused: notebook.node.contains(document.activeElement),\n            activeCell: notebook.activeCell\n        };\n    }\n    Private.getState = getState;\n    /**\n     * Handle the state of a widget after running an action.\n     */\n    function handleState(notebook, state, scrollIfNeeded = false) {\n        const { activeCell, node } = notebook;\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scrollIfNeeded && activeCell) {\n            ElementExt.scrollIntoViewIfNeeded(node, activeCell.node);\n        }\n    }\n    Private.handleState = handleState;\n    /**\n     * Handle the state of a widget after running a run action.\n     */\n    function handleRunState(notebook, state, scroll = false) {\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scroll && state.activeCell) {\n            // Scroll to the top of the previous active cell output.\n            const rect = state.activeCell.inputArea.node.getBoundingClientRect();\n            notebook.scrollToPosition(rect.bottom, 45);\n        }\n    }\n    Private.handleRunState = handleRunState;\n    /**\n     * Clone a cell model.\n     */\n    function cloneCell(model, cell) {\n        switch (cell.type) {\n            case 'code':\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createCodeCell({ cell: cell.toJSON() });\n            case 'markdown':\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createMarkdownCell({ cell: cell.toJSON() });\n            default:\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createRawCell({ cell: cell.toJSON() });\n        }\n    }\n    Private.cloneCell = cloneCell;\n    /**\n     * Run the selected cells.\n     */\n    function runSelected(notebook, sessionContext) {\n        notebook.mode = 'command';\n        let lastIndex = notebook.activeCellIndex;\n        const selected = notebook.widgets.filter((child, index) => {\n            const active = notebook.isSelectedOrActive(child);\n            if (active) {\n                lastIndex = index;\n            }\n            return active;\n        });\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        return Promise.all(selected.map(child => runCell(notebook, child, sessionContext)))\n            .then(results => {\n            if (notebook.isDisposed) {\n                return false;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            // Post an update request.\n            notebook.update();\n            return results.every(result => result);\n        })\n            .catch(reason => {\n            if (reason.message.startsWith('KernelReplyNotOK')) {\n                selected.map(cell => {\n                    // Remove '*' prompt from cells that didn't execute\n                    if (cell.model.type === 'code' &&\n                        cell.model.executionCount == null) {\n                        cell.setPrompt('');\n                    }\n                });\n            }\n            else {\n                throw reason;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            notebook.update();\n            return false;\n        });\n    }\n    Private.runSelected = runSelected;\n    /**\n     * Run a cell.\n     */\n    function runCell(notebook, cell, sessionContext, translator) {\n        var _a, _b, _c;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        switch (cell.model.type) {\n            case 'markdown':\n                cell.rendered = true;\n                cell.inputHidden = false;\n                Private.executed.emit({ notebook, cell, success: true });\n                break;\n            case 'code':\n                if (sessionContext) {\n                    if (sessionContext.isTerminating) {\n                        void showDialog({\n                            title: trans.__('Kernel Terminating'),\n                            body: trans.__('The kernel for %1 appears to be terminating. You can not run any cell for now.', (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                        break;\n                    }\n                    if (sessionContext.pendingInput) {\n                        void showDialog({\n                            title: trans.__('Waiting on User Input'),\n                            body: trans.__('Did not run selected cell because there is a cell waiting on input! Submit your input and try again.'),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                        return Promise.resolve(false);\n                    }\n                    const deletedCells = (_c = (_b = notebook.model) === null || _b === void 0 ? void 0 : _b.deletedCells) !== null && _c !== void 0 ? _c : [];\n                    Private.executionScheduled.emit({ notebook, cell });\n                    return CodeCell.execute(cell, sessionContext, {\n                        deletedCells,\n                        recordTiming: notebook.notebookConfig.recordTiming\n                    })\n                        .then(reply => {\n                        deletedCells.splice(0, deletedCells.length);\n                        if (cell.isDisposed) {\n                            return false;\n                        }\n                        if (!reply) {\n                            return true;\n                        }\n                        if (reply.content.status === 'ok') {\n                            const content = reply.content;\n                            if (content.payload && content.payload.length) {\n                                handlePayload(content, notebook, cell);\n                            }\n                            return true;\n                        }\n                        else {\n                            throw new KernelError(reply.content);\n                        }\n                    })\n                        .catch(reason => {\n                        if (cell.isDisposed || reason.message.startsWith('Canceled')) {\n                            return false;\n                        }\n                        Private.executed.emit({ notebook, cell, success: false, error: reason });\n                        throw reason;\n                    })\n                        .then(ran => {\n                        if (ran) {\n                            Private.executed.emit({ notebook, cell, success: true });\n                        }\n                        return ran;\n                    });\n                }\n                cell.model.clearExecution();\n                break;\n            default:\n                break;\n        }\n        return Promise.resolve(true);\n    }\n    /**\n     * Handle payloads from an execute reply.\n     *\n     * #### Notes\n     * Payloads are deprecated and there are no official interfaces for them in\n     * the kernel type definitions.\n     * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).\n     */\n    function handlePayload(content, notebook, cell) {\n        var _a;\n        const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter(i => {\n            return i.source === 'set_next_input';\n        })[0];\n        if (!setNextInput) {\n            return;\n        }\n        const text = setNextInput.text;\n        const replace = setNextInput.replace;\n        if (replace) {\n            cell.model.value.text = text;\n            return;\n        }\n        // Create a new code cell and add as the next cell.\n        const newCell = notebook.model.contentFactory.createCodeCell({});\n        const cells = notebook.model.cells;\n        const index = ArrayExt.firstIndexOf(toArray(cells), cell.model);\n        newCell.value.text = text;\n        if (index === -1) {\n            cells.push(newCell);\n        }\n        else {\n            cells.insert(index + 1, newCell);\n        }\n    }\n    /**\n     * Copy or cut the selected cell data to the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param cut - Whether to copy or cut.\n     */\n    function copyOrCut(notebook, cut) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = getState(notebook);\n        const clipboard = Clipboard.getInstance();\n        notebook.mode = 'command';\n        clipboard.clear();\n        const data = notebook.widgets\n            .filter(cell => notebook.isSelectedOrActive(cell))\n            .map(cell => cell.model.toJSON())\n            .map(cellJSON => {\n            if (cellJSON.metadata.deletable !== undefined) {\n                delete cellJSON.metadata.deletable;\n            }\n            return cellJSON;\n        });\n        clipboard.setData(JUPYTER_CELL_MIME, data);\n        if (cut) {\n            deleteCells(notebook);\n        }\n        else {\n            notebook.deselectAll();\n        }\n        handleState(notebook, state);\n    }\n    Private.copyOrCut = copyOrCut;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        const model = notebook.model;\n        const cells = model.cells;\n        cells.beginCompoundOperation();\n        notebook.widgets.forEach((child, index) => {\n            if (!notebook.isSelectedOrActive(child)) {\n                return;\n            }\n            if (child.model.type !== value) {\n                const cell = child.model.toJSON();\n                let newCell;\n                switch (value) {\n                    case 'code':\n                        newCell = model.contentFactory.createCodeCell({ cell });\n                        break;\n                    case 'markdown':\n                        newCell = model.contentFactory.createMarkdownCell({ cell });\n                        if (child.model.type === 'code') {\n                            newCell.trusted = false;\n                        }\n                        break;\n                    default:\n                        newCell = model.contentFactory.createRawCell({ cell });\n                        if (child.model.type === 'code') {\n                            newCell.trusted = false;\n                        }\n                }\n                cells.set(index, newCell);\n            }\n            if (value === 'markdown') {\n                // Fetch the new widget and unrender it.\n                child = notebook.widgets[index];\n                child.rendered = false;\n            }\n        });\n        cells.endCompoundOperation();\n        notebook.deselectAll();\n    }\n    Private.changeCellType = changeCellType;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * If the last cell is deleted, then the previous one will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        const model = notebook.model;\n        const cells = model.cells;\n        const toDelete = [];\n        notebook.mode = 'command';\n        // Find the cells to delete.\n        notebook.widgets.forEach((child, index) => {\n            const deletable = child.model.metadata.get('deletable') !== false;\n            if (notebook.isSelectedOrActive(child) && deletable) {\n                toDelete.push(index);\n                model.deletedCells.push(child.model.id);\n            }\n        });\n        // If cells are not deletable, we may not have anything to delete.\n        if (toDelete.length > 0) {\n            // Delete the cells as one undo event.\n            cells.beginCompoundOperation();\n            // Delete cells in reverse order to maintain the correct indices.\n            toDelete.reverse().forEach(index => {\n                cells.remove(index);\n            });\n            // Add a new cell if the notebook is empty. This is done\n            // within the compound operation to make the deletion of\n            // a notebook's last cell undoable.\n            if (!cells.length) {\n                cells.push(model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {}));\n            }\n            cells.endCompoundOperation();\n            // Select the *first* interior cell not deleted or the cell\n            // *after* the last selected cell.\n            // Note: The activeCellIndex is clamped to the available cells,\n            // so if the last cell is deleted the previous cell will be activated.\n            // The *first* index is the index of the last cell in the initial\n            // toDelete list due to the `reverse` operation above.\n            notebook.activeCellIndex = toDelete[0] - toDelete.length + 1;\n        }\n        // Deselect any remaining, undeletable cells. Do this even if we don't\n        // delete anything so that users are aware *something* happened.\n        notebook.deselectAll();\n    }\n    Private.deleteCells = deleteCells;\n    /**\n     * Set the markdown header level of a cell.\n     */\n    function setMarkdownHeader(cell, level) {\n        // Remove existing header or leading white space.\n        let source = cell.value.text;\n        const regex = /^(#+\\s*)|^(\\s*)/;\n        const newHeader = Array(level + 1).join('#') + ' ';\n        const matches = regex.exec(source);\n        if (matches) {\n            source = source.slice(matches[0].length);\n        }\n        cell.value.text = newHeader + source;\n    }\n    Private.setMarkdownHeader = setMarkdownHeader;\n})(Private || (Private = {}));\n//# sourceMappingURL=actions.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { addToolbarButtonClass, Dialog, ReactWidget, sessionContextDialogs, showDialog, Toolbar, ToolbarButton, ToolbarButtonComponent, UseSignal } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { addIcon, copyIcon, cutIcon, fastForwardIcon, HTMLSelect, pasteIcon, runIcon, saveIcon } from '@jupyterlab/ui-components';\nimport * as React from 'react';\nimport { NotebookActions } from './actions';\n/**\n * The class name added to toolbar cell type dropdown wrapper.\n */\nconst TOOLBAR_CELLTYPE_CLASS = 'jp-Notebook-toolbarCellType';\n/**\n * The class name added to toolbar cell type dropdown.\n */\nconst TOOLBAR_CELLTYPE_DROPDOWN_CLASS = 'jp-Notebook-toolbarCellTypeDropdown';\n/**\n * A namespace for the default toolbar items.\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create save button toolbar item.\n     */\n    function createSaveButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        function onClick() {\n            if (panel.context.model.readOnly) {\n                return showDialog({\n                    title: trans.__('Cannot Save'),\n                    body: trans.__('Document is read-only'),\n                    buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                });\n            }\n            void panel.context.save(true).then(() => {\n                if (!panel.isDisposed) {\n                    return panel.context.createCheckpoint();\n                }\n            });\n        }\n        return addToolbarButtonClass(ReactWidget.create(React.createElement(UseSignal, { signal: panel.context.fileChanged }, () => (React.createElement(ToolbarButtonComponent, { icon: saveIcon, onClick: onClick, tooltip: trans.__('Save the notebook contents and create checkpoint'), enabled: !!(panel &&\n                panel.context &&\n                panel.context.contentsModel &&\n                panel.context.contentsModel.writable) })))));\n    }\n    ToolbarItems.createSaveButton = createSaveButton;\n    /**\n     * Create an insert toolbar item.\n     */\n    function createInsertButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: addIcon,\n            onClick: () => {\n                NotebookActions.insertBelow(panel.content);\n            },\n            tooltip: trans.__('Insert a cell below')\n        });\n    }\n    ToolbarItems.createInsertButton = createInsertButton;\n    /**\n     * Create a cut toolbar item.\n     */\n    function createCutButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: cutIcon,\n            onClick: () => {\n                NotebookActions.cut(panel.content);\n            },\n            tooltip: trans.__('Cut the selected cells')\n        });\n    }\n    ToolbarItems.createCutButton = createCutButton;\n    /**\n     * Create a copy toolbar item.\n     */\n    function createCopyButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: copyIcon,\n            onClick: () => {\n                NotebookActions.copy(panel.content);\n            },\n            tooltip: trans.__('Copy the selected cells')\n        });\n    }\n    ToolbarItems.createCopyButton = createCopyButton;\n    /**\n     * Create a paste toolbar item.\n     */\n    function createPasteButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: pasteIcon,\n            onClick: () => {\n                NotebookActions.paste(panel.content);\n            },\n            tooltip: trans.__('Paste cells from the clipboard')\n        });\n    }\n    ToolbarItems.createPasteButton = createPasteButton;\n    /**\n     * Create a run toolbar item.\n     */\n    function createRunButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: runIcon,\n            onClick: () => {\n                void NotebookActions.runAndAdvance(panel.content, panel.sessionContext);\n            },\n            tooltip: trans.__('Run the selected cells and advance')\n        });\n    }\n    ToolbarItems.createRunButton = createRunButton;\n    /**\n     * Create a restart run all toolbar item\n     */\n    function createRestartRunAllButton(panel, dialogs, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: fastForwardIcon,\n            onClick: () => {\n                void (dialogs !== null && dialogs !== void 0 ? dialogs : sessionContextDialogs)\n                    .restart(panel.sessionContext, translator)\n                    .then(restarted => {\n                    if (restarted) {\n                        void NotebookActions.runAll(panel.content, panel.sessionContext);\n                    }\n                    return restarted;\n                });\n            },\n            tooltip: trans.__('Restart the kernel, then re-run the whole notebook')\n        });\n    }\n    ToolbarItems.createRestartRunAllButton = createRestartRunAllButton;\n    /**\n     * Create a cell type switcher item.\n     *\n     * #### Notes\n     * It will display the type of the current active cell.\n     * If more than one cell is selected but are of different types,\n     * it will display `'-'`.\n     * When the user changes the cell type, it will change the\n     * cell types of the selected cells.\n     * It can handle a change to the context.\n     */\n    function createCellTypeItem(panel, translator) {\n        return new CellTypeSwitcher(panel.content, translator);\n    }\n    ToolbarItems.createCellTypeItem = createCellTypeItem;\n    /**\n     * Get the default toolbar items for panel\n     */\n    function getDefaultItems(panel, sessionDialogs, translator) {\n        return [\n            { name: 'save', widget: createSaveButton(panel, translator) },\n            { name: 'insert', widget: createInsertButton(panel, translator) },\n            { name: 'cut', widget: createCutButton(panel, translator) },\n            { name: 'copy', widget: createCopyButton(panel, translator) },\n            { name: 'paste', widget: createPasteButton(panel, translator) },\n            { name: 'run', widget: createRunButton(panel, translator) },\n            {\n                name: 'interrupt',\n                widget: Toolbar.createInterruptButton(panel.sessionContext, translator)\n            },\n            {\n                name: 'restart',\n                widget: Toolbar.createRestartButton(panel.sessionContext, sessionDialogs, translator)\n            },\n            {\n                name: 'restart-and-run',\n                widget: createRestartRunAllButton(panel, sessionDialogs, translator)\n            },\n            { name: 'cellType', widget: createCellTypeItem(panel, translator) },\n            { name: 'spacer', widget: Toolbar.createSpacerItem() },\n            {\n                name: 'kernelName',\n                widget: Toolbar.createKernelNameItem(panel.sessionContext, sessionDialogs, translator)\n            },\n            {\n                name: 'kernelStatus',\n                widget: Toolbar.createKernelStatusItem(panel.sessionContext, translator)\n            }\n        ];\n    }\n    ToolbarItems.getDefaultItems = getDefaultItems;\n})(ToolbarItems || (ToolbarItems = {}));\n/**\n * A toolbar widget that switches cell types.\n */\nexport class CellTypeSwitcher extends ReactWidget {\n    /**\n     * Construct a new cell type switcher.\n     */\n    constructor(widget, translator) {\n        super();\n        /**\n         * Handle `change` events for the HTMLSelect component.\n         */\n        this.handleChange = (event) => {\n            if (event.target.value !== '-') {\n                NotebookActions.changeCellType(this._notebook, event.target.value);\n                this._notebook.activate();\n            }\n        };\n        /**\n         * Handle `keydown` events for the HTMLSelect component.\n         */\n        this.handleKeyDown = (event) => {\n            if (event.keyCode === 13) {\n                this._notebook.activate();\n            }\n        };\n        this._trans = (translator || nullTranslator).load('jupyterlab');\n        this.addClass(TOOLBAR_CELLTYPE_CLASS);\n        this._notebook = widget;\n        if (widget.model) {\n            this.update();\n        }\n        widget.activeCellChanged.connect(this.update, this);\n        // Follow a change in the selection.\n        widget.selectionChanged.connect(this.update, this);\n    }\n    render() {\n        let value = '-';\n        if (this._notebook.activeCell) {\n            value = this._notebook.activeCell.model.type;\n        }\n        for (const widget of this._notebook.widgets) {\n            if (this._notebook.isSelectedOrActive(widget)) {\n                if (widget.model.type !== value) {\n                    value = '-';\n                    break;\n                }\n            }\n        }\n        return (React.createElement(HTMLSelect, { className: TOOLBAR_CELLTYPE_DROPDOWN_CLASS, onChange: this.handleChange, onKeyDown: this.handleKeyDown, value: value, \"aria-label\": this._trans.__('Cell type'), title: this._trans.__('Select the cell type') },\n            React.createElement(\"option\", { value: \"-\" }, \"-\"),\n            React.createElement(\"option\", { value: \"code\" }, this._trans.__('Code')),\n            React.createElement(\"option\", { value: \"markdown\" }, this._trans.__('Markdown')),\n            React.createElement(\"option\", { value: \"raw\" }, this._trans.__('Raw'))));\n    }\n}\n//# sourceMappingURL=default-toolbar.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ObservableMap } from '@jupyterlab/observables';\nimport * as models from '@jupyterlab/shared-models';\nimport { ArrayExt, ArrayIterator, each, toArray } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\n/**\n * A cell list object that supports undo/redo.\n */\nexport class CellList {\n    /**\n     * Construct the cell list.\n     */\n    constructor(modelDB, factory, model) {\n        /**\n         * Prevents that the modeldb event handler is executed when the shared-model event handler is executed and vice-versa.\n         */\n        this._mutex = models.createMutex();\n        this._isDisposed = false;\n        this._changed = new Signal(this);\n        this._factory = factory;\n        this._cellOrder = modelDB.createList('cellOrder');\n        this._cellMap = new ObservableMap();\n        this._cellOrder.changed.connect(this._onOrderChanged, this);\n        this.nbmodel = model;\n        this.nbmodel.changed.connect(this.onSharedModelChanged, this);\n        this.changed.connect(this.onModelDBChanged, this);\n    }\n    onModelDBChanged(self, change) {\n        this._mutex(() => {\n            const nbmodel = this.nbmodel;\n            nbmodel.transact(() => {\n                if (change.type === 'set' || change.type === 'remove') {\n                    nbmodel.deleteCellRange(change.oldIndex, change.oldIndex + change.oldValues.length);\n                }\n                if (change.type === 'set' ||\n                    change.type === 'add' ||\n                    change.type === 'move') {\n                    const cells = change.newValues.map(cell => {\n                        return cell.sharedModel.clone();\n                    });\n                    let insertLocation = change.newIndex;\n                    if (change.type === 'move' && insertLocation > change.oldIndex) {\n                        insertLocation += change.oldValues.length;\n                    }\n                    nbmodel.insertCells(insertLocation, cells);\n                    change.newValues.forEach((cell, index) => {\n                        cell.switchSharedModel(cells[index], false);\n                    });\n                }\n                if (change.type === 'move') {\n                    let from = change.oldIndex;\n                    if (from >= change.newIndex) {\n                        from += change.oldValues.length;\n                    }\n                    nbmodel.deleteCellRange(from, from + change.oldValues.length);\n                }\n            });\n        });\n    }\n    onSharedModelChanged(self, change) {\n        this._mutex(() => {\n            var _a;\n            let currpos = 0;\n            (_a = change.cellsChange) === null || _a === void 0 ? void 0 : _a.forEach(delta => {\n                if (delta.insert != null) {\n                    const cells = delta.insert.map(nbcell => {\n                        const cell = this._factory.createCell(nbcell.cell_type, {});\n                        cell.switchSharedModel(nbcell, true);\n                        return cell;\n                    });\n                    this.insertAll(currpos, cells);\n                    currpos += delta.insert.length;\n                }\n                else if (delta.delete != null) {\n                    this.removeRange(currpos, currpos + delta.delete);\n                }\n                else if (delta.retain != null) {\n                    currpos += delta.retain;\n                }\n            });\n        });\n    }\n    /**\n     * A signal emitted when the cell list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Test whether the cell list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Test whether the list is empty.\n     *\n     * @returns `true` if the cell list is empty, `false` otherwise.\n     *\n     * #### Notes\n     * This is a read-only property.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    get isEmpty() {\n        return this._cellOrder.length === 0;\n    }\n    /**\n     * Get the length of the cell list.\n     *\n     * @return The number of cells in the cell list.\n     *\n     * #### Notes\n     * This is a read-only property.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    get length() {\n        return this._cellOrder.length;\n    }\n    /**\n     * Create an iterator over the cells in the cell list.\n     *\n     * @returns A new iterator starting at the front of the cell list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    iter() {\n        const arr = [];\n        for (const id of toArray(this._cellOrder)) {\n            arr.push(this._cellMap.get(id));\n        }\n        return new ArrayIterator(arr);\n    }\n    /**\n     * Dispose of the resources held by the cell list.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        // Clean up the cell map and cell order objects.\n        for (const cell of this._cellMap.values()) {\n            cell.dispose();\n        }\n        this._cellMap.dispose();\n        this._cellOrder.dispose();\n    }\n    /**\n     * Get the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The cell at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    get(index) {\n        return this._cellMap.get(this._cellOrder.get(index));\n    }\n    /**\n     * Set the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @param cell - The cell to set at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    set(index, cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        this._cellOrder.set(index, cell.id);\n    }\n    /**\n     * Add a cell to the back of the cell list.\n     *\n     * @param cell - The cell to add to the back of the cell list.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    push(cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        const num = this._cellOrder.push(cell.id);\n        return num;\n    }\n    /**\n     * Insert a cell into the cell list at a specific index.\n     *\n     * @param index - The index at which to insert the cell.\n     *\n     * @param cell - The cell to set at the specified index.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the cell list.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    insert(index, cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        this._cellOrder.insert(index, cell.id);\n    }\n    /**\n     * Remove the first occurrence of a cell from the cell list.\n     *\n     * @param cell - The cell of interest.\n     *\n     * @returns The index of the removed cell, or `-1` if the cell\n     *   is not contained in the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed cell and beyond are invalidated.\n     */\n    removeValue(cell) {\n        const index = ArrayExt.findFirstIndex(toArray(this._cellOrder), id => this._cellMap.get(id) === cell);\n        this.remove(index);\n        return index;\n    }\n    /**\n     * Remove and return the cell at a specific index.\n     *\n     * @param index - The index of the cell of interest.\n     *\n     * @returns The cell at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed cell and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    remove(index) {\n        const id = this._cellOrder.get(index);\n        this._cellOrder.remove(index);\n        const cell = this._cellMap.get(id);\n        return cell;\n    }\n    /**\n     * Remove all cells from the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * All current iterators are invalidated.\n     */\n    clear() {\n        this._cellOrder.clear();\n    }\n    /**\n     * Move a cell from one index to another.\n     *\n     * @parm fromIndex - The index of the element to move.\n     *\n     * @param toIndex - The index to move the element to.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`\n     * and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or a `toIndex` which is non-integral.\n     */\n    move(fromIndex, toIndex) {\n        this._cellOrder.move(fromIndex, toIndex);\n    }\n    /**\n     * Push a set of cells to the back of the cell list.\n     *\n     * @param cells - An iterable or array-like set of cells to add.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cells to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    pushAll(cells) {\n        const newValues = toArray(cells);\n        each(newValues, cell => {\n            // Set the internal data structures.\n            this._cellMap.set(cell.id, cell);\n            this._cellOrder.push(cell.id);\n        });\n        return this.length;\n    }\n    /**\n     * Insert a set of items into the cell list at the specified index.\n     *\n     * @param index - The index at which to insert the cells.\n     *\n     * @param cells - The cells to insert at the specified index.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity.\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the cell list.\n     *\n     * #### Undefined Behavior.\n     * An `index` which is non-integral.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cells to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    insertAll(index, cells) {\n        const newValues = toArray(cells);\n        each(newValues, cell => {\n            this._cellMap.set(cell.id, cell);\n            // @todo it looks like this compound operation shoult start before the `each` loop.\n            this._cellOrder.beginCompoundOperation();\n            this._cellOrder.insert(index++, cell.id);\n            this._cellOrder.endCompoundOperation();\n        });\n        return this.length;\n    }\n    /**\n     * Remove a range of items from the cell list.\n     *\n     * @param startIndex - The start index of the range to remove (inclusive).\n     *\n     * @param endIndex - The end index of the range to remove (exclusive).\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing to the first removed cell and beyond are invalid.\n     *\n     * #### Undefined Behavior\n     * A `startIndex` or `endIndex` which is non-integral.\n     */\n    removeRange(startIndex, endIndex) {\n        this._cellOrder.removeRange(startIndex, endIndex);\n        return this.length;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    get canRedo() {\n        return this.nbmodel.canRedo();\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    get canUndo() {\n        return this.nbmodel.canUndo();\n    }\n    /**\n     * Begin a compound operation.\n     *\n     * @param isUndoAble - Whether the operation is undoable.\n     *   The default is `true`.\n     */\n    beginCompoundOperation(isUndoAble) {\n        this._cellOrder.beginCompoundOperation(isUndoAble);\n    }\n    /**\n     * End a compound operation.\n     */\n    endCompoundOperation() {\n        this._cellOrder.endCompoundOperation();\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        this.nbmodel.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        this.nbmodel.redo();\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndo() {\n        this.nbmodel.clearUndoHistory();\n    }\n    _onOrderChanged(order, change) {\n        if (change.type === 'add' || change.type === 'set') {\n            each(change.newValues, id => {\n                const existingCell = this._cellMap.get(id);\n                if (existingCell == null) {\n                    const cellDB = this._factory.modelDB;\n                    const cellType = cellDB.createValue(id + '.type');\n                    let cell;\n                    switch (cellType.get()) {\n                        case 'code':\n                            cell = this._factory.createCodeCell({ id: id });\n                            break;\n                        case 'markdown':\n                            cell = this._factory.createMarkdownCell({ id: id });\n                            break;\n                        default:\n                            cell = this._factory.createRawCell({ id: id });\n                            break;\n                    }\n                    this._cellMap.set(id, cell);\n                }\n                else if (!existingCell.sharedModel.isStandalone) {\n                    this._mutex(() => {\n                        // it does already exist, probably because it was deleted previously and we introduced it\n                        // copy it to a fresh codecell instance\n                        const cell = existingCell.toJSON();\n                        let freshCell = null;\n                        switch (cell.cell_type) {\n                            case 'code':\n                                freshCell = this._factory.createCodeCell({ cell });\n                                break;\n                            case 'markdown':\n                                freshCell = this._factory.createMarkdownCell({ cell });\n                                break;\n                            default:\n                                freshCell = this._factory.createRawCell({ cell });\n                                break;\n                        }\n                        this._cellMap.set(id, freshCell);\n                    });\n                }\n            });\n        }\n        const newValues = [];\n        const oldValues = [];\n        each(change.newValues, id => {\n            newValues.push(this._cellMap.get(id));\n        });\n        each(change.oldValues, id => {\n            oldValues.push(this._cellMap.get(id));\n        });\n        this._changed.emit({\n            type: change.type,\n            oldIndex: change.oldIndex,\n            newIndex: change.newIndex,\n            oldValues,\n            newValues\n        });\n    }\n}\n//# sourceMappingURL=celllist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCellModel, MarkdownCellModel, RawCellModel } from '@jupyterlab/cells';\nimport * as nbformat from '@jupyterlab/nbformat';\nimport { ModelDB } from '@jupyterlab/observables';\nimport * as models from '@jupyterlab/shared-models';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { CellList } from './celllist';\n/**\n * An implementation of a notebook Model.\n */\nexport class NotebookModel {\n    /**\n     * Construct a new notebook model.\n     */\n    constructor(options = {}) {\n        /**\n         * The shared notebook model.\n         */\n        this.sharedModel = models.YNotebook.create();\n        this._dirty = false;\n        this._readOnly = false;\n        this._contentChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._nbformat = nbformat.MAJOR_VERSION;\n        this._nbformatMinor = nbformat.MINOR_VERSION;\n        this._isDisposed = false;\n        if (options.modelDB) {\n            this.modelDB = options.modelDB;\n        }\n        else {\n            this.modelDB = new ModelDB();\n        }\n        this._isInitialized = options.isInitialized === false ? false : true;\n        const factory = options.contentFactory || NotebookModel.defaultContentFactory;\n        this.contentFactory = factory.clone(this.modelDB.view('cells'));\n        this._cells = new CellList(this.modelDB, this.contentFactory, this.sharedModel);\n        this._trans = (options.translator || nullTranslator).load('jupyterlab');\n        this._cells.changed.connect(this._onCellsChanged, this);\n        // Handle initial metadata.\n        const metadata = this.modelDB.createMap('metadata');\n        if (!metadata.has('language_info')) {\n            const name = options.languagePreference || '';\n            metadata.set('language_info', { name });\n        }\n        this._ensureMetadata();\n        metadata.changed.connect(this.triggerContentChange, this);\n        this._deletedCells = [];\n    }\n    /**\n     * A signal emitted when the document content changes.\n     */\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    /**\n     * A signal emitted when the document state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * The dirty state of the document.\n     */\n    get dirty() {\n        return this._dirty;\n    }\n    set dirty(newValue) {\n        if (newValue === this._dirty) {\n            return;\n        }\n        const oldValue = this._dirty;\n        this._dirty = newValue;\n        this.triggerStateChange({ name: 'dirty', oldValue, newValue });\n    }\n    /**\n     * The read only state of the document.\n     */\n    get readOnly() {\n        return this._readOnly;\n    }\n    set readOnly(newValue) {\n        if (newValue === this._readOnly) {\n            return;\n        }\n        const oldValue = this._readOnly;\n        this._readOnly = newValue;\n        this.triggerStateChange({ name: 'readOnly', oldValue, newValue });\n    }\n    /**\n     * The metadata associated with the notebook.\n     */\n    get metadata() {\n        return this.modelDB.get('metadata');\n    }\n    /**\n     * Get the observable list of notebook cells.\n     */\n    get cells() {\n        return this._cells;\n    }\n    /**\n     * The major version number of the nbformat.\n     */\n    get nbformat() {\n        return this._nbformat;\n    }\n    /**\n     * The minor version number of the nbformat.\n     */\n    get nbformatMinor() {\n        return this._nbformatMinor;\n    }\n    /**\n     * The default kernel name of the document.\n     */\n    get defaultKernelName() {\n        const spec = this.metadata.get('kernelspec');\n        return spec ? spec.name : '';\n    }\n    /**\n     * A list of deleted cells for the notebook..\n     */\n    get deletedCells() {\n        return this._deletedCells;\n    }\n    /**\n     * If the model is initialized or not.\n     */\n    get isInitialized() {\n        return this._isInitialized;\n    }\n    /**\n     * The default kernel language of the document.\n     */\n    get defaultKernelLanguage() {\n        const info = this.metadata.get('language_info');\n        return info ? info.name : '';\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        const cells = this.cells;\n        this._cells = null;\n        cells.dispose();\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Serialize the model to a string.\n     */\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n    /**\n     * Deserialize the model from a string.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromString(value) {\n        this.fromJSON(JSON.parse(value));\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        var _a, _b;\n        const cells = [];\n        for (let i = 0; i < ((_b = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i++) {\n            const cell = this.cells.get(i).toJSON();\n            if (this._nbformat === 4 && this._nbformatMinor <= 4) {\n                // strip cell ids if we have notebook format 4.0-4.4\n                delete cell.id;\n            }\n            cells.push(cell);\n        }\n        this._ensureMetadata();\n        const metadata = Object.create(null);\n        for (const key of this.metadata.keys()) {\n            metadata[key] = JSON.parse(JSON.stringify(this.metadata.get(key)));\n        }\n        return {\n            metadata,\n            nbformat_minor: this._nbformatMinor,\n            nbformat: this._nbformat,\n            cells\n        };\n    }\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromJSON(value) {\n        const cells = [];\n        const factory = this.contentFactory;\n        const useId = value.nbformat === 4 && value.nbformat_minor >= 5;\n        for (const cell of value.cells) {\n            const options = { cell };\n            if (useId) {\n                options.id = cell.id;\n            }\n            switch (cell.cell_type) {\n                case 'code':\n                    cells.push(factory.createCodeCell(options));\n                    break;\n                case 'markdown':\n                    cells.push(factory.createMarkdownCell(options));\n                    break;\n                case 'raw':\n                    cells.push(factory.createRawCell(options));\n                    break;\n                default:\n                    continue;\n            }\n        }\n        this.cells.beginCompoundOperation();\n        this.cells.clear();\n        this.cells.pushAll(cells);\n        this.cells.endCompoundOperation();\n        let oldValue = 0;\n        let newValue = 0;\n        this._nbformatMinor = nbformat.MINOR_VERSION;\n        this._nbformat = nbformat.MAJOR_VERSION;\n        const origNbformat = value.metadata.orig_nbformat;\n        if (value.nbformat !== this._nbformat) {\n            oldValue = this._nbformat;\n            this._nbformat = newValue = value.nbformat;\n            this.triggerStateChange({ name: 'nbformat', oldValue, newValue });\n        }\n        if (value.nbformat_minor > this._nbformatMinor) {\n            oldValue = this._nbformatMinor;\n            this._nbformatMinor = newValue = value.nbformat_minor;\n            this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });\n        }\n        // Alert the user if the format changes.\n        if (origNbformat !== undefined && this._nbformat !== origNbformat) {\n            const newer = this._nbformat > origNbformat;\n            let msg;\n            if (newer) {\n                msg = this._trans.__(`This notebook has been converted from an older notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (vthis._nbformat) will be used.\n'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, this._nbformat);\n            }\n            else {\n                msg = this._trans.__(`This notebook has been converted from an newer notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\nSome features of the original notebook may not be available.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, this._nbformat);\n            }\n            void showDialog({\n                title: this._trans.__('Notebook converted'),\n                body: msg,\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n        }\n        // Update the metadata.\n        this.metadata.clear();\n        const metadata = value.metadata;\n        for (const key in metadata) {\n            // orig_nbformat is not intended to be stored per spec.\n            if (key === 'orig_nbformat') {\n                continue;\n            }\n            this.metadata.set(key, metadata[key]);\n        }\n        this._ensureMetadata();\n        this.dirty = true;\n    }\n    /**\n     * Initialize the model with its current state.\n     *\n     * # Notes\n     * Adds an empty code cell if the model is empty\n     * and clears undo state.\n     */\n    initialize() {\n        if (!this.cells.length) {\n            const factory = this.contentFactory;\n            this.cells.push(factory.createCodeCell({}));\n        }\n        this._isInitialized = true;\n        this.cells.clearUndo();\n    }\n    /**\n     * Handle a change in the cells list.\n     */\n    _onCellsChanged(list, change) {\n        switch (change.type) {\n            case 'add':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            case 'remove':\n                break;\n            case 'set':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            default:\n                break;\n        }\n        this.triggerContentChange();\n    }\n    /**\n     * Make sure we have the required metadata fields.\n     */\n    _ensureMetadata() {\n        const metadata = this.metadata;\n        if (!metadata.has('language_info')) {\n            metadata.set('language_info', { name: '' });\n        }\n        if (!metadata.has('kernelspec')) {\n            metadata.set('kernelspec', { name: '', display_name: '' });\n        }\n    }\n    /**\n     * Trigger a state change signal.\n     */\n    triggerStateChange(args) {\n        this._stateChanged.emit(args);\n    }\n    /**\n     * Trigger a content changed signal.\n     */\n    triggerContentChange() {\n        this._contentChanged.emit(void 0);\n        this.dirty = true;\n    }\n    /**\n     * Whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n}\n/**\n * The namespace for the `NotebookModel` class statics.\n */\n(function (NotebookModel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory {\n        /**\n         * Create a new cell model factory.\n         */\n        constructor(options) {\n            this.codeCellContentFactory =\n                options.codeCellContentFactory || CodeCellModel.defaultContentFactory;\n            this.modelDB = options.modelDB;\n        }\n        /**\n         * Create a new cell by cell type.\n         *\n         * @param type:  the type of the cell to create.\n         *\n         * @param options: the cell creation options.\n         *\n         * #### Notes\n         * This method is intended to be a convenience method to programmatically\n         * call the other cell creation methods in the factory.\n         */\n        createCell(type, options) {\n            switch (type) {\n                case 'code':\n                    return this.createCodeCell(options);\n                case 'markdown':\n                    return this.createMarkdownCell(options);\n                case 'raw':\n                default:\n                    return this.createRawCell(options);\n            }\n        }\n        /**\n         * Create a new code cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new code cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         *   If the contentFactory is not provided, the instance\n         *   `codeCellContentFactory` will be used.\n         */\n        createCodeCell(options) {\n            if (options.contentFactory) {\n                options.contentFactory = this.codeCellContentFactory;\n            }\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new CodeCellModel(options);\n        }\n        /**\n         * Create a new markdown cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new markdown cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createMarkdownCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new MarkdownCellModel(options);\n        }\n        /**\n         * Create a new raw cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new raw cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createRawCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new RawCellModel(options);\n        }\n        /**\n         * Clone the content factory with a new IModelDB.\n         */\n        clone(modelDB) {\n            return new ContentFactory({\n                modelDB: modelDB,\n                codeCellContentFactory: this.codeCellContentFactory\n            });\n        }\n    }\n    NotebookModel.ContentFactory = ContentFactory;\n    /**\n     * The default `ContentFactory` instance.\n     */\n    NotebookModel.defaultContentFactory = new ContentFactory({});\n})(NotebookModel || (NotebookModel = {}));\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NotebookModel } from './model';\n/**\n * A model factory for notebooks.\n */\nexport class NotebookModelFactory {\n    /**\n     * Construct a new notebook model factory.\n     */\n    constructor(options) {\n        this._disposed = false;\n        const codeCellContentFactory = options.codeCellContentFactory;\n        this.contentFactory =\n            options.contentFactory ||\n                new NotebookModel.ContentFactory({ codeCellContentFactory });\n    }\n    /**\n     * The name of the model.\n     */\n    get name() {\n        return 'notebook';\n    }\n    /**\n     * The content type of the file.\n     */\n    get contentType() {\n        return 'notebook';\n    }\n    /**\n     * The format of the file.\n     */\n    get fileFormat() {\n        return 'json';\n    }\n    /**\n     * Get whether the model factory has been disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose of the model factory.\n     */\n    dispose() {\n        this._disposed = true;\n    }\n    /**\n     * Create a new model for a given path.\n     *\n     * @param languagePreference - An optional kernel language preference.\n     *\n     * @returns A new document model.\n     */\n    createNew(languagePreference, modelDB, isInitialized) {\n        const contentFactory = this.contentFactory;\n        return new NotebookModel({\n            languagePreference,\n            contentFactory,\n            modelDB,\n            isInitialized\n        });\n    }\n    /**\n     * Get the preferred kernel language given a path.\n     */\n    preferredLanguage(path) {\n        return '';\n    }\n}\n//# sourceMappingURL=modelfactory.js.map","import { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { Text } from '@jupyterlab/coreutils';\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport * as React from 'react';\n/**\n * A pure function for rendering a Command/Edit mode component.\n *\n * @param props: the props for rendering the component.\n *\n * @returns a tsx component for command/edit mode.\n */\nfunction CommandEditComponent(props) {\n    const trans = (props.translator || nullTranslator).load('jupyterlab');\n    return (React.createElement(TextItem, { source: trans.__('Mode: %1', Text.titleCase(props.notebookMode)) }));\n}\n/**\n * StatusBar item to display which notebook mode user is in.\n */\nexport class CommandEditStatus extends VDomRenderer {\n    /**\n     * Construct a new CommandEdit status item.\n     */\n    constructor(translator) {\n        super(new CommandEditStatus.Model());\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n    }\n    /**\n     * Render the CommandEdit status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = this._trans.__('Notebook is in %1 mode', this.model.notebookMode);\n        return (React.createElement(CommandEditComponent, { notebookMode: this.model.notebookMode, translator: this.translator }));\n    }\n}\n/**\n * A namespace for CommandEdit statics.\n */\n(function (CommandEditStatus) {\n    /**\n     * A VDomModel for the CommandEdit renderer.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            /**\n             * On a change to the notebook, update the mode.\n             */\n            this._onChanged = (_notebook) => {\n                const oldMode = this._notebookMode;\n                if (this._notebook) {\n                    this._notebookMode = _notebook.mode;\n                }\n                else {\n                    this._notebookMode = 'command';\n                }\n                this._triggerChange(oldMode, this._notebookMode);\n            };\n            this._notebookMode = 'command';\n            this._notebook = null;\n        }\n        /**\n         * The current mode of the current notebook.\n         */\n        get notebookMode() {\n            return this._notebookMode;\n        }\n        /**\n         * Set the current notebook for the model.\n         */\n        set notebook(notebook) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.stateChanged.disconnect(this._onChanged, this);\n                oldNotebook.activeCellChanged.disconnect(this._onChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onChanged, this);\n            }\n            const oldMode = this._notebookMode;\n            this._notebook = notebook;\n            if (this._notebook === null) {\n                this._notebookMode = 'command';\n            }\n            else {\n                this._notebookMode = this._notebook.mode;\n                this._notebook.stateChanged.connect(this._onChanged, this);\n                this._notebook.activeCellChanged.connect(this._onChanged, this);\n                this._notebook.modelContentChanged.connect(this._onChanged, this);\n            }\n            this._triggerChange(oldMode, this._notebookMode);\n        }\n        /**\n         * Trigger a state change for the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState !== newState) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    CommandEditStatus.Model = Model;\n})(CommandEditStatus || (CommandEditStatus = {}));\n//# sourceMappingURL=modestatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Collapse, Styling } from '@jupyterlab/apputils';\nimport { CodeEditor, CodeEditorWrapper, JSONEditor } from '@jupyterlab/codeeditor';\nimport { ObservableJSON } from '@jupyterlab/observables';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, chain, each } from '@lumino/algorithm';\nimport { ConflatableMessage, MessageLoop } from '@lumino/messaging';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nclass RankedPanel extends Widget {\n    constructor() {\n        super();\n        this._items = [];\n        this.layout = new PanelLayout();\n        this.addClass('jp-RankedPanel');\n    }\n    addWidget(widget, rank) {\n        const rankItem = { widget, rank };\n        const index = ArrayExt.upperBound(this._items, rankItem, Private.itemCmp);\n        ArrayExt.insert(this._items, index, rankItem);\n        const layout = this.layout;\n        layout.insertWidget(index, widget);\n    }\n    /**\n     * Handle the removal of a child\n     *\n     */\n    onChildRemoved(msg) {\n        const index = ArrayExt.findFirstIndex(this._items, item => item.widget === msg.child);\n        if (index !== -1) {\n            ArrayExt.removeAt(this._items, index);\n        }\n    }\n}\n/**\n * A widget that provides metadata tools.\n */\nexport class NotebookTools extends Widget {\n    /**\n     * Construct a new NotebookTools object.\n     */\n    constructor(options) {\n        super();\n        this.addClass('jp-NotebookTools');\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._commonTools = new RankedPanel();\n        this._advancedTools = new RankedPanel();\n        this._advancedTools.title.label = this._trans.__('Advanced Tools');\n        const layout = (this.layout = new PanelLayout());\n        layout.addWidget(this._commonTools);\n        layout.addWidget(new Collapse({ widget: this._advancedTools }));\n        this._tracker = options.tracker;\n        this._tracker.currentChanged.connect(this._onActiveNotebookPanelChanged, this);\n        this._tracker.activeCellChanged.connect(this._onActiveCellChanged, this);\n        this._tracker.selectionChanged.connect(this._onSelectionChanged, this);\n        this._onActiveNotebookPanelChanged();\n        this._onActiveCellChanged();\n        this._onSelectionChanged();\n    }\n    /**\n     * The active cell widget.\n     */\n    get activeCell() {\n        return this._tracker.activeCell;\n    }\n    /**\n     * The currently selected cells.\n     */\n    get selectedCells() {\n        const panel = this._tracker.currentWidget;\n        if (!panel) {\n            return [];\n        }\n        const notebook = panel.content;\n        return notebook.widgets.filter(cell => notebook.isSelectedOrActive(cell));\n    }\n    /**\n     * The current notebook.\n     */\n    get activeNotebookPanel() {\n        return this._tracker.currentWidget;\n    }\n    /**\n     * Add a cell tool item.\n     */\n    addItem(options) {\n        var _a;\n        const tool = options.tool;\n        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : 100;\n        let section;\n        if (options.section === 'advanced') {\n            section = this._advancedTools;\n        }\n        else {\n            section = this._commonTools;\n        }\n        tool.addClass('jp-NotebookTools-tool');\n        section.addWidget(tool, rank);\n        // TODO: perhaps the necessary notebookTools functionality should be\n        // consolidated into a single object, rather than a broad reference to this.\n        tool.notebookTools = this;\n        // Trigger the tool to update its active notebook and cell.\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveNotebookPanelMessage);\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveCellMessage);\n    }\n    /**\n     * Handle a change to the notebook panel.\n     */\n    _onActiveNotebookPanelChanged() {\n        if (this._prevActiveNotebookModel &&\n            !this._prevActiveNotebookModel.isDisposed) {\n            this._prevActiveNotebookModel.metadata.changed.disconnect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        const activeNBModel = this.activeNotebookPanel && this.activeNotebookPanel.content\n            ? this.activeNotebookPanel.content.model\n            : null;\n        this._prevActiveNotebookModel = activeNBModel;\n        if (activeNBModel) {\n            activeNBModel.metadata.changed.connect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveNotebookPanelMessage);\n        });\n    }\n    /**\n     * Handle a change to the active cell.\n     */\n    _onActiveCellChanged() {\n        if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {\n            this._prevActiveCell.metadata.changed.disconnect(this._onActiveCellMetadataChanged, this);\n        }\n        const activeCell = this.activeCell ? this.activeCell.model : null;\n        this._prevActiveCell = activeCell;\n        if (activeCell) {\n            activeCell.metadata.changed.connect(this._onActiveCellMetadataChanged, this);\n        }\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveCellMessage);\n        });\n    }\n    /**\n     * Handle a change in the selection.\n     */\n    _onSelectionChanged() {\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.SelectionMessage);\n        });\n    }\n    /**\n     * Handle a change in the active cell metadata.\n     */\n    _onActiveNotebookPanelMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activenotebookpanel-metadata-changed', args);\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, message);\n        });\n    }\n    /**\n     * Handle a change in the notebook model metadata.\n     */\n    _onActiveCellMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activecell-metadata-changed', args);\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, message);\n        });\n    }\n    _toolChildren() {\n        return chain(this._commonTools.children(), this._advancedTools.children());\n    }\n}\n/**\n * The namespace for NotebookTools class statics.\n */\n(function (NotebookTools) {\n    /**\n     * A singleton conflatable `'activenotebookpanel-changed'` message.\n     */\n    NotebookTools.ActiveNotebookPanelMessage = new ConflatableMessage('activenotebookpanel-changed');\n    /**\n     * A singleton conflatable `'activecell-changed'` message.\n     */\n    NotebookTools.ActiveCellMessage = new ConflatableMessage('activecell-changed');\n    /**\n     * A singleton conflatable `'selection-changed'` message.\n     */\n    NotebookTools.SelectionMessage = new ConflatableMessage('selection-changed');\n    /**\n     * The base notebook tool, meant to be subclassed.\n     */\n    class Tool extends Widget {\n        dispose() {\n            super.dispose();\n            if (this.notebookTools) {\n                this.notebookTools = null;\n            }\n        }\n        /**\n         * Process a message sent to the widget.\n         *\n         * @param msg - The message sent to the widget.\n         */\n        processMessage(msg) {\n            super.processMessage(msg);\n            switch (msg.type) {\n                case 'activenotebookpanel-changed':\n                    this.onActiveNotebookPanelChanged(msg);\n                    break;\n                case 'activecell-changed':\n                    this.onActiveCellChanged(msg);\n                    break;\n                case 'selection-changed':\n                    this.onSelectionChanged(msg);\n                    break;\n                case 'activecell-metadata-changed':\n                    this.onActiveCellMetadataChanged(msg);\n                    break;\n                case 'activenotebookpanel-metadata-changed':\n                    this.onActiveNotebookPanelMetadataChanged(msg);\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle a change to the notebook panel.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the selection.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onSelectionChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellMetadataChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            /* no-op */\n        }\n    }\n    NotebookTools.Tool = Tool;\n    /**\n     * A cell tool displaying the active cell contents.\n     */\n    class ActiveCellTool extends Tool {\n        /**\n         * Construct a new active cell tool.\n         */\n        constructor() {\n            super();\n            this._model = new CodeEditor.Model();\n            this.addClass('jp-ActiveCellTool');\n            this.addClass('jp-InputArea');\n            this.layout = new PanelLayout();\n        }\n        /**\n         * Dispose of the resources used by the tool.\n         */\n        dispose() {\n            if (this._model === null) {\n                return;\n            }\n            this._model.dispose();\n            this._model = null;\n            super.dispose();\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged() {\n            const activeCell = this.notebookTools.activeCell;\n            const layout = this.layout;\n            const count = layout.widgets.length;\n            for (let i = 0; i < count; i++) {\n                layout.widgets[0].dispose();\n            }\n            if (this._cellModel && !this._cellModel.isDisposed) {\n                this._cellModel.value.changed.disconnect(this._onValueChanged, this);\n                this._cellModel.mimeTypeChanged.disconnect(this._onMimeTypeChanged, this);\n            }\n            if (!activeCell) {\n                const cell = new Widget();\n                cell.addClass('jp-InputArea-editor');\n                cell.addClass('jp-InputArea-editor');\n                layout.addWidget(cell);\n                this._cellModel = null;\n                return;\n            }\n            const promptNode = activeCell.promptNode\n                ? activeCell.promptNode.cloneNode(true)\n                : undefined;\n            const prompt = new Widget({ node: promptNode });\n            const factory = activeCell.contentFactory.editorFactory;\n            const cellModel = (this._cellModel = activeCell.model);\n            cellModel.value.changed.connect(this._onValueChanged, this);\n            cellModel.mimeTypeChanged.connect(this._onMimeTypeChanged, this);\n            this._model.value.text = cellModel.value.text.split('\\n')[0];\n            this._model.mimeType = cellModel.mimeType;\n            const model = this._model;\n            const editorWidget = new CodeEditorWrapper({ model, factory });\n            editorWidget.addClass('jp-InputArea-editor');\n            editorWidget.addClass('jp-InputArea-editor');\n            editorWidget.editor.setOption('readOnly', true);\n            layout.addWidget(prompt);\n            layout.addWidget(editorWidget);\n        }\n        /**\n         * Handle a change to the current editor value.\n         */\n        _onValueChanged() {\n            this._model.value.text = this._cellModel.value.text.split('\\n')[0];\n        }\n        /**\n         * Handle a change to the current editor mimetype.\n         */\n        _onMimeTypeChanged() {\n            this._model.mimeType = this._cellModel.mimeType;\n        }\n    }\n    NotebookTools.ActiveCellTool = ActiveCellTool;\n    /**\n     * A raw metadata editor.\n     */\n    class MetadataEditorTool extends Tool {\n        /**\n         * Construct a new raw metadata tool.\n         */\n        constructor(options) {\n            super();\n            const { editorFactory } = options;\n            this.addClass('jp-MetadataEditorTool');\n            const layout = (this.layout = new PanelLayout());\n            this.editor = new JSONEditor({\n                editorFactory\n            });\n            this.editor.title.label = options.label || 'Edit Metadata';\n            const titleNode = new Widget({ node: document.createElement('label') });\n            titleNode.node.textContent = options.label || 'Edit Metadata';\n            layout.addWidget(titleNode);\n            layout.addWidget(this.editor);\n        }\n    }\n    NotebookTools.MetadataEditorTool = MetadataEditorTool;\n    /**\n     * A notebook metadata editor\n     */\n    class NotebookMetadataEditorTool extends MetadataEditorTool {\n        constructor(options) {\n            const translator = options.translator || nullTranslator;\n            const trans = translator.load('jupyterlab');\n            options.label = options.label || trans.__('Notebook Metadata');\n            super(options);\n        }\n        /**\n         * Handle a change to the notebook.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            this._update();\n        }\n        /**\n         * Handle a change to the notebook metadata.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            this._update();\n        }\n        _update() {\n            var _a, _b;\n            const nb = this.notebookTools.activeNotebookPanel &&\n                this.notebookTools.activeNotebookPanel.content;\n            this.editor.source = (_b = (_a = nb === null || nb === void 0 ? void 0 : nb.model) === null || _a === void 0 ? void 0 : _a.metadata) !== null && _b !== void 0 ? _b : null;\n        }\n    }\n    NotebookTools.NotebookMetadataEditorTool = NotebookMetadataEditorTool;\n    /**\n     * A cell metadata editor\n     */\n    class CellMetadataEditorTool extends MetadataEditorTool {\n        constructor(options) {\n            const translator = options.translator || nullTranslator;\n            const trans = translator.load('jupyterlab');\n            options.label = options.label || trans.__('Cell Metadata');\n            super(options);\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged(msg) {\n            this._update();\n        }\n        /**\n         * Handle a change to the active cell metadata.\n         */\n        onActiveCellMetadataChanged(msg) {\n            this._update();\n        }\n        _update() {\n            const cell = this.notebookTools.activeCell;\n            this.editor.source = cell ? cell.model.metadata : null;\n        }\n    }\n    NotebookTools.CellMetadataEditorTool = CellMetadataEditorTool;\n    /**\n     * A cell tool that provides a selection for a given metadata key.\n     */\n    class KeySelector extends Tool {\n        /**\n         * Construct a new KeySelector.\n         */\n        constructor(options) {\n            // TODO: use react\n            super({ node: Private.createSelectorNode(options) });\n            /**\n             * Get the value for the data.\n             */\n            this._getValue = (cell) => {\n                let value = cell.model.metadata.get(this.key);\n                if (value === undefined) {\n                    value = this._default;\n                }\n                return value;\n            };\n            /**\n             * Set the value for the data.\n             */\n            this._setValue = (cell, value) => {\n                if (value === this._default) {\n                    cell.model.metadata.delete(this.key);\n                }\n                else {\n                    cell.model.metadata.set(this.key, value);\n                }\n            };\n            this._changeGuard = false;\n            this.addClass('jp-KeySelector');\n            this.key = options.key;\n            this._default = options.default;\n            this._validCellTypes = options.validCellTypes || [];\n            this._getter = options.getter || this._getValue;\n            this._setter = options.setter || this._setValue;\n        }\n        /**\n         * The select node for the widget.\n         */\n        get selectNode() {\n            return this.node.getElementsByTagName('select')[0];\n        }\n        /**\n         * Handle the DOM events for the widget.\n         *\n         * @param event - The DOM event sent to the widget.\n         *\n         * #### Notes\n         * This method implements the DOM `EventListener` interface and is\n         * called in response to events on the notebook panel's node. It should\n         * not be called directly by user code.\n         */\n        handleEvent(event) {\n            switch (event.type) {\n                case 'change':\n                    this.onValueChanged();\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle `after-attach` messages for the widget.\n         */\n        onAfterAttach(msg) {\n            const node = this.selectNode;\n            node.addEventListener('change', this);\n        }\n        /**\n         * Handle `before-detach` messages for the widget.\n         */\n        onBeforeDetach(msg) {\n            const node = this.selectNode;\n            node.removeEventListener('change', this);\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged(msg) {\n            const select = this.selectNode;\n            const activeCell = this.notebookTools.activeCell;\n            if (!activeCell) {\n                select.disabled = true;\n                select.value = '';\n                return;\n            }\n            const cellType = activeCell.model.type;\n            if (this._validCellTypes.length &&\n                this._validCellTypes.indexOf(cellType) === -1) {\n                select.value = '';\n                select.disabled = true;\n                return;\n            }\n            select.disabled = false;\n            this._changeGuard = true;\n            const getter = this._getter;\n            select.value = JSON.stringify(getter(activeCell));\n            this._changeGuard = false;\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         */\n        onActiveCellMetadataChanged(msg) {\n            if (this._changeGuard) {\n                return;\n            }\n            const select = this.selectNode;\n            const cell = this.notebookTools.activeCell;\n            if (msg.args.key === this.key && cell) {\n                this._changeGuard = true;\n                const getter = this._getter;\n                select.value = JSON.stringify(getter(cell));\n                this._changeGuard = false;\n            }\n        }\n        /**\n         * Handle a change to the value.\n         */\n        onValueChanged() {\n            const activeCell = this.notebookTools.activeCell;\n            if (!activeCell || this._changeGuard) {\n                return;\n            }\n            this._changeGuard = true;\n            const select = this.selectNode;\n            const setter = this._setter;\n            setter(activeCell, JSON.parse(select.value));\n            this._changeGuard = false;\n        }\n    }\n    NotebookTools.KeySelector = KeySelector;\n    /**\n     * Create a slideshow selector.\n     */\n    function createSlideShowSelector(translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        trans.__('');\n        const options = {\n            key: 'slideshow',\n            title: trans.__('Slide Type'),\n            optionValueArray: [\n                ['-', null],\n                [trans.__('Slide'), 'slide'],\n                [trans.__('Sub-Slide'), 'subslide'],\n                [trans.__('Fragment'), 'fragment'],\n                [trans.__('Skip'), 'skip'],\n                [trans.__('Notes'), 'notes']\n            ],\n            getter: cell => {\n                const value = cell.model.metadata.get('slideshow');\n                return value && value['slide_type'];\n            },\n            setter: (cell, value) => {\n                let data = cell.model.metadata.get('slideshow') || Object.create(null);\n                if (value === null) {\n                    // Make a shallow copy so we aren't modifying the original metadata.\n                    data = Object.assign({}, data);\n                    delete data.slide_type;\n                }\n                else {\n                    data = Object.assign(Object.assign({}, data), { slide_type: value });\n                }\n                if (Object.keys(data).length > 0) {\n                    cell.model.metadata.set('slideshow', data);\n                }\n                else {\n                    cell.model.metadata.delete('slideshow');\n                }\n            }\n        };\n        return new KeySelector(options);\n    }\n    NotebookTools.createSlideShowSelector = createSlideShowSelector;\n    /**\n     * Create an nbconvert selector.\n     */\n    function createNBConvertSelector(optionValueArray, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        return new KeySelector({\n            key: 'raw_mimetype',\n            title: trans.__('Raw NBConvert Format'),\n            optionValueArray: optionValueArray,\n            validCellTypes: ['raw']\n        });\n    }\n    NotebookTools.createNBConvertSelector = createNBConvertSelector;\n})(NotebookTools || (NotebookTools = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A comparator function for widget rank items.\n     */\n    function itemCmp(first, second) {\n        return first.rank - second.rank;\n    }\n    Private.itemCmp = itemCmp;\n    /**\n     * Create the node for a KeySelector.\n     */\n    function createSelectorNode(options) {\n        const name = options.key;\n        const title = options.title || name[0].toLocaleUpperCase() + name.slice(1);\n        const optionNodes = [];\n        let value;\n        let option;\n        each(options.optionValueArray, item => {\n            option = item[0];\n            value = JSON.stringify(item[1]);\n            optionNodes.push(h.option({ value }, option));\n        });\n        const node = VirtualDOM.realize(h.div({}, h.label(title, h.select({}, optionNodes))));\n        Styling.styleNode(node);\n        return node;\n    }\n    Private.createSelectorNode = createSelectorNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=notebooktools.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Cell, CodeCell, MarkdownCell, RawCell } from '@jupyterlab/cells';\nimport { CodeEditor } from '@jupyterlab/codeeditor';\nimport { ArrayExt, each, findIndex } from '@lumino/algorithm';\nimport { MimeData } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Drag } from '@lumino/dragdrop';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { NotebookActions } from './actions';\n/**\n * The data attribute added to a widget that has an active kernel.\n */\nconst KERNEL_USER = 'jpKernelUser';\n/**\n * The data attribute added to a widget that can run code.\n */\nconst CODE_RUNNER = 'jpCodeRunner';\n/**\n * The data attribute added to a widget that can undo.\n */\nconst UNDOER = 'jpUndoer';\n/**\n * The class name added to notebook widgets.\n */\nconst NB_CLASS = 'jp-Notebook';\n/**\n * The class name added to notebook widget cells.\n */\nconst NB_CELL_CLASS = 'jp-Notebook-cell';\n/**\n * The class name added to a notebook in edit mode.\n */\nconst EDIT_CLASS = 'jp-mod-editMode';\n/**\n * The class name added to a notebook in command mode.\n */\nconst COMMAND_CLASS = 'jp-mod-commandMode';\n/**\n * The class name added to the active cell.\n */\nconst ACTIVE_CLASS = 'jp-mod-active';\n/**\n * The class name added to selected cells.\n */\nconst SELECTED_CLASS = 'jp-mod-selected';\n/**\n * The class name added to an active cell when there are other selected cells.\n */\nconst OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';\n/**\n * The class name added to unconfined images.\n */\nconst UNCONFINED_CLASS = 'jp-mod-unconfined';\n/**\n * The class name added to a drop target.\n */\nconst DROP_TARGET_CLASS = 'jp-mod-dropTarget';\n/**\n * The class name added to a drop source.\n */\nconst DROP_SOURCE_CLASS = 'jp-mod-dropSource';\n/**\n * The class name added to drag images.\n */\nconst DRAG_IMAGE_CLASS = 'jp-dragImage';\n/**\n * The class name added to singular drag images\n */\nconst SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\n/**\n * The threshold in pixels to start a drag event.\n */\nconst DRAG_THRESHOLD = 5;\n/**\n * The class attached to the heading collapser button\n */\nconst HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';\nif (window.requestIdleCallback === undefined) {\n    // On Safari, requestIdleCallback is not available, so we use replacement functions for `idleCallbacks`\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#falling_back_to_settimeout\n    window.requestIdleCallback = function (handler) {\n        let startTime = Date.now();\n        return setTimeout(function () {\n            handler({\n                didTimeout: false,\n                timeRemaining: function () {\n                    return Math.max(0, 50.0 - (Date.now() - startTime));\n                }\n            });\n        }, 1);\n    };\n    window.cancelIdleCallback = function (id) {\n        clearTimeout(id);\n    };\n}\n/**\n * A widget which renders static non-interactive notebooks.\n *\n * #### Notes\n * The widget model must be set separately and can be changed\n * at any time.  Consumers of the widget must account for a\n * `null` model, and may want to listen to the `modelChanged`\n * signal.\n */\nexport class StaticNotebook extends Widget {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        super();\n        this._editorConfig = StaticNotebook.defaultEditorConfig;\n        this._notebookConfig = StaticNotebook.defaultNotebookConfig;\n        this._mimetype = 'text/plain';\n        this._model = null;\n        this._modelChanged = new Signal(this);\n        this._modelContentChanged = new Signal(this);\n        this._fullyRendered = new Signal(this);\n        this._placeholderCellRendered = new Signal(this);\n        this._renderedCellsCount = 0;\n        this.addClass(NB_CLASS);\n        this.node.dataset[KERNEL_USER] = 'true';\n        this.node.dataset[UNDOER] = 'true';\n        this.node.dataset[CODE_RUNNER] = 'true';\n        this.rendermime = options.rendermime;\n        this.layout = new Private.NotebookPanelLayout();\n        this.contentFactory =\n            options.contentFactory || StaticNotebook.defaultContentFactory;\n        this.editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this.notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._mimetypeService = options.mimeTypeService;\n        // Section for the virtual-notebook behavior.\n        this._toRenderMap = new Map();\n        this._cellsArray = new Array();\n        if ('IntersectionObserver' in window) {\n            this._observer = new IntersectionObserver((entries, observer) => {\n                entries.forEach(o => {\n                    if (o.isIntersecting) {\n                        observer.unobserve(o.target);\n                        const ci = this._toRenderMap.get(o.target.id);\n                        if (ci) {\n                            const { cell, index } = ci;\n                            this._renderPlaceholderCell(cell, index);\n                        }\n                    }\n                });\n            }, {\n                root: this.node,\n                threshold: 1,\n                rootMargin: `${this.notebookConfig.observedTopMargin} 0px ${this.notebookConfig.observedBottomMargin} 0px`\n            });\n        }\n    }\n    /**\n     * A signal emitted when the notebook is fully rendered.\n     */\n    get fullyRendered() {\n        return this._fullyRendered;\n    }\n    /**\n     * A signal emitted when the a placeholder cell is rendered.\n     */\n    get placeholderCellRendered() {\n        return this._placeholderCellRendered;\n    }\n    /**\n     * A signal emitted when the model of the notebook changes.\n     */\n    get modelChanged() {\n        return this._modelChanged;\n    }\n    /**\n     * A signal emitted when the model content changes.\n     *\n     * #### Notes\n     * This is a convenience signal that follows the current model.\n     */\n    get modelContentChanged() {\n        return this._modelContentChanged;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this._model;\n    }\n    set model(newValue) {\n        newValue = newValue || null;\n        if (this._model === newValue) {\n            return;\n        }\n        const oldValue = this._model;\n        this._model = newValue;\n        if (oldValue && oldValue.modelDB.isCollaborative) {\n            void oldValue.modelDB.connected.then(() => {\n                oldValue.modelDB.collaborators.changed.disconnect(this._onCollaboratorsChanged, this);\n            });\n        }\n        if (newValue && newValue.modelDB.isCollaborative) {\n            void newValue.modelDB.connected.then(() => {\n                newValue.modelDB.collaborators.changed.connect(this._onCollaboratorsChanged, this);\n            });\n        }\n        // Trigger private, protected, and public changes.\n        this._onModelChanged(oldValue, newValue);\n        this.onModelChanged(oldValue, newValue);\n        this._modelChanged.emit(void 0);\n    }\n    /**\n     * Get the mimetype for code cells.\n     */\n    get codeMimetype() {\n        return this._mimetype;\n    }\n    /**\n     * A read-only sequence of the widgets in the notebook.\n     */\n    get widgets() {\n        return this.layout.widgets;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n        this._updateEditorConfig();\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n        this._updateNotebookConfig();\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._model = null;\n        super.dispose();\n    }\n    /**\n     * Handle a new model.\n     *\n     * #### Notes\n     * This method is called after the model change has been handled\n     * internally and before the `modelChanged` signal is emitted.\n     * The default implementation is a no-op.\n     */\n    onModelChanged(oldValue, newValue) {\n        // No-op.\n    }\n    /**\n     * Handle changes to the notebook model content.\n     *\n     * #### Notes\n     * The default implementation emits the `modelContentChanged` signal.\n     */\n    onModelContentChanged(model, args) {\n        this._modelContentChanged.emit(void 0);\n    }\n    /**\n     * Handle changes to the notebook model metadata.\n     *\n     * #### Notes\n     * The default implementation updates the mimetypes of the code cells\n     * when the `language_info` metadata changes.\n     */\n    onMetadataChanged(sender, args) {\n        switch (args.key) {\n            case 'language_info':\n                this._updateMimetype();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     *\n     * The default implementation is a no-op\n     */\n    onCellInserted(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being moved.\n     *\n     * The default implementation is a no-op\n     */\n    onCellMoved(fromIndex, toIndex) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being removed.\n     *\n     * The default implementation is a no-op\n     */\n    onCellRemoved(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a new model on the widget.\n     */\n    _onModelChanged(oldValue, newValue) {\n        const layout = this.layout;\n        if (oldValue) {\n            oldValue.cells.changed.disconnect(this._onCellsChanged, this);\n            oldValue.metadata.changed.disconnect(this.onMetadataChanged, this);\n            oldValue.contentChanged.disconnect(this.onModelContentChanged, this);\n            // TODO: reuse existing cell widgets if possible. Remember to initially\n            // clear the history of each cell if we do this.\n            while (layout.widgets.length) {\n                this._removeCell(0);\n            }\n        }\n        if (!newValue) {\n            this._mimetype = 'text/plain';\n            return;\n        }\n        this._updateMimetype();\n        const cells = newValue.cells;\n        if (!cells.length && newValue.isInitialized) {\n            cells.push(newValue.contentFactory.createCell(this.notebookConfig.defaultCell, {}));\n        }\n        each(cells, (cell, i) => {\n            this._insertCell(i, cell, 'set');\n        });\n        cells.changed.connect(this._onCellsChanged, this);\n        newValue.contentChanged.connect(this.onModelContentChanged, this);\n        newValue.metadata.changed.connect(this.onMetadataChanged, this);\n    }\n    /**\n     * Handle a change cells event.\n     */\n    _onCellsChanged(sender, args) {\n        let index = 0;\n        switch (args.type) {\n            case 'add':\n                index = args.newIndex;\n                // eslint-disable-next-line no-case-declarations\n                const insertType = args.oldIndex == -1 ? 'push' : 'insert';\n                each(args.newValues, value => {\n                    this._insertCell(index++, value, insertType);\n                });\n                break;\n            case 'move':\n                this._moveCell(args.oldIndex, args.newIndex);\n                break;\n            case 'remove':\n                each(args.oldValues, value => {\n                    this._removeCell(args.oldIndex);\n                });\n                // Add default cell if there are no cells remaining.\n                if (!sender.length) {\n                    const model = this.model;\n                    // Add the cell in a new context to avoid triggering another\n                    // cell changed event during the handling of this signal.\n                    requestAnimationFrame(() => {\n                        if (model && !model.isDisposed && !model.cells.length) {\n                            model.cells.push(model.contentFactory.createCell(this.notebookConfig.defaultCell, {}));\n                        }\n                    });\n                }\n                break;\n            case 'set':\n                // TODO: reuse existing widgets if possible.\n                index = args.newIndex;\n                each(args.newValues, value => {\n                    // Note: this ordering (insert then remove)\n                    // is important for getting the active cell\n                    // index for the editable notebook correct.\n                    this._insertCell(index, value, 'set');\n                    this._removeCell(index + 1);\n                    index++;\n                });\n                break;\n            default:\n                return;\n        }\n    }\n    /**\n     * Create a cell widget and insert into the notebook.\n     */\n    _insertCell(index, cell, insertType) {\n        let widget;\n        switch (cell.type) {\n            case 'code':\n                widget = this._createCodeCell(cell);\n                widget.model.mimeType = this._mimetype;\n                break;\n            case 'markdown':\n                widget = this._createMarkdownCell(cell);\n                if (cell.value.text === '') {\n                    widget.rendered = false;\n                }\n                break;\n            default:\n                widget = this._createRawCell(cell);\n        }\n        widget.addClass(NB_CELL_CLASS);\n        const layout = this.layout;\n        this._cellsArray.push(widget);\n        if (this._observer &&\n            insertType === 'push' &&\n            this._renderedCellsCount >=\n                this.notebookConfig.numberCellsToRenderDirectly) {\n            // We have an observer and we are have been asked to push (not to insert).\n            // and we are above the number of cells to render directly, then\n            // we will add a placeholder and let the intersection observer or the\n            // idle browser render those placeholder cells.\n            this._toRenderMap.set(widget.model.id, { index: index, cell: widget });\n            const placeholder = this._createPlaceholderCell(cell, index);\n            placeholder.node.id = widget.model.id;\n            layout.insertWidget(index, placeholder);\n            this.onCellInserted(index, placeholder);\n            this._fullyRendered.emit(false);\n            this._observer.observe(placeholder.node);\n        }\n        else {\n            // We have no intersection observer, or we insert, or we are below\n            // the number of cells to render directly, so we render directly.\n            layout.insertWidget(index, widget);\n            this._incrementRenderedCount();\n            this.onCellInserted(index, widget);\n        }\n        if (this._observer && this.notebookConfig.renderCellOnIdle) {\n            const renderPlaceholderCells = this._renderPlaceholderCells.bind(this);\n            window.requestIdleCallback(renderPlaceholderCells, {\n                timeout: 1000\n            });\n        }\n    }\n    _renderPlaceholderCells(deadline) {\n        if (this._renderedCellsCount < this._cellsArray.length &&\n            this._renderedCellsCount >=\n                this.notebookConfig.numberCellsToRenderDirectly) {\n            const index = this._renderedCellsCount;\n            const cell = this._cellsArray[index];\n            this._renderPlaceholderCell(cell, index);\n        }\n    }\n    _renderPlaceholderCell(cell, index) {\n        const pl = this.layout;\n        pl.removeWidgetAt(index);\n        pl.insertWidget(index, cell);\n        this._toRenderMap.delete(cell.model.id);\n        this._incrementRenderedCount();\n        this.onCellInserted(index, cell);\n        this._placeholderCellRendered.emit(cell);\n    }\n    /**\n     * Create a code cell widget from a code cell model.\n     */\n    _createCodeCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.code;\n        const options = {\n            editorConfig,\n            model,\n            rendermime,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: false,\n            maxNumberOutputs: this.notebookConfig.maxNumberOutputs\n        };\n        const cell = this.contentFactory.createCodeCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        cell.syncScrolled = true;\n        return cell;\n    }\n    /**\n     * Create a markdown cell widget from a markdown cell model.\n     */\n    _createMarkdownCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.markdown;\n        const options = {\n            editorConfig,\n            model,\n            rendermime,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: false\n        };\n        const cell = this.contentFactory.createMarkdownCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Create a placeholder cell widget from a raw cell model.\n     */\n    _createPlaceholderCell(model, index) {\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.raw;\n        const options = {\n            editorConfig,\n            model,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: true\n        };\n        const cell = this.contentFactory.createRawCell(options, this);\n        cell.node.innerHTML = `\n      <div class=\"jp-Cell-Placeholder\">\n        <div class=\"jp-Cell-Placeholder-wrapper\">\n        </div>\n      </div>`;\n        cell.inputHidden = true;\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Create a raw cell widget from a raw cell model.\n     */\n    _createRawCell(model) {\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.raw;\n        const options = {\n            editorConfig,\n            model,\n            contentFactory,\n            updateEditorOnShow: false,\n            placeholder: false\n        };\n        const cell = this.contentFactory.createRawCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Move a cell widget.\n     */\n    _moveCell(fromIndex, toIndex) {\n        const layout = this.layout;\n        layout.insertWidget(toIndex, layout.widgets[fromIndex]);\n        this.onCellMoved(fromIndex, toIndex);\n    }\n    /**\n     * Remove a cell widget.\n     */\n    _removeCell(index) {\n        const layout = this.layout;\n        const widget = layout.widgets[index];\n        widget.parent = null;\n        this.onCellRemoved(index, widget);\n        widget.dispose();\n    }\n    /**\n     * Update the mimetype of the notebook.\n     */\n    _updateMimetype() {\n        var _a;\n        const info = (_a = this._model) === null || _a === void 0 ? void 0 : _a.metadata.get('language_info');\n        if (!info) {\n            return;\n        }\n        this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);\n        each(this.widgets, widget => {\n            if (widget.model.type === 'code') {\n                widget.model.mimeType = this._mimetype;\n            }\n        });\n    }\n    /**\n     * Handle an update to the collaborators.\n     */\n    _onCollaboratorsChanged() {\n        var _a, _b, _c;\n        // If there are selections corresponding to non-collaborators,\n        // they are stale and should be removed.\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            for (const key of cell.model.selections.keys()) {\n                if (false === ((_c = (_b = (_a = this._model) === null || _a === void 0 ? void 0 : _a.modelDB) === null || _b === void 0 ? void 0 : _b.collaborators) === null || _c === void 0 ? void 0 : _c.has(key))) {\n                    cell.model.selections.delete(key);\n                }\n            }\n        }\n    }\n    /**\n     * Update editor settings for notebook cells.\n     */\n    _updateEditorConfig() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            let config;\n            switch (cell.model.type) {\n                case 'code':\n                    config = this._editorConfig.code;\n                    break;\n                case 'markdown':\n                    config = this._editorConfig.markdown;\n                    break;\n                default:\n                    config = this._editorConfig.raw;\n                    break;\n            }\n            let editorOptions = {};\n            Object.keys(config).forEach((key) => {\n                var _a;\n                editorOptions[key] = (_a = config[key]) !== null && _a !== void 0 ? _a : null;\n            });\n            cell.editor.setOptions(editorOptions);\n            cell.editor.refresh();\n        }\n    }\n    /**\n     * Apply updated notebook settings.\n     */\n    _updateNotebookConfig() {\n        // Apply scrollPastEnd setting.\n        this.toggleClass('jp-mod-scrollPastEnd', this._notebookConfig.scrollPastEnd);\n    }\n    _incrementRenderedCount() {\n        if (this._toRenderMap.size === 0) {\n            this._fullyRendered.emit(true);\n        }\n        this._renderedCellsCount++;\n    }\n}\n/**\n * The namespace for the `StaticNotebook` class statics.\n */\n(function (StaticNotebook) {\n    /**\n     * Default configuration options for cell editors.\n     */\n    StaticNotebook.defaultEditorConfig = {\n        code: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'off', matchBrackets: true, autoClosingBrackets: false }),\n        markdown: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false }),\n        raw: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false })\n    };\n    /**\n     * Default configuration options for notebooks.\n     */\n    StaticNotebook.defaultNotebookConfig = {\n        scrollPastEnd: true,\n        defaultCell: 'code',\n        recordTiming: false,\n        numberCellsToRenderDirectly: 20,\n        renderCellOnIdle: true,\n        observedTopMargin: '1000px',\n        observedBottomMargin: '1000px',\n        maxNumberOutputs: 50\n    };\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Cell.ContentFactory {\n        /**\n         * Create a new code cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createCodeCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new CodeCell(options).initializeState();\n        }\n        /**\n         * Create a new markdown cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createMarkdownCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new MarkdownCell(options).initializeState();\n        }\n        /**\n         * Create a new raw cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createRawCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new RawCell(options).initializeState();\n        }\n    }\n    StaticNotebook.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the static notebook widget.\n     */\n    StaticNotebook.defaultContentFactory = new ContentFactory();\n})(StaticNotebook || (StaticNotebook = {}));\n/**\n * A notebook widget that supports interactivity.\n */\nexport class Notebook extends StaticNotebook {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        super(Private.processNotebookOptions(options));\n        this._activeCellIndex = -1;\n        this._activeCell = null;\n        this._mode = 'command';\n        this._drag = null;\n        this._fragment = '';\n        this._dragData = null;\n        this._mouseMode = null;\n        this._activeCellChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n        this._checkCacheOnNextResize = false;\n        this.node.tabIndex = 0; // Allow the widget to take focus.\n        // Allow the node to scroll while dragging items.\n        this.node.setAttribute('data-lm-dragscroll', 'true');\n    }\n    /**\n     * A signal emitted when the active cell changes.\n     *\n     * #### Notes\n     * This can be due to the active index changing or the\n     * cell at the active index changing.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the state of the notebook changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when the selection state of the notebook changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * The interactivity mode of the notebook.\n     */\n    get mode() {\n        return this._mode;\n    }\n    set mode(newValue) {\n        const activeCell = this.activeCell;\n        if (!activeCell) {\n            newValue = 'command';\n        }\n        if (newValue === this._mode) {\n            this._ensureFocus();\n            return;\n        }\n        // Post an update request.\n        this.update();\n        const oldValue = this._mode;\n        this._mode = newValue;\n        if (newValue === 'edit') {\n            // Edit mode deselects all cells.\n            each(this.widgets, widget => {\n                this.deselect(widget);\n            });\n            //  Edit mode unrenders an active markdown widget.\n            if (activeCell instanceof MarkdownCell) {\n                activeCell.rendered = false;\n            }\n            activeCell.inputHidden = false;\n        }\n        else {\n            // Focus on the notebook document, which blurs the active cell.\n            this.node.focus();\n        }\n        this._stateChanged.emit({ name: 'mode', oldValue, newValue });\n        this._ensureFocus();\n    }\n    /**\n     * The active cell index of the notebook.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the notebook cells.\n     */\n    get activeCellIndex() {\n        if (!this.model) {\n            return -1;\n        }\n        return this.model.cells.length ? this._activeCellIndex : -1;\n    }\n    set activeCellIndex(newValue) {\n        const oldValue = this._activeCellIndex;\n        if (!this.model || !this.model.cells.length) {\n            newValue = -1;\n        }\n        else {\n            newValue = Math.max(newValue, 0);\n            newValue = Math.min(newValue, this.model.cells.length - 1);\n        }\n        this._activeCellIndex = newValue;\n        const cell = this.widgets[newValue];\n        if (cell !== this._activeCell) {\n            // Post an update request.\n            this.update();\n            this._activeCell = cell;\n            this._activeCellChanged.emit(cell);\n        }\n        if (this.mode === 'edit' && cell instanceof MarkdownCell) {\n            cell.rendered = false;\n        }\n        this._ensureFocus();\n        if (newValue === oldValue) {\n            return;\n        }\n        this._trimSelections();\n        this._stateChanged.emit({ name: 'activeCellIndex', oldValue, newValue });\n    }\n    /**\n     * Get the active cell widget.\n     *\n     * #### Notes\n     * This is a cell or `null` if there is no active cell.\n     */\n    get activeCell() {\n        return this._activeCell;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Select a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    select(widget) {\n        if (Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, true);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Deselect a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    deselect(widget) {\n        if (!Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, false);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Whether a cell is selected.\n     */\n    isSelected(widget) {\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Whether a cell is selected or is the active cell.\n     */\n    isSelectedOrActive(widget) {\n        if (widget === this._activeCell) {\n            return true;\n        }\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Deselect all of the cells.\n     */\n    deselectAll() {\n        let changed = false;\n        each(this.widgets, widget => {\n            if (Private.selectedProperty.get(widget)) {\n                changed = true;\n            }\n            Private.selectedProperty.set(widget, false);\n        });\n        if (changed) {\n            this._selectionChanged.emit(void 0);\n        }\n        // Make sure we have a valid active cell.\n        this.activeCellIndex = this.activeCellIndex; // eslint-disable-line\n        this.update();\n    }\n    /**\n     * Move the head of an existing contiguous selection to extend the selection.\n     *\n     * @param index - The new head of the existing selection.\n     *\n     * #### Notes\n     * If there is no existing selection, the active cell is considered an\n     * existing one-cell selection.\n     *\n     * If the new selection is a single cell, that cell becomes the active cell\n     * and all cells are deselected.\n     *\n     * There is no change if there are no cells (i.e., activeCellIndex is -1).\n     */\n    extendContiguousSelectionTo(index) {\n        let { head, anchor } = this.getContiguousSelection();\n        let i;\n        // Handle the case of no current selection.\n        if (anchor === null || head === null) {\n            if (index === this.activeCellIndex) {\n                // Already collapsed selection, nothing more to do.\n                return;\n            }\n            // We will start a new selection below.\n            head = this.activeCellIndex;\n            anchor = this.activeCellIndex;\n        }\n        // Move the active cell. We do this before the collapsing shortcut below.\n        this.activeCellIndex = index;\n        // Make sure the index is valid, according to the rules for setting and clipping the\n        // active cell index. This may change the index.\n        index = this.activeCellIndex;\n        // Collapse the selection if it is only the active cell.\n        if (index === anchor) {\n            this.deselectAll();\n            return;\n        }\n        let selectionChanged = false;\n        if (head < index) {\n            if (head < anchor) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between head and index except anchor.\n            for (i = head + 1; i < index; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        else if (index < head) {\n            if (anchor < head) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between index and head except anchor.\n            for (i = index + 1; i < head; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        // Anchor and index should *always* be selected.\n        if (!Private.selectedProperty.get(this.widgets[anchor])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[anchor], true);\n        if (!Private.selectedProperty.get(this.widgets[index])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[index], true);\n        if (selectionChanged) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Get the head and anchor of a contiguous cell selection.\n     *\n     * The head of a contiguous selection is always the active cell.\n     *\n     * If there are no cells selected, `{head: null, anchor: null}` is returned.\n     *\n     * Throws an error if the currently selected cells do not form a contiguous\n     * selection.\n     */\n    getContiguousSelection() {\n        const cells = this.widgets;\n        const first = ArrayExt.findFirstIndex(cells, c => this.isSelected(c));\n        // Return early if no cells are selected.\n        if (first === -1) {\n            return { head: null, anchor: null };\n        }\n        const last = ArrayExt.findLastIndex(cells, c => this.isSelected(c), -1, first);\n        // Check that the selection is contiguous.\n        for (let i = first; i <= last; i++) {\n            if (!this.isSelected(cells[i])) {\n                throw new Error('Selection not contiguous');\n            }\n        }\n        // Check that the active cell is one of the endpoints of the selection.\n        const activeIndex = this.activeCellIndex;\n        if (first !== activeIndex && last !== activeIndex) {\n            throw new Error('Active cell not at endpoint of selection');\n        }\n        // Determine the head and anchor of the selection.\n        if (first === activeIndex) {\n            return { head: first, anchor: last };\n        }\n        else {\n            return { head: last, anchor: first };\n        }\n    }\n    /**\n     * Scroll so that the given position is centered.\n     *\n     * @param position - The vertical position in the notebook widget.\n     *\n     * @param threshold - An optional threshold for the scroll (0-50, defaults to\n     * 25).\n     *\n     * #### Notes\n     * If the position is within the threshold percentage of the widget height,\n     * measured from the center of the widget, the scroll position will not be\n     * changed. A threshold of 0 means we will always scroll so the position is\n     * centered, and a threshold of 50 means scrolling only happens if position is\n     * outside the current window.\n     */\n    scrollToPosition(position, threshold = 25) {\n        const node = this.node;\n        const ar = node.getBoundingClientRect();\n        const delta = position - ar.top - ar.height / 2;\n        if (Math.abs(delta) > (ar.height * threshold) / 100) {\n            node.scrollTop += delta;\n        }\n    }\n    /**\n     * Scroll so that the given cell is in view. Selects and activates cell.\n     *\n     * @param cell - A cell in the notebook widget.\n     *\n     */\n    scrollToCell(cell) {\n        // use Phosphor to scroll\n        ElementExt.scrollIntoViewIfNeeded(this.node, cell.node);\n        // change selection and active cell:\n        this.deselectAll();\n        this.select(cell);\n        cell.activate();\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        // Wait all cells are rendered then set fragment and update.\n        void Promise.all(this.widgets.map(widget => widget.ready)).then(() => {\n            this._fragment = fragment;\n            this.update();\n        });\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notebook panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (!this.model) {\n            return;\n        }\n        switch (event.type) {\n            case 'contextmenu':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtContextMenuCapture(event);\n                }\n                break;\n            case 'mousedown':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtMouseDownCapture(event);\n                }\n                else {\n                    this._evtMouseDown(event);\n                }\n                break;\n            case 'mouseup':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMouseup(event);\n                }\n                break;\n            case 'mousemove':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMousemove(event);\n                }\n                break;\n            case 'keydown':\n                this._ensureFocus(true);\n                break;\n            case 'dblclick':\n                this._evtDblClick(event);\n                break;\n            case 'focusin':\n                this._evtFocusIn(event);\n                break;\n            case 'focusout':\n                this._evtFocusOut(event);\n                break;\n            case 'lm-dragenter':\n                this._evtDragEnter(event);\n                break;\n            case 'lm-dragleave':\n                this._evtDragLeave(event);\n                break;\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        const node = this.node;\n        node.addEventListener('contextmenu', this, true);\n        node.addEventListener('mousedown', this, true);\n        node.addEventListener('mousedown', this);\n        node.addEventListener('keydown', this);\n        node.addEventListener('dblclick', this);\n        node.addEventListener('focusin', this);\n        node.addEventListener('focusout', this);\n        // Capture drag events for the notebook widget\n        // in order to preempt the drag/drop handlers in the\n        // code editor widgets, which can take text data.\n        node.addEventListener('lm-dragenter', this, true);\n        node.addEventListener('lm-dragleave', this, true);\n        node.addEventListener('lm-dragover', this, true);\n        node.addEventListener('lm-drop', this, true);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('contextmenu', this, true);\n        node.removeEventListener('mousedown', this, true);\n        node.removeEventListener('mousedown', this);\n        node.removeEventListener('keydown', this);\n        node.removeEventListener('dblclick', this);\n        node.removeEventListener('focusin', this);\n        node.removeEventListener('focusout', this);\n        node.removeEventListener('lm-dragenter', this, true);\n        node.removeEventListener('lm-dragleave', this, true);\n        node.removeEventListener('lm-dragover', this, true);\n        node.removeEventListener('lm-drop', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n    }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     */\n    onAfterShow(msg) {\n        this._checkCacheOnNextResize = true;\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (!this._checkCacheOnNextResize) {\n            return super.onResize(msg);\n        }\n        this._checkCacheOnNextResize = false;\n        const cache = this._cellLayoutStateCache;\n        const width = parseInt(this.node.style.width, 10);\n        if (cache) {\n            if (width === cache.width) {\n                // Cache identical, do nothing\n                return;\n            }\n        }\n        // Update cache\n        this._cellLayoutStateCache = { width };\n        // Fallback:\n        for (const w of this.widgets) {\n            if (w instanceof Cell) {\n                w.editorWidget.update();\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'before-hide'` message.\n     */\n    onBeforeHide(msg) {\n        // Update cache\n        const width = parseInt(this.node.style.width, 10);\n        this._cellLayoutStateCache = { width };\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle `update-request` messages sent to the widget.\n     */\n    onUpdateRequest(msg) {\n        const activeCell = this.activeCell;\n        // Set the appropriate classes on the cells.\n        if (this.mode === 'edit') {\n            this.addClass(EDIT_CLASS);\n            this.removeClass(COMMAND_CLASS);\n        }\n        else {\n            this.addClass(COMMAND_CLASS);\n            this.removeClass(EDIT_CLASS);\n        }\n        if (activeCell) {\n            activeCell.addClass(ACTIVE_CLASS);\n        }\n        let count = 0;\n        each(this.widgets, widget => {\n            if (widget !== activeCell) {\n                widget.removeClass(ACTIVE_CLASS);\n            }\n            widget.removeClass(OTHER_SELECTED_CLASS);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(SELECTED_CLASS);\n                count++;\n            }\n            else {\n                widget.removeClass(SELECTED_CLASS);\n            }\n        });\n        if (count > 1) {\n            activeCell === null || activeCell === void 0 ? void 0 : activeCell.addClass(OTHER_SELECTED_CLASS);\n        }\n        if (this._fragment) {\n            let el;\n            try {\n                el = this.node.querySelector(this._fragment);\n            }\n            catch (error) {\n                console.warn('Unable to set URI fragment identifier', error);\n            }\n            if (el) {\n                el.scrollIntoView();\n            }\n            this._fragment = '';\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     */\n    onCellInserted(index, cell) {\n        if (this.model && this.model.modelDB.isCollaborative) {\n            const modelDB = this.model.modelDB;\n            void modelDB.connected.then(() => {\n                if (!cell.isDisposed) {\n                    // Setup the selection style for collaborators.\n                    const localCollaborator = modelDB.collaborators.localCollaborator;\n                    cell.editor.uuid = localCollaborator.sessionId;\n                    cell.editor.selectionStyle = Object.assign(Object.assign({}, CodeEditor.defaultSelectionStyle), { color: localCollaborator.color });\n                }\n            });\n        }\n        cell.editor.edgeRequested.connect(this._onEdgeRequest, this);\n        // If the insertion happened above, increment the active cell\n        // index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex + 1\n                : this.activeCellIndex;\n    }\n    /**\n     * Handle a cell being moved.\n     */\n    onCellMoved(fromIndex, toIndex) {\n        const i = this.activeCellIndex;\n        if (fromIndex === i) {\n            this.activeCellIndex = toIndex;\n        }\n        else if (fromIndex < i && i <= toIndex) {\n            this.activeCellIndex--;\n        }\n        else if (toIndex <= i && i < fromIndex) {\n            this.activeCellIndex++;\n        }\n    }\n    /**\n     * Handle a cell being removed.\n     */\n    onCellRemoved(index, cell) {\n        // If the removal happened above, decrement the active\n        // cell index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex - 1\n                : this.activeCellIndex;\n        if (this.isSelected(cell)) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Handle a new model.\n     */\n    onModelChanged(oldValue, newValue) {\n        super.onModelChanged(oldValue, newValue);\n        // Try to set the active cell index to 0.\n        // It will be set to `-1` if there is no new model or the model is empty.\n        this.activeCellIndex = 0;\n    }\n    /**\n     * Handle edge request signals from cells.\n     */\n    _onEdgeRequest(editor, location) {\n        const prev = this.activeCellIndex;\n        if (location === 'top') {\n            this.activeCellIndex--;\n            // Move the cursor to the first position on the last line.\n            if (this.activeCellIndex < prev) {\n                const editor = this.activeCell.editor;\n                const lastLine = editor.lineCount - 1;\n                editor.setCursorPosition({ line: lastLine, column: 0 });\n            }\n        }\n        else if (location === 'bottom') {\n            this.activeCellIndex++;\n            // Move the cursor to the first character.\n            if (this.activeCellIndex > prev) {\n                const editor = this.activeCell.editor;\n                editor.setCursorPosition({ line: 0, column: 0 });\n            }\n        }\n        this.mode = 'edit';\n    }\n    /**\n     * Ensure that the notebook has proper focus.\n     */\n    _ensureFocus(force = false) {\n        const activeCell = this.activeCell;\n        if (this.mode === 'edit' && activeCell) {\n            if (!activeCell.editor.hasFocus()) {\n                activeCell.editor.focus();\n            }\n        }\n        if (force && !this.node.contains(document.activeElement)) {\n            this.node.focus();\n        }\n    }\n    /**\n     * Find the cell index containing the target html element.\n     *\n     * #### Notes\n     * Returns -1 if the cell is not found.\n     */\n    _findCell(node) {\n        // Trace up the DOM hierarchy to find the root cell node.\n        // Then find the corresponding child and select it.\n        let n = node;\n        while (n && n !== this.node) {\n            if (n.classList.contains(NB_CELL_CLASS)) {\n                const i = ArrayExt.findFirstIndex(this.widgets, widget => widget.node === n);\n                if (i !== -1) {\n                    return i;\n                }\n                break;\n            }\n            n = n.parentElement;\n        }\n        return -1;\n    }\n    /**\n     * Find the target of html mouse event and cell index containing this target.\n     *\n     * #### Notes\n     * Returned index is -1 if the cell is not found.\n     */\n    _findEventTargetAndCell(event) {\n        let target = event.target;\n        let index = this._findCell(target);\n        if (index === -1) {\n            // `event.target` sometimes gives an orphaned node in Firefox 57, which\n            // can have `null` anywhere in its parent line. If we fail to find a cell\n            // using `event.target`, try again using a target reconstructed from the\n            // position of the click event.\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            index = this._findCell(target);\n        }\n        return [target, index];\n    }\n    /**\n     * Handle `contextmenu` event.\n     */\n    _evtContextMenuCapture(event) {\n        // Allow the event to propagate un-modified if the user\n        // is holding the shift-key (and probably requesting\n        // the native context menu).\n        if (event.shiftKey) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        if (widget && widget.editorWidget.node.contains(target)) {\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` event in the capture phase for the widget.\n     */\n    _evtMouseDownCapture(event) {\n        const { button, shiftKey } = event;\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        // On OS X, the context menu may be triggered with ctrl-left-click. In\n        // Firefox, ctrl-left-click gives an event with button 2, but in Chrome,\n        // ctrl-left-click gives an event with button 0 with the ctrl modifier.\n        if (button === 2 &&\n            !shiftKey &&\n            widget &&\n            widget.editorWidget.node.contains(target)) {\n            this.mode = 'command';\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` events for the widget.\n     */\n    _evtMouseDown(event) {\n        var _a;\n        const { button, shiftKey } = event;\n        // We only handle main or secondary button actions.\n        if (!(button === 0 || button === 2)) {\n            return;\n        }\n        // Shift right-click gives the browser default behavior.\n        if (shiftKey && button === 2) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        let targetArea;\n        if (widget) {\n            if (widget.editorWidget.node.contains(target)) {\n                targetArea = 'input';\n            }\n            else if (widget.promptNode.contains(target)) {\n                targetArea = 'prompt';\n            }\n            else {\n                targetArea = 'cell';\n            }\n        }\n        else {\n            targetArea = 'notebook';\n        }\n        // Make sure we go to command mode if the click isn't in the cell editor If\n        // we do click in the cell editor, the editor handles the focus event to\n        // switch to edit mode.\n        if (targetArea !== 'input') {\n            this.mode = 'command';\n        }\n        if (targetArea === 'notebook') {\n            this.deselectAll();\n        }\n        else if (targetArea === 'prompt' || targetArea === 'cell') {\n            // We don't want to prevent the default selection behavior\n            // if there is currently text selected in an output.\n            const hasSelection = ((_a = window.getSelection()) !== null && _a !== void 0 ? _a : '').toString() !== '';\n            if (button === 0 && shiftKey && !hasSelection) {\n                // Prevent browser selecting text in prompt or output\n                event.preventDefault();\n                // Shift-click - extend selection\n                try {\n                    this.extendContiguousSelectionTo(index);\n                }\n                catch (e) {\n                    console.error(e);\n                    this.deselectAll();\n                    return;\n                }\n                // Enter selecting mode\n                this._mouseMode = 'select';\n                document.addEventListener('mouseup', this, true);\n                document.addEventListener('mousemove', this, true);\n            }\n            else if (button === 0 && !shiftKey) {\n                // Prepare to start a drag if we are on the drag region.\n                if (targetArea === 'prompt') {\n                    // Prepare for a drag start\n                    this._dragData = {\n                        pressX: event.clientX,\n                        pressY: event.clientY,\n                        index: index\n                    };\n                    // Enter possible drag mode\n                    this._mouseMode = 'couldDrag';\n                    document.addEventListener('mouseup', this, true);\n                    document.addEventListener('mousemove', this, true);\n                    event.preventDefault();\n                }\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n            }\n            else if (button === 2) {\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n                event.preventDefault();\n            }\n        }\n        else if (targetArea === 'input') {\n            if (button === 2 && !this.isSelectedOrActive(widget)) {\n                this.deselectAll();\n                this.activeCellIndex = index;\n            }\n        }\n        // If we didn't set focus above, make sure we get focus now.\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle the `'mouseup'` event on the document.\n     */\n    _evtDocumentMouseup(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // Remove the event listeners we put on the document\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        if (this._mouseMode === 'couldDrag') {\n            // We didn't end up dragging if we are here, so treat it as a click event.\n            const [, index] = this._findEventTargetAndCell(event);\n            this.deselectAll();\n            this.activeCellIndex = index;\n        }\n        this._mouseMode = null;\n    }\n    /**\n     * Handle the `'mousemove'` event for the widget.\n     */\n    _evtDocumentMousemove(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // If in select mode, update the selection\n        switch (this._mouseMode) {\n            case 'select': {\n                const target = event.target;\n                const index = this._findCell(target);\n                if (index !== -1) {\n                    this.extendContiguousSelectionTo(index);\n                }\n                break;\n            }\n            case 'couldDrag': {\n                // Check for a drag initialization.\n                const data = this._dragData;\n                const dx = Math.abs(event.clientX - data.pressX);\n                const dy = Math.abs(event.clientY - data.pressY);\n                if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD) {\n                    this._mouseMode = null;\n                    this._startDrag(data.index, event.clientX, event.clientY);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle the `'lm-dragenter'` event for the widget.\n     */\n    _evtDragEnter(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.layout.widgets[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-dragleave'` event for the widget.\n     */\n    _evtDragLeave(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n    }\n    /**\n     * Handle the `'lm-dragover'` event for the widget.\n     */\n    _evtDragOver(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        event.dropAction = event.proposedAction;\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.layout.widgets[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-drop'` event for the widget.\n     */\n    _evtDrop(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        let target = event.target;\n        while (target && target.parentElement) {\n            if (target.classList.contains(DROP_TARGET_CLASS)) {\n                target.classList.remove(DROP_TARGET_CLASS);\n                break;\n            }\n            target = target.parentElement;\n        }\n        // Model presence should be checked before calling event handlers\n        const model = this.model;\n        const source = event.source;\n        if (source === this) {\n            // Handle the case where we are moving cells within\n            // the same notebook.\n            event.dropAction = 'move';\n            const toMove = event.mimeData.getData('internal:cells');\n            // For collapsed markdown headings with hidden \"child\" cells, move all\n            // child cells as well as the markdown heading.\n            const cell = toMove[toMove.length - 1];\n            if (cell instanceof MarkdownCell && cell.headingCollapsed) {\n                const nextParent = NotebookActions.findNextParentHeading(cell, source);\n                if (nextParent > 0) {\n                    const index = findIndex(source.widgets, (possibleCell) => {\n                        return cell.model.id === possibleCell.model.id;\n                    });\n                    toMove.push(...source.widgets.slice(index + 1, nextParent));\n                }\n            }\n            // Compute the to/from indices for the move.\n            let fromIndex = ArrayExt.firstIndexOf(this.widgets, toMove[0]);\n            let toIndex = this._findCell(target);\n            // This check is needed for consistency with the view.\n            if (toIndex !== -1 && toIndex > fromIndex) {\n                toIndex -= 1;\n            }\n            else if (toIndex === -1) {\n                // If the drop is within the notebook but not on any cell,\n                // most often this means it is past the cell areas, so\n                // set it to move the cells to the end of the notebook.\n                toIndex = this.widgets.length - 1;\n            }\n            // Don't move if we are within the block of selected cells.\n            if (toIndex >= fromIndex && toIndex < fromIndex + toMove.length) {\n                return;\n            }\n            // Move the cells one by one\n            model.cells.beginCompoundOperation();\n            if (fromIndex < toIndex) {\n                each(toMove, cellWidget => {\n                    model.cells.move(fromIndex, toIndex);\n                });\n            }\n            else if (fromIndex > toIndex) {\n                each(toMove, cellWidget => {\n                    model.cells.move(fromIndex++, toIndex++);\n                });\n            }\n            model.cells.endCompoundOperation();\n        }\n        else {\n            // Handle the case where we are copying cells between\n            // notebooks.\n            event.dropAction = 'copy';\n            // Find the target cell and insert the copied cells.\n            let index = this._findCell(target);\n            if (index === -1) {\n                index = this.widgets.length;\n            }\n            const start = index;\n            const values = event.mimeData.getData(JUPYTER_CELL_MIME);\n            const factory = model.contentFactory;\n            // Insert the copies of the original cells.\n            model.cells.beginCompoundOperation();\n            each(values, (cell) => {\n                let value;\n                switch (cell.cell_type) {\n                    case 'code':\n                        value = factory.createCodeCell({ cell });\n                        break;\n                    case 'markdown':\n                        value = factory.createMarkdownCell({ cell });\n                        break;\n                    default:\n                        value = factory.createRawCell({ cell });\n                        break;\n                }\n                model.cells.insert(index++, value);\n            });\n            model.cells.endCompoundOperation();\n            // Select the inserted cells.\n            this.deselectAll();\n            this.activeCellIndex = start;\n            this.extendContiguousSelectionTo(index - 1);\n        }\n    }\n    /**\n     * Start a drag event.\n     */\n    _startDrag(index, clientX, clientY) {\n        var _a;\n        const cells = this.model.cells;\n        const selected = [];\n        const toMove = [];\n        each(this.widgets, (widget, i) => {\n            const cell = cells.get(i);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(DROP_SOURCE_CLASS);\n                selected.push(cell.toJSON());\n                toMove.push(widget);\n            }\n        });\n        const activeCell = this.activeCell;\n        let dragImage = null;\n        let countString;\n        if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'code') {\n            const executionCount = activeCell.model\n                .executionCount;\n            countString = ' ';\n            if (executionCount) {\n                countString = executionCount.toString();\n            }\n        }\n        else {\n            countString = '';\n        }\n        // Create the drag image.\n        dragImage = Private.createDragImage(selected.length, countString, (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.value.text.split('\\n')[0].slice(0, 26)) !== null && _a !== void 0 ? _a : '');\n        // Set up the drag event.\n        this._drag = new Drag({\n            mimeData: new MimeData(),\n            dragImage,\n            supportedActions: 'copy-move',\n            proposedAction: 'copy',\n            source: this\n        });\n        this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);\n        // Add mimeData for the fully reified cell widgets, for the\n        // case where the target is in the same notebook and we\n        // can just move the cells.\n        this._drag.mimeData.setData('internal:cells', toMove);\n        // Add mimeData for the text content of the selected cells,\n        // allowing for drag/drop into plain text fields.\n        const textContent = toMove.map(cell => cell.model.value.text).join('\\n');\n        this._drag.mimeData.setData('text/plain', textContent);\n        // Remove mousemove and mouseup listeners and start the drag.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        this._mouseMode = null;\n        void this._drag.start(clientX, clientY).then(action => {\n            if (this.isDisposed) {\n                return;\n            }\n            this._drag = null;\n            each(toMove, widget => {\n                widget.removeClass(DROP_SOURCE_CLASS);\n            });\n        });\n    }\n    /**\n     * Handle `focus` events for the widget.\n     */\n    _evtFocusIn(event) {\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            // If the editor itself does not have focus, ensure command mode.\n            if (!widget.editorWidget.node.contains(target)) {\n                this.mode = 'command';\n            }\n            this.activeCellIndex = index;\n            // If the editor has focus, ensure edit mode.\n            const node = widget.editorWidget.node;\n            if (node.contains(target)) {\n                this.mode = 'edit';\n            }\n            this.activeCellIndex = index;\n        }\n        else {\n            // No cell has focus, ensure command mode.\n            this.mode = 'command';\n        }\n    }\n    /**\n     * Handle `focusout` events for the notebook.\n     */\n    _evtFocusOut(event) {\n        const relatedTarget = event.relatedTarget;\n        // Bail if the window is losing focus, to preserve edit mode. This test\n        // assumes that we explicitly focus things rather than calling blur()\n        if (!relatedTarget) {\n            return;\n        }\n        // Bail if the item gaining focus is another cell,\n        // and we should not be entering command mode.\n        const index = this._findCell(relatedTarget);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            if (widget.editorWidget.node.contains(relatedTarget)) {\n                return;\n            }\n        }\n        // Otherwise enter command mode if not already.\n        if (this.mode !== 'command') {\n            this.mode = 'command';\n            // Switching to command mode currently focuses the notebook element, so\n            // refocus the relatedTarget so the focus actually switches as intended.\n            if (relatedTarget) {\n                relatedTarget.focus();\n            }\n        }\n    }\n    /**\n     * Handle `dblclick` events for the widget.\n     */\n    _evtDblClick(event) {\n        const model = this.model;\n        if (!model) {\n            return;\n        }\n        this.deselectAll();\n        const [target, index] = this._findEventTargetAndCell(event);\n        if (event.target.classList.contains(HEADING_COLLAPSER_CLASS)) {\n            return;\n        }\n        if (index === -1) {\n            return;\n        }\n        this.activeCellIndex = index;\n        if (model.cells.get(index).type === 'markdown') {\n            const widget = this.widgets[index];\n            widget.rendered = false;\n        }\n        else if (target.localName === 'img') {\n            target.classList.toggle(UNCONFINED_CLASS);\n        }\n    }\n    /**\n     * Remove selections from inactive cells to avoid\n     * spurious cursors.\n     */\n    _trimSelections() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            if (i !== this._activeCellIndex) {\n                const cell = this.widgets[i];\n                cell.model.selections.delete(cell.editor.uuid);\n            }\n        }\n    }\n}\n/**\n * The namespace for the `Notebook` class statics.\n */\n(function (Notebook) {\n    /**\n     * The default implementation of a notebook content factory..\n     *\n     * #### Notes\n     * Override methods on this class to customize the default notebook factory\n     * methods that create notebook content.\n     */\n    class ContentFactory extends StaticNotebook.ContentFactory {\n    }\n    Notebook.ContentFactory = ContentFactory;\n    Notebook.defaultContentFactory = new ContentFactory();\n})(Notebook || (Notebook = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for the selected state of a cell.\n     */\n    Private.selectedProperty = new AttachedProperty({\n        name: 'selected',\n        create: () => false\n    });\n    /**\n     * A custom panel layout for the notebook.\n     */\n    class NotebookPanelLayout extends PanelLayout {\n        /**\n         * A message handler invoked on an `'update-request'` message.\n         *\n         * #### Notes\n         * This is a reimplementation of the base class method,\n         * and is a no-op.\n         */\n        onUpdateRequest(msg) {\n            // This is a no-op.\n        }\n    }\n    Private.NotebookPanelLayout = NotebookPanelLayout;\n    /**\n     * Create a cell drag image.\n     */\n    function createDragImage(count, promptNumber, cellContent) {\n        if (count > 1) {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n        }\n        else {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n        }\n    }\n    Private.createDragImage = createDragImage;\n    /**\n     * Process the `IOptions` passed to the notebook widget.\n     *\n     * #### Notes\n     * This defaults the content factory to that in the `Notebook` namespace.\n     */\n    function processNotebookOptions(options) {\n        if (options.contentFactory) {\n            return options;\n        }\n        else {\n            return {\n                rendermime: options.rendermime,\n                languagePreference: options.languagePreference,\n                contentFactory: Notebook.defaultContentFactory,\n                mimeTypeService: options.mimeTypeService\n            };\n        }\n    }\n    Private.processNotebookOptions = processNotebookOptions;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, Printing, showDialog } from '@jupyterlab/apputils';\nimport { isMarkdownCellModel } from '@jupyterlab/cells';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { DocumentWidget } from '@jupyterlab/docregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { each } from '@lumino/algorithm';\nimport { Token } from '@lumino/coreutils';\nimport { Notebook } from './widget';\n/**\n * The class name added to notebook panels.\n */\nconst NOTEBOOK_PANEL_CLASS = 'jp-NotebookPanel';\nconst NOTEBOOK_PANEL_TOOLBAR_CLASS = 'jp-NotebookPanel-toolbar';\nconst NOTEBOOK_PANEL_NOTEBOOK_CLASS = 'jp-NotebookPanel-notebook';\n/**\n * The class name to add when the document is loaded for the search box.\n */\nconst SEARCH_DOCUMENT_LOADED_CLASS = 'jp-DocumentSearch-document-loaded';\n/**\n * A widget that hosts a notebook toolbar and content area.\n *\n * #### Notes\n * The widget keeps the document metadata in sync with the current\n * kernel on the context.\n */\nexport class NotebookPanel extends DocumentWidget {\n    /**\n     * Construct a new notebook panel.\n     */\n    constructor(options) {\n        super(options);\n        /**\n         * Whether we are currently in a series of autorestarts we have already\n         * notified the user about.\n         */\n        this._autorestarting = false;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        // Set up CSS classes\n        this.addClass(NOTEBOOK_PANEL_CLASS);\n        this.toolbar.addClass(NOTEBOOK_PANEL_TOOLBAR_CLASS);\n        this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);\n        // Set up things related to the context\n        this.content.model = this.context.model;\n        this.context.sessionContext.kernelChanged.connect(this._onKernelChanged, this);\n        this.context.sessionContext.statusChanged.connect(this._onSessionStatusChanged, this);\n        this.content.fullyRendered.connect(this._onFullyRendered, this);\n        this.context.saveState.connect(this._onSave, this);\n        void this.revealed.then(() => {\n            if (this.isDisposed) {\n                // this widget has already been disposed, bail\n                return;\n            }\n            // Set the document edit mode on initial open if it looks like a new document.\n            if (this.content.widgets.length === 1) {\n                const cellModel = this.content.widgets[0].model;\n                if (cellModel.type === 'code' && cellModel.value.text === '') {\n                    this.content.mode = 'edit';\n                }\n            }\n        });\n    }\n    _onSave(sender, state) {\n        if (state === 'started' && this.model) {\n            // Find markdown cells\n            const { cells } = this.model;\n            each(cells, cell => {\n                if (isMarkdownCellModel(cell)) {\n                    for (const key of cell.attachments.keys) {\n                        if (!cell.value.text.includes(key)) {\n                            cell.attachments.remove(key);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * The session context used by the panel.\n     */\n    get sessionContext() {\n        return this.context.sessionContext;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this.content.model;\n    }\n    /**\n     * Update the options for the current notebook panel.\n     *\n     * @param config new options to set\n     */\n    setConfig(config) {\n        this.content.editorConfig = config.editorConfig;\n        this.content.notebookConfig = config.notebookConfig;\n        // Update kernel shutdown behavior\n        const kernelPreference = this.context.sessionContext.kernelPreference;\n        this.context.sessionContext.kernelPreference = Object.assign(Object.assign({}, kernelPreference), { shutdownOnDispose: config.kernelShutdown });\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        void this.context.ready.then(() => {\n            this.content.setFragment(fragment);\n        });\n    }\n    /**\n     * Dispose of the resources used by the widget.\n     */\n    dispose() {\n        this.content.dispose();\n        super.dispose();\n    }\n    /**\n     * Prints the notebook by converting to HTML with nbconvert.\n     */\n    [Printing.symbol]() {\n        return async () => {\n            // Save before generating HTML\n            if (this.context.model.dirty && !this.context.model.readOnly) {\n                await this.context.save();\n            }\n            await Printing.printURL(PageConfig.getNBConvertURL({\n                format: 'html',\n                download: false,\n                path: this.context.path\n            }));\n        };\n    }\n    /**\n     * Handle a fully rendered signal notebook.\n     */\n    _onFullyRendered(notebook, fullyRendered) {\n        fullyRendered\n            ? this.removeClass(SEARCH_DOCUMENT_LOADED_CLASS)\n            : this.addClass(SEARCH_DOCUMENT_LOADED_CLASS);\n    }\n    /**\n     * Handle a change in the kernel by updating the document metadata.\n     */\n    _onKernelChanged(sender, args) {\n        if (!this.model || !args.newValue) {\n            return;\n        }\n        const { newValue } = args;\n        void newValue.info.then(info => {\n            var _a;\n            if (this.model &&\n                ((_a = this.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === newValue) {\n                this._updateLanguage(info.language_info);\n            }\n        });\n        void this._updateSpec(newValue);\n    }\n    _onSessionStatusChanged(sender, status) {\n        var _a;\n        // If the status is autorestarting, and we aren't already in a series of\n        // autorestarts, show the dialog.\n        if (status === 'autorestarting' && !this._autorestarting) {\n            // The kernel died and the server is restarting it. We notify the user so\n            // they know why their kernel state is gone.\n            void showDialog({\n                title: this._trans.__('Kernel Restarting'),\n                body: this._trans.__('The kernel for %1 appears to have died. It will restart automatically.', (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n            this._autorestarting = true;\n        }\n        else if (status === 'restarting') {\n            // Another autorestart attempt will first change the status to\n            // restarting, then to autorestarting again, so we don't reset the\n            // autorestarting status if the status is 'restarting'.\n            /* no-op */\n        }\n        else {\n            this._autorestarting = false;\n        }\n    }\n    /**\n     * Update the kernel language.\n     */\n    _updateLanguage(language) {\n        this.model.metadata.set('language_info', language);\n    }\n    /**\n     * Update the kernel spec.\n     */\n    async _updateSpec(kernel) {\n        const spec = await kernel.spec;\n        if (this.isDisposed) {\n            return;\n        }\n        this.model.metadata.set('kernelspec', {\n            name: kernel.name,\n            display_name: spec === null || spec === void 0 ? void 0 : spec.display_name,\n            language: spec === null || spec === void 0 ? void 0 : spec.language\n        });\n    }\n}\n/**\n * A namespace for `NotebookPanel` statics.\n */\n(function (NotebookPanel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Notebook.ContentFactory {\n        /**\n         * Create a new content area for the panel.\n         */\n        createNotebook(options) {\n            return new Notebook(options);\n        }\n    }\n    NotebookPanel.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the notebook panel.\n     */\n    NotebookPanel.defaultContentFactory = new ContentFactory();\n    /* tslint:disable */\n    /**\n     * The notebook renderer token.\n     */\n    NotebookPanel.IContentFactory = new Token('@jupyterlab/notebook:IContentFactory');\n    /* tslint:enable */\n})(NotebookPanel || (NotebookPanel = {}));\n//# sourceMappingURL=panel.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The notebook widget factory token.\n */\nexport const INotebookWidgetFactory = new Token('@jupyterlab/notebook:INotebookWidgetFactory');\n/* tslint:enable */\n/* tslint:disable */\n/**\n * The notebook tools token.\n */\nexport const INotebookTools = new Token('@jupyterlab/notebook:INotebookTools');\n/* tslint:disable */\n/**\n * The notebook tracker token.\n */\nexport const INotebookTracker = new Token('@jupyterlab/notebook:INotebookTracker');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { Signal } from '@lumino/signaling';\nexport class NotebookTracker extends WidgetTracker {\n    constructor() {\n        super(...arguments);\n        this._activeCell = null;\n        this._activeCellChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n    }\n    /**\n     * The currently focused cell.\n     *\n     * #### Notes\n     * This is a read-only property. If there is no cell with the focus, then this\n     * value is `null`.\n     */\n    get activeCell() {\n        const widget = this.currentWidget;\n        if (!widget) {\n            return null;\n        }\n        return widget.content.activeCell || null;\n    }\n    /**\n     * A signal emitted when the current active cell changes.\n     *\n     * #### Notes\n     * If there is no cell with the focus, then `null` will be emitted.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the selection state changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * Add a new notebook panel to the tracker.\n     *\n     * @param panel - The notebook panel being added.\n     */\n    add(panel) {\n        const promise = super.add(panel);\n        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        panel.content.selectionChanged.connect(this._onSelectionChanged, this);\n        return promise;\n    }\n    /**\n     * Dispose of the resources held by the tracker.\n     */\n    dispose() {\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Handle the current change event.\n     */\n    onCurrentChanged(widget) {\n        // Store an internal reference to active cell to prevent false positives.\n        const activeCell = this.activeCell;\n        if (activeCell && activeCell === this._activeCell) {\n            return;\n        }\n        this._activeCell = activeCell;\n        if (!widget) {\n            return;\n        }\n        // Since the notebook has changed, immediately signal an active cell change\n        this._activeCellChanged.emit(widget.content.activeCell || null);\n    }\n    _onActiveCellChanged(sender, cell) {\n        // Check if the active cell change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._activeCell = cell || null;\n            this._activeCellChanged.emit(this._activeCell);\n        }\n    }\n    _onSelectionChanged(sender) {\n        // Check if the selection change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n}\n//# sourceMappingURL=tracker.js.map","import { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { notTrustedIcon, trustedIcon } from '@jupyterlab/ui-components';\nimport { toArray } from '@lumino/algorithm';\nimport React from 'react';\n/**\n * Determine the notebook trust status message.\n */\nfunction cellTrust(props, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    if (props.trustedCells === props.totalCells) {\n        return [\n            trans.__('Notebook trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-trusted'\n        ];\n    }\n    else if (props.activeCellTrusted) {\n        return [\n            trans.__('Active cell trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-trusted'\n        ];\n    }\n    else {\n        return [\n            trans.__('Notebook not trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-untrusted'\n        ];\n    }\n}\n/**\n * A pure function for a notebook trust status component.\n *\n * @param props: the props for the component.\n *\n * @returns a tsx component for notebook trust.\n */\nfunction NotebookTrustComponent(props) {\n    if (props.allCellsTrusted) {\n        return React.createElement(trustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n    else {\n        return React.createElement(notTrustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n}\n/**\n * The NotebookTrust status item.\n */\nexport class NotebookTrustStatus extends VDomRenderer {\n    /**\n     * Construct a new status item.\n     */\n    constructor(translator) {\n        super(new NotebookTrustStatus.Model());\n        this.translator = translator || nullTranslator;\n    }\n    /**\n     * Render the NotebookTrust status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = cellTrust(this.model, this.translator)[0];\n        return (React.createElement(\"div\", null,\n            React.createElement(NotebookTrustComponent, { allCellsTrusted: this.model.trustedCells === this.model.totalCells, activeCellTrusted: this.model.activeCellTrusted, totalCells: this.model.totalCells, trustedCells: this.model.trustedCells })));\n    }\n}\n/**\n * A namespace for NotebookTrust statics.\n */\n(function (NotebookTrustStatus) {\n    /**\n     * A VDomModel for the NotebookTrust status item.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            this._trustedCells = 0;\n            this._totalCells = 0;\n            this._activeCellTrusted = false;\n            this._notebook = null;\n        }\n        /**\n         * The number of trusted cells in the current notebook.\n         */\n        get trustedCells() {\n            return this._trustedCells;\n        }\n        /**\n         * The total number of cells in the current notebook.\n         */\n        get totalCells() {\n            return this._totalCells;\n        }\n        /**\n         * Whether the active cell is trusted.\n         */\n        get activeCellTrusted() {\n            return this._activeCellTrusted;\n        }\n        /**\n         * The current notebook for the model.\n         */\n        get notebook() {\n            return this._notebook;\n        }\n        set notebook(model) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.activeCellChanged.disconnect(this._onActiveCellChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onModelChanged, this);\n            }\n            const oldState = this._getAllState();\n            this._notebook = model;\n            if (this._notebook === null) {\n                this._trustedCells = 0;\n                this._totalCells = 0;\n                this._activeCellTrusted = false;\n            }\n            else {\n                // Add listeners\n                this._notebook.activeCellChanged.connect(this._onActiveCellChanged, this);\n                this._notebook.modelContentChanged.connect(this._onModelChanged, this);\n                // Derive values\n                if (this._notebook.activeCell !== undefined) {\n                    this._activeCellTrusted = this._notebook.activeCell.model.trusted;\n                }\n                else {\n                    this._activeCellTrusted = false;\n                }\n                const { total, trusted } = this._deriveCellTrustState(this._notebook.model);\n                this._totalCells = total;\n                this._trustedCells = trusted;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the notebook model changes, update the trust state.\n         */\n        _onModelChanged(notebook) {\n            const oldState = this._getAllState();\n            const { total, trusted } = this._deriveCellTrustState(notebook.model);\n            this._totalCells = total;\n            this._trustedCells = trusted;\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the active cell changes, update the trust state.\n         */\n        _onActiveCellChanged(model, cell) {\n            const oldState = this._getAllState();\n            if (cell) {\n                this._activeCellTrusted = cell.model.trusted;\n            }\n            else {\n                this._activeCellTrusted = false;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Given a notebook model, figure out how many of the cells are trusted.\n         */\n        _deriveCellTrustState(model) {\n            if (model === null) {\n                return { total: 0, trusted: 0 };\n            }\n            const cells = toArray(model.cells);\n            const trusted = cells.reduce((accum, current) => {\n                if (current.trusted) {\n                    return accum + 1;\n                }\n                else {\n                    return accum;\n                }\n            }, 0);\n            const total = cells.length;\n            return {\n                total,\n                trusted\n            };\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._trustedCells, this._totalCells, this.activeCellTrusted];\n        }\n        /**\n         * Trigger a change in the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] ||\n                oldState[1] !== newState[1] ||\n                oldState[2] !== newState[2]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    NotebookTrustStatus.Model = Model;\n})(NotebookTrustStatus || (NotebookTrustStatus = {}));\n//# sourceMappingURL=truststatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { sessionContextDialogs } from '@jupyterlab/apputils';\nimport { ABCWidgetFactory } from '@jupyterlab/docregistry';\nimport { ToolbarItems } from './default-toolbar';\nimport { NotebookPanel } from './panel';\nimport { StaticNotebook } from './widget';\n/**\n * A widget factory for notebook panels.\n */\nexport class NotebookWidgetFactory extends ABCWidgetFactory {\n    /**\n     * Construct a new notebook widget factory.\n     *\n     * @param options - The options used to construct the factory.\n     */\n    constructor(options) {\n        super(options);\n        this.rendermime = options.rendermime;\n        this.contentFactory =\n            options.contentFactory || NotebookPanel.defaultContentFactory;\n        this.mimeTypeService = options.mimeTypeService;\n        this._editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this._notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._sessionDialogs = options.sessionDialogs || sessionContextDialogs;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n    }\n    /**\n     * Create a new widget.\n     *\n     * #### Notes\n     * The factory will start the appropriate kernel.\n     */\n    createNewWidget(context, source) {\n        const nbOptions = {\n            rendermime: source\n                ? source.content.rendermime\n                : this.rendermime.clone({ resolver: context.urlResolver }),\n            contentFactory: this.contentFactory,\n            mimeTypeService: this.mimeTypeService,\n            editorConfig: source ? source.content.editorConfig : this._editorConfig,\n            notebookConfig: source\n                ? source.content.notebookConfig\n                : this._notebookConfig\n        };\n        const content = this.contentFactory.createNotebook(nbOptions);\n        return new NotebookPanel({ context, content });\n    }\n    /**\n     * Default factory for toolbar items to be added after the widget is created.\n     */\n    defaultToolbarFactory(widget) {\n        return ToolbarItems.getDefaultItems(widget, this._sessionDialogs, this.translator);\n    }\n}\n//# sourceMappingURL=widgetfactory.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nexport function convertYMapEventToMapChange(event) {\n    let changes = new Map();\n    event.changes.keys.forEach((event, key) => {\n        changes.set(key, {\n            action: event.action,\n            oldValue: event.oldValue,\n            newValue: this.ymeta.get(key)\n        });\n    });\n    return changes;\n}\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n */\nexport const createMutex = () => {\n    let token = true;\n    return (f) => {\n        if (token) {\n            token = false;\n            try {\n                f();\n            }\n            finally {\n                token = true;\n            }\n        }\n    };\n};\n//# sourceMappingURL=utils.js.map"],"sourceRoot":""}