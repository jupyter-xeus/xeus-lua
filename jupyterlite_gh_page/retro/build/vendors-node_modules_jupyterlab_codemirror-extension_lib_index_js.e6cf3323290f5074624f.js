(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_codemirror-extension_lib_index_js"],{

/***/ 52099:
/*!************************************************************************!*\
  !*** ../../node_modules/@jupyterlab/codemirror-extension/lib/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "editorSyntaxStatus": () => (/* binding */ editorSyntaxStatus),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ 67599);
/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/codeeditor */ 6256);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/codemirror */ 63804);
/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/fileeditor */ 86785);
/* harmony import */ var _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/mainmenu */ 86942);
/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/settingregistry */ 2832);
/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/statusbar */ 76150);
/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! codemirror */ 26260);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_8__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module codemirror-extension
 */









/**
 * The command IDs used by the codemirror plugin.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.changeKeyMap = 'codemirror:change-keymap';
    CommandIDs.changeTheme = 'codemirror:change-theme';
    CommandIDs.changeMode = 'codemirror:change-mode';
    CommandIDs.find = 'codemirror:find';
    CommandIDs.goToLine = 'codemirror:go-to-line';
})(CommandIDs || (CommandIDs = {}));
/** The CodeMirror singleton. */
const codemirrorSingleton = {
    id: '@jupyterlab/codemirror-extension:codemirror',
    provides: _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.ICodeMirror,
    activate: activateCodeMirror
};
/**
 * The editor services.
 */
const services = {
    id: '@jupyterlab/codemirror-extension:services',
    provides: _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.IEditorServices,
    activate: activateEditorServices
};
/**
 * The editor commands.
 */
const commands = {
    id: '@jupyterlab/codemirror-extension:commands',
    requires: [_jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorTracker, _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__.ISettingRegistry, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__.ITranslator, _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.ICodeMirror],
    optional: [_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__.IMainMenu],
    activate: activateEditorCommands,
    autoStart: true
};
/**
 * The JupyterLab plugin for the EditorSyntax status item.
 */
const editorSyntaxStatus = {
    id: '@jupyterlab/codemirror-extension:editor-syntax-status',
    autoStart: true,
    requires: [_jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorTracker, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__.ITranslator],
    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6__.IStatusBar],
    activate: (app, tracker, labShell, translator, statusBar) => {
        if (!statusBar) {
            // Automatically disable if statusbar missing
            return;
        }
        const item = new _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.EditorSyntaxStatus({ commands: app.commands, translator });
        labShell.currentChanged.connect(() => {
            const current = labShell.currentWidget;
            if (current && tracker.has(current) && item.model) {
                item.model.editor = current.content.editor;
            }
        });
        statusBar.registerStatusItem('@jupyterlab/codemirror-extension:editor-syntax-status', {
            item,
            align: 'left',
            rank: 0,
            isActive: () => !!labShell.currentWidget &&
                !!tracker.currentWidget &&
                labShell.currentWidget === tracker.currentWidget
        });
    }
};
/**
 * Export the plugins as default.
 */
const plugins = [
    commands,
    services,
    editorSyntaxStatus,
    codemirrorSingleton
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugins);
/**
 * The plugin ID used as the key in the setting registry.
 */
const id = commands.id;
/**
 * Set up the editor services.
 */
function activateEditorServices(app) {
    (codemirror__WEBPACK_IMPORTED_MODULE_8___default().prototype.save) = () => {
        void app.commands.execute('docmanager:save');
    };
    return _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.editorServices;
}
/**
 * Simplest implementation of the CodeMirror singleton provider.
 */
class CodeMirrorSingleton {
    get CodeMirror() {
        return (codemirror__WEBPACK_IMPORTED_MODULE_8___default());
    }
    async ensureVimKeymap() {
        if (!('Vim' in (codemirror__WEBPACK_IMPORTED_MODULE_8___default()))) {
            // @ts-expect-error
            await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_codemirror_lib_codemirror_js"), __webpack_require__.e("vendors-node_modules_codemirror_addon_dialog_dialog_js-node_modules_codemirror_addon_edit_mat-b0885c"), __webpack_require__.e("vendors-node_modules_codemirror_keymap_vim_js")]).then(__webpack_require__.t.bind(__webpack_require__, /*! codemirror/keymap/vim.js */ 50832, 23));
        }
    }
}
/**
 * Set up the CodeMirror singleton.
 */
function activateCodeMirror(app) {
    return new CodeMirrorSingleton();
}
/**
 * Set up the editor widget menu and commands.
 */
function activateEditorCommands(app, tracker, settingRegistry, translator, codeMirror, mainMenu) {
    var _a;
    const trans = translator.load('jupyterlab');
    const { commands, restored } = app;
    let { theme, keyMap, scrollPastEnd, styleActiveLine, styleSelectedText, selectionPointer, lineWiseCopyCut } = _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.CodeMirrorEditor.defaultConfig;
    /**
     * Update the setting values.
     */
    async function updateSettings(settings) {
        var _a, _b, _c, _d, _e;
        keyMap = settings.get('keyMap').composite || keyMap;
        // Lazy loading of vim mode
        if (keyMap === 'vim') {
            await codeMirror.ensureVimKeymap();
        }
        theme = settings.get('theme').composite || theme;
        // Lazy loading of theme stylesheets
        if (theme !== 'jupyter' && theme !== 'default') {
            const filename = theme === 'solarized light' || theme === 'solarized dark'
                ? 'solarized'
                : theme;
            await __webpack_require__(98908)(`./${filename}.css`);
        }
        scrollPastEnd = (_a = settings.get('scrollPastEnd').composite) !== null && _a !== void 0 ? _a : scrollPastEnd;
        styleActiveLine = (_b = settings.get('styleActiveLine').composite) !== null && _b !== void 0 ? _b : styleActiveLine;
        styleSelectedText = (_c = settings.get('styleSelectedText').composite) !== null && _c !== void 0 ? _c : styleSelectedText;
        selectionPointer = (_d = settings.get('selectionPointer').composite) !== null && _d !== void 0 ? _d : selectionPointer;
        lineWiseCopyCut = (_e = settings.get('lineWiseCopyCut').composite) !== null && _e !== void 0 ? _e : lineWiseCopyCut;
    }
    /**
     * Update the settings of the current tracker instances.
     */
    function updateTracker() {
        const editorOptions = {
            keyMap,
            theme,
            scrollPastEnd,
            styleActiveLine,
            styleSelectedText,
            selectionPointer,
            lineWiseCopyCut
        };
        tracker.forEach(widget => {
            if (widget.content.editor instanceof _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.CodeMirrorEditor) {
                widget.content.editor.setOptions(editorOptions);
            }
        });
    }
    // Fetch the initial state of the settings.
    Promise.all([settingRegistry.load(id), restored])
        .then(async ([settings]) => {
        await updateSettings(settings);
        updateTracker();
        settings.changed.connect(async () => {
            await updateSettings(settings);
            updateTracker();
        });
    })
        .catch((reason) => {
        console.error(reason.message);
        updateTracker();
    });
    /**
     * Handle the settings of new widgets.
     */
    tracker.widgetAdded.connect((sender, widget) => {
        const editorOptions = {
            keyMap,
            theme,
            scrollPastEnd,
            styleActiveLine,
            styleSelectedText,
            selectionPointer,
            lineWiseCopyCut
        };
        if (widget.content.editor instanceof _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.CodeMirrorEditor) {
            widget.content.editor.setOptions(editorOptions);
        }
    });
    /**
     * A test for whether the tracker has an active widget.
     */
    function isEnabled() {
        return (tracker.currentWidget !== null &&
            tracker.currentWidget === app.shell.currentWidget);
    }
    /**
     * Create a menu for the editor.
     */
    commands.addCommand(CommandIDs.changeTheme, {
        label: args => {
            var _a;
            return args.theme === 'default'
                ? trans.__('codemirror')
                : trans.__((_a = args.theme) !== null && _a !== void 0 ? _a : theme);
        },
        execute: args => {
            var _a;
            const key = 'theme';
            const value = (theme = (_a = args['theme']) !== null && _a !== void 0 ? _a : theme);
            return settingRegistry.set(id, key, value).catch((reason) => {
                console.error(`Failed to set ${id}:${key} - ${reason.message}`);
            });
        },
        isToggled: args => args['theme'] === theme
    });
    commands.addCommand(CommandIDs.changeKeyMap, {
        label: args => {
            var _a;
            const theKeyMap = (_a = args['keyMap']) !== null && _a !== void 0 ? _a : keyMap;
            return theKeyMap === 'sublime'
                ? trans.__('Sublime Text')
                : trans.__(theKeyMap);
        },
        execute: args => {
            var _a;
            const key = 'keyMap';
            const value = (keyMap = (_a = args['keyMap']) !== null && _a !== void 0 ? _a : keyMap);
            return settingRegistry.set(id, key, value).catch((reason) => {
                console.error(`Failed to set ${id}:${key} - ${reason.message}`);
            });
        },
        isToggled: args => args['keyMap'] === keyMap
    });
    commands.addCommand(CommandIDs.find, {
        label: trans.__('Find…'),
        execute: () => {
            const widget = tracker.currentWidget;
            if (!widget) {
                return;
            }
            const editor = widget.content.editor;
            editor.execCommand('find');
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.goToLine, {
        label: trans.__('Go to Line…'),
        execute: () => {
            const widget = tracker.currentWidget;
            if (!widget) {
                return;
            }
            const editor = widget.content.editor;
            editor.execCommand('jumpToLine');
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.changeMode, {
        label: args => args['name'],
        execute: args => {
            const name = args['name'];
            const widget = tracker.currentWidget;
            if (name && widget) {
                const spec = _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.Mode.findByName(name);
                if (spec) {
                    widget.content.model.mimeType = spec.mime;
                }
            }
        },
        isEnabled,
        isToggled: args => {
            const widget = tracker.currentWidget;
            if (!widget) {
                return false;
            }
            const mime = widget.content.model.mimeType;
            const spec = _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.Mode.findByMIME(mime);
            const name = spec && spec.name;
            return args['name'] === name;
        }
    });
    if (mainMenu) {
        const modeMenu = (_a = mainMenu.viewMenu.items.find(item => {
            var _a;
            return item.type === 'submenu' &&
                ((_a = item.submenu) === null || _a === void 0 ? void 0 : _a.id) === 'jp-mainmenu-view-codemirror-theme';
        })) === null || _a === void 0 ? void 0 : _a.submenu;
        if (modeMenu) {
            _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.Mode.getModeInfo()
                .sort((a, b) => {
                const aName = a.name || '';
                const bName = b.name || '';
                return aName.localeCompare(bName);
            })
                .forEach(spec => {
                // Avoid mode name with a curse word.
                if (spec.mode.indexOf('brainf') === 0) {
                    return;
                }
                modeMenu.addItem({
                    command: CommandIDs.changeMode,
                    args: Object.assign({}, spec) // TODO: Casting to `any` until lumino typings are fixed
                });
            });
        }
        // Add go to line capabilities to the edit menu.
        mainMenu.editMenu.goToLiners.add({
            tracker,
            goToLine: (widget) => {
                const editor = widget.content.editor;
                editor.execCommand('jumpToLine');
            }
        });
    }
}
//# sourceMappingURL=index.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jupyterlab_codemirror-extension_lib_index_js.e6cf3323290f5074624f.js.map