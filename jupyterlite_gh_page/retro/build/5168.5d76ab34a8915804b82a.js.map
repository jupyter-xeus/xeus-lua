{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/widget.js"],"names":["ITooltipManager","Token","BODY_CLASS","USE_CAPTURE","Tooltip","Widget","constructor","options","super","this","_content","layout","PanelLayout","model","MimeModel","data","bundle","anchor","addClass","hide","_editor","editor","_position","position","_rendermime","rendermime","mimeType","preferredMimeType","createRenderer","renderModel","addWidget","dispose","handleEvent","event","isHidden","isDisposed","node","target","type","contains","activate","_evtScroll","onActivateRequest","msg","tabIndex","focus","onAfterAttach","document","body","classList","add","addEventListener","update","onBeforeDetach","remove","removeEventListener","onUpdateRequest","show","_setGeometry","_getTokenPosition","cursor","getCursorPosition","end","getOffsetAt","line","getLine","tokens","substring","split","last","length","start","getPositionAt","getCoordinateForPosition","style","window","getComputedStyle","paddingLeft","parseInt","HoverBox","host","maxHeight","minHeight","offset","horizontal","privilege"],"mappings":"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","file":"5168.5d76ab34a8915804b82a.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The tooltip manager token.\n */\nexport const ITooltipManager = new Token('@jupyterlab/tooltip:ITooltipManager');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { HoverBox } from '@jupyterlab/apputils';\nimport { MimeModel } from '@jupyterlab/rendermime';\nimport { PanelLayout, Widget } from '@lumino/widgets';\n/**\n * The class name added to each tooltip.\n */\nconst TOOLTIP_CLASS = 'jp-Tooltip';\n/**\n * The class name added to the tooltip content.\n */\nconst CONTENT_CLASS = 'jp-Tooltip-content';\n/**\n * The class added to the body when a tooltip exists on the page.\n */\nconst BODY_CLASS = 'jp-mod-tooltip';\n/**\n * The minimum height of a tooltip widget.\n */\nconst MIN_HEIGHT = 20;\n/**\n * The maximum height of a tooltip widget.\n */\nconst MAX_HEIGHT = 250;\n/**\n * A flag to indicate that event handlers are caught in the capture phase.\n */\nconst USE_CAPTURE = true;\n/**\n * A tooltip widget.\n */\nexport class Tooltip extends Widget {\n    /**\n     * Instantiate a tooltip.\n     */\n    constructor(options) {\n        super();\n        this._content = null;\n        const layout = (this.layout = new PanelLayout());\n        const model = new MimeModel({ data: options.bundle });\n        this.anchor = options.anchor;\n        this.addClass(TOOLTIP_CLASS);\n        this.hide();\n        this._editor = options.editor;\n        this._position = options.position;\n        this._rendermime = options.rendermime;\n        const mimeType = this._rendermime.preferredMimeType(options.bundle, 'any');\n        if (!mimeType) {\n            return;\n        }\n        this._content = this._rendermime.createRenderer(mimeType);\n        void this._content.renderModel(model);\n        this._content.addClass(CONTENT_CLASS);\n        layout.addWidget(this._content);\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this._content) {\n            this._content.dispose();\n            this._content = null;\n        }\n        super.dispose();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (this.isHidden || this.isDisposed) {\n            return;\n        }\n        const { node } = this;\n        const target = event.target;\n        switch (event.type) {\n            case 'keydown':\n                if (node.contains(target)) {\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'mousedown':\n                if (node.contains(target)) {\n                    this.activate();\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'scroll':\n                this._evtScroll(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this.node.tabIndex = 0;\n        this.node.focus();\n    }\n    /**\n     * Handle `'after-attach'` messages.\n     */\n    onAfterAttach(msg) {\n        document.body.classList.add(BODY_CLASS);\n        document.addEventListener('keydown', this, USE_CAPTURE);\n        document.addEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.addEventListener('scroll', this, USE_CAPTURE);\n        this.update();\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        document.body.classList.remove(BODY_CLASS);\n        document.removeEventListener('keydown', this, USE_CAPTURE);\n        document.removeEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.removeEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle `'update-request'` messages.\n     */\n    onUpdateRequest(msg) {\n        if (this.isHidden) {\n            this.show();\n        }\n        this._setGeometry();\n        super.onUpdateRequest(msg);\n    }\n    /**\n     * Handle scroll events for the widget\n     */\n    _evtScroll(event) {\n        // All scrolls except scrolls in the actual hover box node may cause the\n        // referent editor that anchors the node to move, so the only scroll events\n        // that can safely be ignored are ones that happen inside the hovering node.\n        if (this.node.contains(event.target)) {\n            return;\n        }\n        this.update();\n    }\n    /**\n     * Find the position of the first character of the current token.\n     */\n    _getTokenPosition() {\n        const editor = this._editor;\n        const cursor = editor.getCursorPosition();\n        const end = editor.getOffsetAt(cursor);\n        const line = editor.getLine(cursor.line);\n        if (!line) {\n            return;\n        }\n        const tokens = line.substring(0, end).split(/\\W+/);\n        const last = tokens[tokens.length - 1];\n        const start = last ? end - last.length : end;\n        return editor.getPositionAt(start);\n    }\n    /**\n     * Set the geometry of the tooltip widget.\n     */\n    _setGeometry() {\n        // determine position for hover box placement\n        const position = this._position ? this._position : this._getTokenPosition();\n        if (!position) {\n            return;\n        }\n        const editor = this._editor;\n        const anchor = editor.getCoordinateForPosition(position);\n        const style = window.getComputedStyle(this.node);\n        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;\n        // Calculate the geometry of the tooltip.\n        HoverBox.setGeometry({\n            anchor,\n            host: editor.host,\n            maxHeight: MAX_HEIGHT,\n            minHeight: MIN_HEIGHT,\n            node: this.node,\n            offset: { horizontal: -1 * paddingLeft },\n            privilege: 'below',\n            style: style\n        });\n    }\n}\n//# sourceMappingURL=widget.js.map"],"sourceRoot":""}