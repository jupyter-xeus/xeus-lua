{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/index.js"],"names":["shortcuts","id","requires","ISettingRegistry","ITranslator","activate","async","app","registry","translator","trans","load","commands","canonical","loaded","populate","schema","listCommands","join","properties","default","Object","keys","plugins","map","plugin","concat","reduce","acc","val","sort","a","b","command","localeCompare","description","__","pluginChanged","connect","sender","oldShortcuts","newShortcuts","undefined","JSONExt","reload","transform","compose","_a","_b","_c","_d","defaults","user","data","composite","SettingRegistry","fetch","raw","version","settings","Private","loadShortcuts","changed","error","console","autoStart","disposables","dispose","options","value","isArray","Array","normalizeOptions","add","addKeyBinding","DisposableSet"],"mappings":"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","file":"1498.261abd2d12acccca4662.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module shortcuts-extension\n */\nimport { ISettingRegistry, SettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { JSONExt } from '@lumino/coreutils';\nimport { DisposableSet } from '@lumino/disposable';\n/**\n * The default shortcuts extension.\n *\n * #### Notes\n * Shortcut values are stored in the setting system. The default values for each\n * shortcut are preset in the settings schema file of this extension.\n * Additionally, each shortcut can be individually set by the end user by\n * modifying its setting (either in the text editor or by modifying its\n * underlying JSON schema file).\n *\n * When setting shortcut selectors, there are two concepts to consider:\n * specificity and matchability. These two interact in sometimes\n * counterintuitive ways. Keyboard events are triggered from an element and\n * they propagate up the DOM until they reach the `documentElement` (`<body>`).\n *\n * When a registered shortcut sequence is fired, the shortcut manager checks\n * the node that fired the event and each of its ancestors until a node matches\n * one or more registered selectors. The *first* matching selector in the\n * chain of ancestors will invoke the shortcut handler and the traversal will\n * end at that point. If a node matches more than one selector, the handler for\n * whichever selector is more *specific* fires.\n * @see https://www.w3.org/TR/css3-selectors/#specificity\n *\n * The practical consequence of this is that a very broadly matching selector,\n * e.g. `'*'` or `'div'` may match and therefore invoke a handler *before* a\n * more specific selector. The most common pitfall is to use the universal\n * (`'*'`) selector. For almost any use case where a global keyboard shortcut is\n * required, using the `'body'` selector is more appropriate.\n */\nconst shortcuts = {\n    id: '@jupyterlab/shortcuts-extension:shortcuts',\n    requires: [ISettingRegistry, ITranslator],\n    activate: async (app, registry, translator) => {\n        const trans = translator.load('jupyterlab');\n        const { commands } = app;\n        let canonical;\n        let loaded = {};\n        /**\n         * Populate the plugin's schema defaults.\n         */\n        function populate(schema) {\n            const commands = app.commands.listCommands().join('\\n');\n            loaded = {};\n            schema.properties.shortcuts.default = Object.keys(registry.plugins)\n                .map(plugin => {\n                const shortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                loaded[plugin] = shortcuts;\n                return shortcuts;\n            })\n                .concat([schema.properties.shortcuts.default])\n                .reduce((acc, val) => acc.concat(val), []) // flatten one level\n                .sort((a, b) => a.command.localeCompare(b.command));\n            schema.properties.shortcuts.description = trans.__(`Note: To disable a system default shortcut,\ncopy it to User Preferences and add the\n\"disabled\" key, for example:\n{\n    \"command\": \"application:activate-next-tab\",\n    \"keys\": [\n        \"Ctrl Shift ]\"\n    ],\n    \"selector\": \"body\",\n    \"disabled\": true\n}\n\nList of commands followed by keyboard shortcuts:\n%1\n\nList of keyboard shortcuts:`, commands);\n        }\n        registry.pluginChanged.connect(async (sender, plugin) => {\n            if (plugin !== shortcuts.id) {\n                // If the plugin changed its shortcuts, reload everything.\n                const oldShortcuts = loaded[plugin];\n                const newShortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                if (oldShortcuts === undefined ||\n                    !JSONExt.deepEqual(oldShortcuts, newShortcuts)) {\n                    canonical = null;\n                    await registry.reload(shortcuts.id);\n                }\n            }\n        });\n        // Transform the plugin object to return different schema than the default.\n        registry.transform(shortcuts.id, {\n            compose: plugin => {\n                var _a, _b, _c, _d;\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                const defaults = (_c = (_b = (_a = canonical.properties) === null || _a === void 0 ? void 0 : _a.shortcuts) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : [];\n                const user = {\n                    shortcuts: (_d = plugin.data.user.shortcuts) !== null && _d !== void 0 ? _d : []\n                };\n                const composite = {\n                    shortcuts: SettingRegistry.reconcileShortcuts(defaults, user.shortcuts)\n                };\n                plugin.data = { composite, user };\n                return plugin;\n            },\n            fetch: plugin => {\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                return {\n                    data: plugin.data,\n                    id: plugin.id,\n                    raw: plugin.raw,\n                    schema: canonical,\n                    version: plugin.version\n                };\n            }\n        });\n        try {\n            // Repopulate the canonical variable after the setting registry has\n            // preloaded all initial plugins.\n            canonical = null;\n            const settings = await registry.load(shortcuts.id);\n            Private.loadShortcuts(commands, settings.composite);\n            settings.changed.connect(() => {\n                Private.loadShortcuts(commands, settings.composite);\n            });\n        }\n        catch (error) {\n            console.error(`Loading ${shortcuts.id} failed.`, error);\n        }\n    },\n    autoStart: true\n};\n/**\n * Export the shortcut plugin as default.\n */\nexport default shortcuts;\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The internal collection of currently loaded shortcuts.\n     */\n    let disposables;\n    /**\n     * Load the keyboard shortcuts from settings.\n     */\n    function loadShortcuts(commands, composite) {\n        var _a;\n        const shortcuts = ((_a = composite === null || composite === void 0 ? void 0 : composite.shortcuts) !== null && _a !== void 0 ? _a : []);\n        if (disposables) {\n            disposables.dispose();\n        }\n        disposables = shortcuts.reduce((acc, val) => {\n            const options = normalizeOptions(val);\n            if (options) {\n                acc.add(commands.addKeyBinding(options));\n            }\n            return acc;\n        }, new DisposableSet());\n    }\n    Private.loadShortcuts = loadShortcuts;\n    /**\n     * Normalize potential keyboard shortcut options.\n     */\n    function normalizeOptions(value) {\n        if (!value || typeof value !== 'object') {\n            return undefined;\n        }\n        const { isArray } = Array;\n        const valid = 'command' in value &&\n            'keys' in value &&\n            'selector' in value &&\n            isArray(value.keys);\n        return valid ? value : undefined;\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}