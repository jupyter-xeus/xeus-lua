{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console/lib/foreign.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console/lib/history.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console/lib/panel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/console/lib/widget.js"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AACA;AAC2C;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB,uBAAuB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;AC1HA;AACA;AAC2C;AAC3C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6BAA6B;AACvE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,mC;;;;;;;;;;;;;;;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACA;AACF;AACC;AACA;AACzB,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AAC6F;AACvC;AACM;AACH;AACD;AACR;AACR;AACD;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,gEAAc;AAChD;AACA;AACA;AACA;AACA,eAAe,cAAc,kDAAK,IAAI;AACtC;AACA;AACA;AACA,aAAa,uGAAuG;AACpH,wCAAwC,mEAAc;AACtD;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe,WAAW,MAAM,GAAG,yDAAU,GAAG;AACtE;AACA;AACA;AACA,oBAAoB,gEAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,kFAA8B;AAC3D;AACA;AACA,SAAS;AACT,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,oFAAkC;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,kEAAW;AACrC;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAA0B;AAC3D;AACA;AACA;AACA;AACA,uBAAuB,gDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAK;AAC5C;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA;AACA;AACA;AACA;AACA,4CAA4C,kEAAe;AAC3D;AACA;AACA,uDAAuD,8DAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,iC;;;;;;;;;;;;;;;;;ACtLA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACO,4BAA4B,oDAAK;AACxC,kC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACyH;AAChE;AAChB;AACI;AACL;AACG;AACkB;AAClB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,mDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAM;AACnC;AACA;AACA;AACA,sCAAsC,qDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,0CAA0C,wDAAW;AACrD,0BAA0B,mEAAc;AACxC,4BAA4B,kDAAK;AACjC,0BAA0B,kDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,2CAA2C,sDAAO;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAI;AACZ;AACA,gBAAgB,kEAAe;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAA8B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gFAAiC;AAC3D,yBAAyB,kDAAI;AAC7B,0BAA0B,uDAAQ;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,kDAAkD,kFAAmC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B,kC","file":"vendors-node_modules_jupyterlab_console_lib_index_js.03d0837e4471bd274d91.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\nconst FOREIGN_CELL_CLASS = 'jp-CodeConsole-foreignCell';\n/**\n * A handler for capturing API messages from other sessions that should be\n * rendered in a given parent.\n */\nexport class ForeignHandler {\n    /**\n     * Construct a new foreign message handler.\n     */\n    constructor(options) {\n        this._enabled = false;\n        this._isDisposed = false;\n        this.sessionContext = options.sessionContext;\n        this.sessionContext.iopubMessage.connect(this.onIOPubMessage, this);\n        this._parent = options.parent;\n    }\n    /**\n     * Set whether the handler is able to inject foreign cells into a console.\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n    }\n    /**\n     * The foreign handler's parent receiver.\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Test whether the handler is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose the resources held by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Handler IOPub messages.\n     *\n     * @returns `true` if the message resulted in a new cell injection or a\n     * previously injected cell being updated and `false` for all other messages.\n     */\n    onIOPubMessage(sender, msg) {\n        var _a;\n        // Only process messages if foreign cell injection is enabled.\n        if (!this._enabled) {\n            return false;\n        }\n        const kernel = (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            return false;\n        }\n        // Check whether this message came from an external session.\n        const parent = this._parent;\n        const session = msg.parent_header.session;\n        if (session === kernel.clientId) {\n            return false;\n        }\n        const msgType = msg.header.msg_type;\n        const parentHeader = msg.parent_header;\n        const parentMsgId = parentHeader.msg_id;\n        let cell;\n        switch (msgType) {\n            case 'execute_input': {\n                const inputMsg = msg;\n                cell = this._newCell(parentMsgId);\n                const model = cell.model;\n                model.executionCount = inputMsg.content.execution_count;\n                model.value.text = inputMsg.content.code;\n                model.trusted = true;\n                parent.update();\n                return true;\n            }\n            case 'execute_result':\n            case 'display_data':\n            case 'stream':\n            case 'error': {\n                cell = this._parent.getCell(parentMsgId);\n                if (!cell) {\n                    return false;\n                }\n                const output = Object.assign(Object.assign({}, msg.content), { output_type: msgType });\n                cell.model.outputs.add(output);\n                parent.update();\n                return true;\n            }\n            case 'clear_output': {\n                const wait = msg.content.wait;\n                cell = this._parent.getCell(parentMsgId);\n                if (cell) {\n                    cell.model.outputs.clear(wait);\n                }\n                return true;\n            }\n            default:\n                return false;\n        }\n    }\n    /**\n     * Create a new code cell for an input originated from a foreign session.\n     */\n    _newCell(parentMsgId) {\n        const cell = this.parent.createCodeCell();\n        cell.addClass(FOREIGN_CELL_CLASS);\n        this._parent.addCell(cell, parentMsgId);\n        return cell;\n    }\n}\n//# sourceMappingURL=foreign.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\n/**\n * A console history manager object.\n */\nexport class ConsoleHistory {\n    /**\n     * Construct a new console history object.\n     */\n    constructor(options) {\n        this._cursor = 0;\n        this._hasSession = false;\n        this._history = [];\n        this._placeholder = '';\n        this._setByHistory = false;\n        this._isDisposed = false;\n        this._editor = null;\n        this._filtered = [];\n        this.sessionContext = options.sessionContext;\n        void this._handleKernel();\n        this.sessionContext.kernelChanged.connect(this._handleKernel, this);\n    }\n    /**\n     * The current editor used by the history manager.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(value) {\n        if (this._editor === value) {\n            return;\n        }\n        const prev = this._editor;\n        if (prev) {\n            prev.edgeRequested.disconnect(this.onEdgeRequest, this);\n            prev.model.value.changed.disconnect(this.onTextChange, this);\n        }\n        this._editor = value;\n        if (value) {\n            value.edgeRequested.connect(this.onEdgeRequest, this);\n            value.model.value.changed.connect(this.onTextChange, this);\n        }\n    }\n    /**\n     * The placeholder text that a history session began with.\n     */\n    get placeholder() {\n        return this._placeholder;\n    }\n    /**\n     * Get whether the console history manager is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the console history manager.\n     */\n    dispose() {\n        this._isDisposed = true;\n        this._history.length = 0;\n        Signal.clearData(this);\n    }\n    /**\n     * Get the previous item in the console history.\n     *\n     * @param placeholder - The placeholder string that gets temporarily added\n     * to the history only for the duration of one history session. If multiple\n     * placeholders are sent within a session, only the first one is accepted.\n     *\n     * @returns A Promise for console command text or `undefined` if unavailable.\n     */\n    back(placeholder) {\n        if (!this._hasSession) {\n            this._hasSession = true;\n            this._placeholder = placeholder;\n            // Filter the history with the placeholder string.\n            this.setFilter(placeholder);\n            this._cursor = this._filtered.length - 1;\n        }\n        --this._cursor;\n        this._cursor = Math.max(0, this._cursor);\n        const content = this._filtered[this._cursor];\n        return Promise.resolve(content);\n    }\n    /**\n     * Get the next item in the console history.\n     *\n     * @param placeholder - The placeholder string that gets temporarily added\n     * to the history only for the duration of one history session. If multiple\n     * placeholders are sent within a session, only the first one is accepted.\n     *\n     * @returns A Promise for console command text or `undefined` if unavailable.\n     */\n    forward(placeholder) {\n        if (!this._hasSession) {\n            this._hasSession = true;\n            this._placeholder = placeholder;\n            // Filter the history with the placeholder string.\n            this.setFilter(placeholder);\n            this._cursor = this._filtered.length;\n        }\n        ++this._cursor;\n        this._cursor = Math.min(this._filtered.length - 1, this._cursor);\n        const content = this._filtered[this._cursor];\n        return Promise.resolve(content);\n    }\n    /**\n     * Add a new item to the bottom of history.\n     *\n     * @param item The item being added to the bottom of history.\n     *\n     * #### Notes\n     * If the item being added is undefined or empty, it is ignored. If the item\n     * being added is the same as the last item in history, it is ignored as well\n     * so that the console's history will consist of no contiguous repetitions.\n     */\n    push(item) {\n        if (item && item !== this._history[this._history.length - 1]) {\n            this._history.push(item);\n        }\n        this.reset();\n    }\n    /**\n     * Reset the history navigation state, i.e., start a new history session.\n     */\n    reset() {\n        this._cursor = this._history.length;\n        this._hasSession = false;\n        this._placeholder = '';\n    }\n    /**\n     * Populate the history collection on history reply from a kernel.\n     *\n     * @param value The kernel message history reply.\n     *\n     * #### Notes\n     * History entries have the shape:\n     * [session: number, line: number, input: string]\n     * Contiguous duplicates are stripped out of the API response.\n     */\n    onHistory(value) {\n        this._history.length = 0;\n        let last = '';\n        let current = '';\n        if (value.content.status === 'ok') {\n            for (let i = 0; i < value.content.history.length; i++) {\n                current = value.content.history[i][2];\n                if (current !== last) {\n                    this._history.push((last = current));\n                }\n            }\n        }\n        // Reset the history navigation cursor back to the bottom.\n        this._cursor = this._history.length;\n    }\n    /**\n     * Handle a text change signal from the editor.\n     */\n    onTextChange() {\n        if (this._setByHistory) {\n            this._setByHistory = false;\n            return;\n        }\n        this.reset();\n    }\n    /**\n     * Handle an edge requested signal.\n     */\n    onEdgeRequest(editor, location) {\n        const model = editor.model;\n        const source = model.value.text;\n        if (location === 'top' || location === 'topLine') {\n            void this.back(source).then(value => {\n                if (this.isDisposed || !value) {\n                    return;\n                }\n                if (model.value.text === value) {\n                    return;\n                }\n                this._setByHistory = true;\n                model.value.text = value;\n                let columnPos = 0;\n                columnPos = value.indexOf('\\n');\n                if (columnPos < 0) {\n                    columnPos = value.length;\n                }\n                editor.setCursorPosition({ line: 0, column: columnPos });\n            });\n        }\n        else {\n            void this.forward(source).then(value => {\n                if (this.isDisposed) {\n                    return;\n                }\n                const text = value || this.placeholder;\n                if (model.value.text === text) {\n                    return;\n                }\n                this._setByHistory = true;\n                model.value.text = text;\n                const pos = editor.getPositionAt(text.length);\n                if (pos) {\n                    editor.setCursorPosition(pos);\n                }\n            });\n        }\n    }\n    /**\n     * Handle the current kernel changing.\n     */\n    async _handleKernel() {\n        var _a;\n        const kernel = (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            this._history.length = 0;\n            return;\n        }\n        return kernel.requestHistory(Private.initialRequest).then(v => {\n            this.onHistory(v);\n        });\n    }\n    /**\n     * Set the filter data.\n     *\n     * @param filterStr - The string to use when filtering the data.\n     */\n    setFilter(filterStr = '') {\n        // Apply the new filter and remove contiguous duplicates.\n        this._filtered.length = 0;\n        let last = '';\n        let current = '';\n        for (let i = 0; i < this._history.length; i++) {\n            current = this._history[i];\n            if (current !== last &&\n                filterStr === current.slice(0, filterStr.length)) {\n                this._filtered.push((last = current));\n            }\n        }\n        this._filtered.push(filterStr);\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    Private.initialRequest = {\n        output: false,\n        raw: true,\n        hist_access_type: 'tail',\n        n: 500\n    };\n})(Private || (Private = {}));\n//# sourceMappingURL=history.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module console\n */\nexport * from './foreign';\nexport * from './history';\nexport * from './panel';\nexport * from './tokens';\nexport * from './widget';\n//# sourceMappingURL=index.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { MainAreaWidget, SessionContext, sessionContextDialogs } from '@jupyterlab/apputils';\nimport { PathExt, Time } from '@jupyterlab/coreutils';\nimport { RenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { consoleIcon } from '@jupyterlab/ui-components';\nimport { Token, UUID } from '@lumino/coreutils';\nimport { Panel } from '@lumino/widgets';\nimport { CodeConsole } from './widget';\n/**\n * The class name added to console panels.\n */\nconst PANEL_CLASS = 'jp-ConsolePanel';\n/**\n * A panel which contains a console and the ability to add other children.\n */\nexport class ConsolePanel extends MainAreaWidget {\n    /**\n     * Construct a console panel.\n     */\n    constructor(options) {\n        super({ content: new Panel() });\n        this._executed = null;\n        this._connected = null;\n        this.addClass(PANEL_CLASS);\n        let { rendermime, mimeTypeService, path, basePath, name, manager, modelFactory, sessionContext, translator } = options;\n        this.translator = translator || nullTranslator;\n        const trans = this.translator.load('jupyterlab');\n        const contentFactory = (this.contentFactory =\n            options.contentFactory || ConsolePanel.defaultContentFactory);\n        const count = Private.count++;\n        if (!path) {\n            path = `${basePath || ''}/console-${count}-${UUID.uuid4()}`;\n        }\n        sessionContext = this._sessionContext =\n            sessionContext ||\n                new SessionContext({\n                    sessionManager: manager.sessions,\n                    specsManager: manager.kernelspecs,\n                    path,\n                    name: name || trans.__('Console %1', count),\n                    type: 'console',\n                    kernelPreference: options.kernelPreference,\n                    setBusy: options.setBusy\n                });\n        const resolver = new RenderMimeRegistry.UrlResolver({\n            session: sessionContext,\n            contents: manager.contents\n        });\n        rendermime = rendermime.clone({ resolver });\n        this.console = contentFactory.createConsole({\n            rendermime,\n            sessionContext: sessionContext,\n            mimeTypeService,\n            contentFactory,\n            modelFactory\n        });\n        this.content.addWidget(this.console);\n        void sessionContext.initialize().then(async (value) => {\n            if (value) {\n                await sessionContextDialogs.selectKernel(sessionContext);\n            }\n            this._connected = new Date();\n            this._updateTitlePanel();\n        });\n        this.console.executed.connect(this._onExecuted, this);\n        this._updateTitlePanel();\n        sessionContext.kernelChanged.connect(this._updateTitlePanel, this);\n        sessionContext.propertyChanged.connect(this._updateTitlePanel, this);\n        this.title.icon = consoleIcon;\n        this.title.closable = true;\n        this.id = `console-${count}`;\n    }\n    /**\n     * The session used by the panel.\n     */\n    get sessionContext() {\n        return this._sessionContext;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        this.sessionContext.dispose();\n        this.console.dispose();\n        super.dispose();\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        const prompt = this.console.promptCell;\n        if (prompt) {\n            prompt.editor.focus();\n        }\n    }\n    /**\n     * Handle `'close-request'` messages.\n     */\n    onCloseRequest(msg) {\n        super.onCloseRequest(msg);\n        this.dispose();\n    }\n    /**\n     * Handle a console execution.\n     */\n    _onExecuted(sender, args) {\n        this._executed = args;\n        this._updateTitlePanel();\n    }\n    /**\n     * Update the console panel title.\n     */\n    _updateTitlePanel() {\n        Private.updateTitle(this, this._connected, this._executed, this.translator);\n    }\n}\n/**\n * A namespace for ConsolePanel statics.\n */\n(function (ConsolePanel) {\n    /**\n     * Default implementation of `IContentFactory`.\n     */\n    class ContentFactory extends CodeConsole.ContentFactory {\n        /**\n         * Create a new console panel.\n         */\n        createConsole(options) {\n            return new CodeConsole(options);\n        }\n    }\n    ConsolePanel.ContentFactory = ContentFactory;\n    /**\n     * A default code console content factory.\n     */\n    ConsolePanel.defaultContentFactory = new ContentFactory();\n    /* tslint:disable */\n    /**\n     * The console renderer token.\n     */\n    ConsolePanel.IContentFactory = new Token('@jupyterlab/console:IContentFactory');\n    /* tslint:enable */\n})(ConsolePanel || (ConsolePanel = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The counter for new consoles.\n     */\n    Private.count = 1;\n    /**\n     * Update the title of a console panel.\n     */\n    function updateTitle(panel, connected, executed, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const sessionContext = panel.console.sessionContext.session;\n        if (sessionContext) {\n            // FIXME:\n            let caption = trans.__('Name: %1\\n', sessionContext.name) +\n                trans.__('Directory: %1\\n', PathExt.dirname(sessionContext.path)) +\n                trans.__('Kernel: %1', panel.console.sessionContext.kernelDisplayName);\n            if (connected) {\n                caption += trans.__('\\nConnected: %1', Time.format(connected.toISOString()));\n            }\n            if (executed) {\n                caption += trans.__('\\nLast Execution: %1');\n            }\n            panel.title.label = sessionContext.name;\n            panel.title.caption = caption;\n        }\n        else {\n            panel.title.label = trans.__('Console');\n            panel.title.caption = '';\n        }\n    }\n    Private.updateTitle = updateTitle;\n})(Private || (Private = {}));\n//# sourceMappingURL=panel.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The console tracker token.\n */\nexport const IConsoleTracker = new Token('@jupyterlab/console:IConsoleTracker');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Cell, CellDragUtils, CodeCell, CodeCellModel, isCodeCellModel, RawCell, RawCellModel } from '@jupyterlab/cells';\nimport { ObservableList } from '@jupyterlab/observables';\nimport { each } from '@lumino/algorithm';\nimport { MimeData } from '@lumino/coreutils';\nimport { Drag } from '@lumino/dragdrop';\nimport { Signal } from '@lumino/signaling';\nimport { Panel, PanelLayout, Widget } from '@lumino/widgets';\nimport { ConsoleHistory } from './history';\n/**\n * The data attribute added to a widget that has an active kernel.\n */\nconst KERNEL_USER = 'jpKernelUser';\n/**\n * The data attribute added to a widget can run code.\n */\nconst CODE_RUNNER = 'jpCodeRunner';\n/**\n * The class name added to console widgets.\n */\nconst CONSOLE_CLASS = 'jp-CodeConsole';\n/**\n * The class added to console cells\n */\nconst CONSOLE_CELL_CLASS = 'jp-Console-cell';\n/**\n * The class name added to the console banner.\n */\nconst BANNER_CLASS = 'jp-CodeConsole-banner';\n/**\n * The class name of the active prompt cell.\n */\nconst PROMPT_CLASS = 'jp-CodeConsole-promptCell';\n/**\n * The class name of the panel that holds cell content.\n */\nconst CONTENT_CLASS = 'jp-CodeConsole-content';\n/**\n * The class name of the panel that holds prompts.\n */\nconst INPUT_CLASS = 'jp-CodeConsole-input';\n/**\n * The timeout in ms for execution requests to the kernel.\n */\nconst EXECUTION_TIMEOUT = 250;\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\n/**\n * A widget containing a Jupyter console.\n *\n * #### Notes\n * The CodeConsole class is intended to be used within a ConsolePanel\n * instance. Under most circumstances, it is not instantiated by user code.\n */\nexport class CodeConsole extends Widget {\n    /**\n     * Construct a console widget.\n     */\n    constructor(options) {\n        super();\n        this._banner = null;\n        this._executed = new Signal(this);\n        this._mimetype = 'text/x-ipython';\n        this._msgIds = new Map();\n        this._msgIdCells = new Map();\n        this._promptCellCreated = new Signal(this);\n        this._dragData = null;\n        this._drag = null;\n        this._focusedCell = null;\n        this.addClass(CONSOLE_CLASS);\n        this.node.dataset[KERNEL_USER] = 'true';\n        this.node.dataset[CODE_RUNNER] = 'true';\n        this.node.tabIndex = -1; // Allow the widget to take focus.\n        // Create the panels that hold the content and input.\n        const layout = (this.layout = new PanelLayout());\n        this._cells = new ObservableList();\n        this._content = new Panel();\n        this._input = new Panel();\n        this.contentFactory =\n            options.contentFactory || CodeConsole.defaultContentFactory;\n        this.modelFactory = options.modelFactory || CodeConsole.defaultModelFactory;\n        this.rendermime = options.rendermime;\n        this.sessionContext = options.sessionContext;\n        this._mimeTypeService = options.mimeTypeService;\n        // Add top-level CSS classes.\n        this._content.addClass(CONTENT_CLASS);\n        this._input.addClass(INPUT_CLASS);\n        // Insert the content and input panes into the widget.\n        layout.addWidget(this._content);\n        layout.addWidget(this._input);\n        this._history = new ConsoleHistory({\n            sessionContext: this.sessionContext\n        });\n        void this._onKernelChanged();\n        this.sessionContext.kernelChanged.connect(this._onKernelChanged, this);\n        this.sessionContext.statusChanged.connect(this._onKernelStatusChanged, this);\n    }\n    /**\n     * A signal emitted when the console finished executing its prompt cell.\n     */\n    get executed() {\n        return this._executed;\n    }\n    /**\n     * A signal emitted when a new prompt cell is created.\n     */\n    get promptCellCreated() {\n        return this._promptCellCreated;\n    }\n    /**\n     * The list of content cells in the console.\n     *\n     * #### Notes\n     * This list does not include the current banner or the prompt for a console.\n     * It may include previous banners as raw cells.\n     */\n    get cells() {\n        return this._cells;\n    }\n    /*\n     * The console input prompt cell.\n     */\n    get promptCell() {\n        const inputLayout = this._input.layout;\n        return inputLayout.widgets[0] || null;\n    }\n    /**\n     * Add a new cell to the content panel.\n     *\n     * @param cell - The code cell widget being added to the content panel.\n     *\n     * @param msgId - The optional execution message id for the cell.\n     *\n     * #### Notes\n     * This method is meant for use by outside classes that want to add cells to a\n     * console. It is distinct from the `inject` method in that it requires\n     * rendered code cell widgets and does not execute them (though it can store\n     * the execution message id).\n     */\n    addCell(cell, msgId) {\n        cell.addClass(CONSOLE_CELL_CLASS);\n        this._content.addWidget(cell);\n        this._cells.push(cell);\n        if (msgId) {\n            this._msgIds.set(msgId, cell);\n            this._msgIdCells.set(cell, msgId);\n        }\n        cell.disposed.connect(this._onCellDisposed, this);\n        this.update();\n    }\n    /**\n     * Add a banner cell.\n     */\n    addBanner() {\n        if (this._banner) {\n            // An old banner just becomes a normal cell now.\n            const cell = this._banner;\n            this._cells.push(this._banner);\n            cell.disposed.connect(this._onCellDisposed, this);\n        }\n        // Create the banner.\n        const model = this.modelFactory.createRawCell({});\n        model.value.text = '...';\n        const banner = (this._banner = new RawCell({\n            model,\n            contentFactory: this.contentFactory,\n            placeholder: false\n        })).initializeState();\n        banner.addClass(BANNER_CLASS);\n        banner.readOnly = true;\n        this._content.addWidget(banner);\n    }\n    /**\n     * Clear the code cells.\n     */\n    clear() {\n        // Dispose all the content cells\n        const cells = this._cells;\n        while (cells.length > 0) {\n            cells.get(0).dispose();\n        }\n    }\n    /**\n     * Create a new cell with the built-in factory.\n     */\n    createCodeCell() {\n        const factory = this.contentFactory;\n        const options = this._createCodeCellOptions();\n        const cell = factory.createCodeCell(options);\n        cell.readOnly = true;\n        cell.model.mimeType = this._mimetype;\n        return cell;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._cells.clear();\n        this._msgIdCells = null;\n        this._msgIds = null;\n        this._history.dispose();\n        super.dispose();\n    }\n    /**\n     * Execute the current prompt.\n     *\n     * @param force - Whether to force execution without checking code\n     * completeness.\n     *\n     * @param timeout - The length of time, in milliseconds, that the execution\n     * should wait for the API to determine whether code being submitted is\n     * incomplete before attempting submission anyway. The default value is `250`.\n     */\n    async execute(force = false, timeout = EXECUTION_TIMEOUT) {\n        var _a, _b;\n        if (((_b = (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.status) === 'dead') {\n            return;\n        }\n        const promptCell = this.promptCell;\n        if (!promptCell) {\n            throw new Error('Cannot execute without a prompt cell');\n        }\n        promptCell.model.trusted = true;\n        if (force) {\n            // Create a new prompt cell before kernel execution to allow typeahead.\n            this.newPromptCell();\n            await this._execute(promptCell);\n            return;\n        }\n        // Check whether we should execute.\n        const shouldExecute = await this._shouldExecute(timeout);\n        if (this.isDisposed) {\n            return;\n        }\n        if (shouldExecute) {\n            // Create a new prompt cell before kernel execution to allow typeahead.\n            this.newPromptCell();\n            this.promptCell.editor.focus();\n            await this._execute(promptCell);\n        }\n        else {\n            // add a newline if we shouldn't execute\n            promptCell.editor.newIndentedLine();\n        }\n    }\n    /**\n     * Get a cell given a message id.\n     *\n     * @param msgId - The message id.\n     */\n    getCell(msgId) {\n        return this._msgIds.get(msgId);\n    }\n    /**\n     * Inject arbitrary code for the console to execute immediately.\n     *\n     * @param code - The code contents of the cell being injected.\n     *\n     * @returns A promise that indicates when the injected cell's execution ends.\n     */\n    inject(code, metadata = {}) {\n        const cell = this.createCodeCell();\n        cell.model.value.text = code;\n        for (const key of Object.keys(metadata)) {\n            cell.model.metadata.set(key, metadata[key]);\n        }\n        this.addCell(cell);\n        return this._execute(cell);\n    }\n    /**\n     * Insert a line break in the prompt cell.\n     */\n    insertLinebreak() {\n        const promptCell = this.promptCell;\n        if (!promptCell) {\n            return;\n        }\n        promptCell.editor.newIndentedLine();\n    }\n    /**\n     * Replaces the selected text in the prompt cell.\n     *\n     * @param text - The text to replace the selection.\n     */\n    replaceSelection(text) {\n        var _a, _b;\n        const promptCell = this.promptCell;\n        if (!promptCell) {\n            return;\n        }\n        (_b = (_a = promptCell.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, text);\n    }\n    /**\n     * Serialize the output.\n     *\n     * #### Notes\n     * This only serializes the code cells and the prompt cell if it exists, and\n     * skips any old banner cells.\n     */\n    serialize() {\n        const cells = [];\n        each(this._cells, cell => {\n            const model = cell.model;\n            if (isCodeCellModel(model)) {\n                cells.push(model.toJSON());\n            }\n        });\n        if (this.promptCell) {\n            cells.push(this.promptCell.model.toJSON());\n        }\n        return cells;\n    }\n    /**\n     * Handle `mousedown` events for the widget.\n     */\n    _evtMouseDown(event) {\n        const { button, shiftKey } = event;\n        // We only handle main or secondary button actions.\n        if (!(button === 0 || button === 2) ||\n            // Shift right-click gives the browser default behavior.\n            (shiftKey && button === 2)) {\n            return;\n        }\n        let target = event.target;\n        const cellFilter = (node) => node.classList.contains(CONSOLE_CELL_CLASS);\n        let cellIndex = CellDragUtils.findCell(target, this._cells, cellFilter);\n        if (cellIndex === -1) {\n            // `event.target` sometimes gives an orphaned node in\n            // Firefox 57, which can have `null` anywhere in its parent line. If we fail\n            // to find a cell using `event.target`, try again using a target\n            // reconstructed from the position of the click event.\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            cellIndex = CellDragUtils.findCell(target, this._cells, cellFilter);\n        }\n        if (cellIndex === -1) {\n            return;\n        }\n        const cell = this._cells.get(cellIndex);\n        const targetArea = CellDragUtils.detectTargetArea(cell, event.target);\n        if (targetArea === 'prompt') {\n            this._dragData = {\n                pressX: event.clientX,\n                pressY: event.clientY,\n                index: cellIndex\n            };\n            this._focusedCell = cell;\n            document.addEventListener('mouseup', this, true);\n            document.addEventListener('mousemove', this, true);\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousemove` event of widget\n     */\n    _evtMouseMove(event) {\n        const data = this._dragData;\n        if (data &&\n            CellDragUtils.shouldStartDrag(data.pressX, data.pressY, event.clientX, event.clientY)) {\n            void this._startDrag(data.index, event.clientX, event.clientY);\n        }\n    }\n    /**\n     * Start a drag event\n     */\n    _startDrag(index, clientX, clientY) {\n        const cellModel = this._focusedCell.model;\n        const selected = [cellModel.toJSON()];\n        const dragImage = CellDragUtils.createCellDragImage(this._focusedCell, selected);\n        this._drag = new Drag({\n            mimeData: new MimeData(),\n            dragImage,\n            proposedAction: 'copy',\n            supportedActions: 'copy',\n            source: this\n        });\n        this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);\n        const textContent = cellModel.value.text;\n        this._drag.mimeData.setData('text/plain', textContent);\n        this._focusedCell = null;\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        return this._drag.start(clientX, clientY).then(() => {\n            if (this.isDisposed) {\n                return;\n            }\n            this._drag = null;\n            this._dragData = null;\n        });\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event -The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notebook panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `after_attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        const node = this.node;\n        node.addEventListener('keydown', this, true);\n        node.addEventListener('click', this);\n        node.addEventListener('mousedown', this);\n        // Create a prompt if necessary.\n        if (!this.promptCell) {\n            this.newPromptCell();\n        }\n        else {\n            this.promptCell.editor.focus();\n            this.update();\n        }\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('keydown', this, true);\n        node.removeEventListener('click', this);\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        const editor = this.promptCell && this.promptCell.editor;\n        if (editor) {\n            editor.focus();\n        }\n        this.update();\n    }\n    /**\n     * Make a new prompt cell.\n     */\n    newPromptCell() {\n        let promptCell = this.promptCell;\n        const input = this._input;\n        // Make the last prompt read-only, clear its signals, and move to content.\n        if (promptCell) {\n            promptCell.readOnly = true;\n            promptCell.removeClass(PROMPT_CLASS);\n            Signal.clearData(promptCell.editor);\n            const child = input.widgets[0];\n            child.parent = null;\n            this.addCell(promptCell);\n        }\n        // Create the new prompt cell.\n        const factory = this.contentFactory;\n        const options = this._createCodeCellOptions();\n        promptCell = factory.createCodeCell(options);\n        promptCell.model.mimeType = this._mimetype;\n        promptCell.addClass(PROMPT_CLASS);\n        // Add the prompt cell to the DOM, making `this.promptCell` valid again.\n        this._input.addWidget(promptCell);\n        // Suppress the default \"Enter\" key handling.\n        const editor = promptCell.editor;\n        editor.addKeydownHandler(this._onEditorKeydown);\n        this._history.editor = editor;\n        this._promptCellCreated.emit(promptCell);\n    }\n    /**\n     * Handle `update-request` messages.\n     */\n    onUpdateRequest(msg) {\n        Private.scrollToBottom(this._content.node);\n    }\n    /**\n     * Handle the `'keydown'` event for the widget.\n     */\n    _evtKeyDown(event) {\n        const editor = this.promptCell && this.promptCell.editor;\n        if (!editor) {\n            return;\n        }\n        if (event.keyCode === 13 && !editor.hasFocus()) {\n            event.preventDefault();\n            editor.focus();\n        }\n        else if (event.keyCode === 27 && editor.hasFocus()) {\n            // Set to command mode\n            event.preventDefault();\n            event.stopPropagation();\n            this.node.focus();\n        }\n    }\n    /**\n     * Handle the `'mouseup'` event for the widget.\n     */\n    _evtMouseUp(event) {\n        if (this.promptCell &&\n            this.promptCell.node.contains(event.target)) {\n            this.promptCell.editor.focus();\n        }\n    }\n    /**\n     * Execute the code in the current prompt cell.\n     */\n    _execute(cell) {\n        const source = cell.model.value.text;\n        this._history.push(source);\n        // If the source of the console is just \"clear\", clear the console as we\n        // do in IPython or QtConsole.\n        if (source === 'clear' || source === '%clear') {\n            this.clear();\n            return Promise.resolve(void 0);\n        }\n        cell.model.contentChanged.connect(this.update, this);\n        const onSuccess = (value) => {\n            if (this.isDisposed) {\n                return;\n            }\n            if (value && value.content.status === 'ok') {\n                const content = value.content;\n                // Use deprecated payloads for backwards compatibility.\n                if (content.payload && content.payload.length) {\n                    const setNextInput = content.payload.filter(i => {\n                        return i.source === 'set_next_input';\n                    })[0];\n                    if (setNextInput) {\n                        const text = setNextInput.text;\n                        // Ignore the `replace` value and always set the next cell.\n                        cell.model.value.text = text;\n                    }\n                }\n            }\n            else if (value && value.content.status === 'error') {\n                each(this._cells, (cell) => {\n                    if (cell.model.executionCount === null) {\n                        cell.setPrompt('');\n                    }\n                });\n            }\n            cell.model.contentChanged.disconnect(this.update, this);\n            this.update();\n            this._executed.emit(new Date());\n        };\n        const onFailure = () => {\n            if (this.isDisposed) {\n                return;\n            }\n            cell.model.contentChanged.disconnect(this.update, this);\n            this.update();\n        };\n        return CodeCell.execute(cell, this.sessionContext).then(onSuccess, onFailure);\n    }\n    /**\n     * Update the console based on the kernel info.\n     */\n    _handleInfo(info) {\n        if (info.status !== 'ok') {\n            this._banner.model.value.text = 'Error in getting kernel banner';\n            return;\n        }\n        this._banner.model.value.text = info.banner;\n        const lang = info.language_info;\n        this._mimetype = this._mimeTypeService.getMimeTypeByLanguage(lang);\n        if (this.promptCell) {\n            this.promptCell.model.mimeType = this._mimetype;\n        }\n    }\n    /**\n     * Create the options used to initialize a code cell widget.\n     */\n    _createCodeCellOptions() {\n        const contentFactory = this.contentFactory;\n        const modelFactory = this.modelFactory;\n        const model = modelFactory.createCodeCell({});\n        const rendermime = this.rendermime;\n        return { model, rendermime, contentFactory, placeholder: false };\n    }\n    /**\n     * Handle cell disposed signals.\n     */\n    _onCellDisposed(sender, args) {\n        if (!this.isDisposed) {\n            this._cells.removeValue(sender);\n            const msgId = this._msgIdCells.get(sender);\n            if (msgId) {\n                this._msgIdCells.delete(sender);\n                this._msgIds.delete(msgId);\n            }\n        }\n    }\n    /**\n     * Test whether we should execute the prompt cell.\n     */\n    _shouldExecute(timeout) {\n        const promptCell = this.promptCell;\n        if (!promptCell) {\n            return Promise.resolve(false);\n        }\n        const model = promptCell.model;\n        const code = model.value.text;\n        return new Promise((resolve, reject) => {\n            var _a;\n            const timer = setTimeout(() => {\n                resolve(true);\n            }, timeout);\n            const kernel = (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n            if (!kernel) {\n                resolve(false);\n                return;\n            }\n            kernel\n                .requestIsComplete({ code })\n                .then(isComplete => {\n                clearTimeout(timer);\n                if (this.isDisposed) {\n                    resolve(false);\n                }\n                if (isComplete.content.status !== 'incomplete') {\n                    resolve(true);\n                    return;\n                }\n                resolve(false);\n            })\n                .catch(() => {\n                resolve(true);\n            });\n        });\n    }\n    /**\n     * Handle a keydown event on an editor.\n     */\n    _onEditorKeydown(editor, event) {\n        // Suppress \"Enter\" events.\n        return event.keyCode === 13;\n    }\n    /**\n     * Handle a change to the kernel.\n     */\n    async _onKernelChanged() {\n        var _a;\n        this.clear();\n        if (this._banner) {\n            this._banner.dispose();\n            this._banner = null;\n        }\n        this.addBanner();\n        if ((_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) {\n            this._handleInfo(await this.sessionContext.session.kernel.info);\n        }\n    }\n    /**\n     * Handle a change to the kernel status.\n     */\n    async _onKernelStatusChanged() {\n        var _a;\n        const kernel = (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if ((kernel === null || kernel === void 0 ? void 0 : kernel.status) === 'restarting') {\n            this.addBanner();\n            this._handleInfo(await (kernel === null || kernel === void 0 ? void 0 : kernel.info));\n        }\n    }\n}\n/**\n * A namespace for CodeConsole statics.\n */\n(function (CodeConsole) {\n    /**\n     * Default implementation of `IContentFactory`.\n     */\n    class ContentFactory extends Cell.ContentFactory {\n        /**\n         * Create a new code cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createCodeCell(options) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new CodeCell(options).initializeState();\n        }\n        /**\n         * Create a new raw cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createRawCell(options) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new RawCell(options).initializeState();\n        }\n    }\n    CodeConsole.ContentFactory = ContentFactory;\n    /**\n     * A default content factory for the code console.\n     */\n    CodeConsole.defaultContentFactory = new ContentFactory();\n    /**\n     * The default implementation of an `IModelFactory`.\n     */\n    class ModelFactory {\n        /**\n         * Create a new cell model factory.\n         */\n        constructor(options = {}) {\n            this.codeCellContentFactory =\n                options.codeCellContentFactory || CodeCellModel.defaultContentFactory;\n        }\n        /**\n         * Create a new code cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new code cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         *   If the contentFactory is not provided, the instance\n         *   `codeCellContentFactory` will be used.\n         */\n        createCodeCell(options) {\n            if (!options.contentFactory) {\n                options.contentFactory = this.codeCellContentFactory;\n            }\n            return new CodeCellModel(options);\n        }\n        /**\n         * Create a new raw cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new raw cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createRawCell(options) {\n            return new RawCellModel(options);\n        }\n    }\n    CodeConsole.ModelFactory = ModelFactory;\n    /**\n     * The default `ModelFactory` instance.\n     */\n    CodeConsole.defaultModelFactory = new ModelFactory({});\n})(CodeConsole || (CodeConsole = {}));\n/**\n * A namespace for console widget private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Jump to the bottom of a node.\n     *\n     * @param node - The scrollable element.\n     */\n    function scrollToBottom(node) {\n        node.scrollTop = node.scrollHeight - node.clientHeight;\n    }\n    Private.scrollToBottom = scrollToBottom;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map"],"sourceRoot":""}