{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@lumino/virtualdom/dist/index.es6.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAA6C;;AAE7C;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,cAAc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6CAA6C;AACzF;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qDAAqD;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAmD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA,qDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uBAAuB;AACpE;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAEsD;AACjF","file":"vendors-node_modules_lumino_virtualdom_dist_index_es6_js.3d19724dd1706dbb2068.js","sourcesContent":["import { ArrayExt } from '@lumino/algorithm';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * A virtual node which represents plain text content.\n *\n * #### Notes\n * User code will not typically create a `VirtualText` node directly.\n * Instead, the `h()` function will be used to create an element tree.\n */\nvar VirtualText = /** @class */ (function () {\n    /**\n     * Construct a new virtual text node.\n     *\n     * @param content - The text content for the node.\n     */\n    function VirtualText(content) {\n        /**\n         * The type of the node.\n         *\n         * This value can be used as a type guard for discriminating the\n         * `VirtualNode` union type.\n         */\n        this.type = 'text';\n        this.content = content;\n    }\n    return VirtualText;\n}());\n/**\n * A virtual node which represents an HTML element.\n *\n * #### Notes\n * User code will not typically create a `VirtualElement` node directly.\n * Instead, the `h()` function will be used to create an element tree.\n */\nvar VirtualElement = /** @class */ (function () {\n    /**\n     * Construct a new virtual element node.\n     *\n     * @param tag - The element tag name.\n     *\n     * @param attrs - The element attributes.\n     *\n     * @param children - The element children.\n     *\n     * @param renderer - An optional custom renderer for the element.\n     */\n    function VirtualElement(tag, attrs, children, renderer) {\n        /**\n         * The type of the node.\n         *\n         * This value can be used as a type guard for discriminating the\n         * `VirtualNode` union type.\n         */\n        this.type = 'element';\n        this.tag = tag;\n        this.attrs = attrs;\n        this.children = children;\n        this.renderer = renderer;\n    }\n    return VirtualElement;\n}());\n/**\n * DEPRECATED - use VirtualElement with a defined renderer param instead.\n * This class is provided as a backwards compatibility shim\n *\n * A \"pass thru\" virtual node whose children are managed by a render and an\n * unrender callback. The intent of this flavor of virtual node is to make\n * it easy to blend other kinds of virtualdom (eg React) into Phosphor's\n * virtualdom.\n *\n * #### Notes\n * User code will not typically create a `VirtualElementPass` node directly.\n * Instead, the `hpass()` function will be used to create an element tree.\n */\nvar VirtualElementPass = /** @class */ (function (_super) {\n    __extends(VirtualElementPass, _super);\n    /**\n     * DEPRECATED - use VirtualElement with a defined renderer param instead\n     *\n     * Construct a new virtual element pass thru node.\n     *\n     * @param tag - the tag of the parent element of this node. Once the parent\n     * element is rendered, it will be passed as an argument to\n     * renderer.render\n     *\n     * @param attrs - attributes that will assigned to the\n     * parent element\n     *\n     * @param renderer - an object with render and unrender\n     * functions, each of which should take a single argument of type\n     * HTMLElement and return nothing. If null, the parent element\n     * will be rendered barren without any children.\n     */\n    function VirtualElementPass(tag, attrs, renderer) {\n        return _super.call(this, tag, attrs, [], renderer || undefined) || this;\n    }\n    return VirtualElementPass;\n}(VirtualElement));\nfunction h(tag) {\n    var attrs = {};\n    var renderer;\n    var children = [];\n    for (var i = 1, n = arguments.length; i < n; ++i) {\n        var arg = arguments[i];\n        if (typeof arg === 'string') {\n            children.push(new VirtualText(arg));\n        }\n        else if (arg instanceof VirtualText) {\n            children.push(arg);\n        }\n        else if (arg instanceof VirtualElement) {\n            children.push(arg);\n        }\n        else if (arg instanceof Array) {\n            extend(children, arg);\n        }\n        else if ((i === 1 || i === 2) && arg && typeof arg === 'object') {\n            if (\"render\" in arg) {\n                renderer = arg;\n            }\n            else {\n                attrs = arg;\n            }\n        }\n    }\n    return new VirtualElement(tag, attrs, children, renderer);\n    function extend(array, values) {\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var child = values_1[_i];\n            if (typeof child === 'string') {\n                array.push(new VirtualText(child));\n            }\n            else if (child instanceof VirtualText) {\n                array.push(child);\n            }\n            else if (child instanceof VirtualElement) {\n                array.push(child);\n            }\n        }\n    }\n}\n/**\n * The namespace for the `h` function statics.\n */\n(function (h) {\n    h.a = h.bind(undefined, 'a');\n    h.abbr = h.bind(undefined, 'abbr');\n    h.address = h.bind(undefined, 'address');\n    h.area = h.bind(undefined, 'area');\n    h.article = h.bind(undefined, 'article');\n    h.aside = h.bind(undefined, 'aside');\n    h.audio = h.bind(undefined, 'audio');\n    h.b = h.bind(undefined, 'b');\n    h.bdi = h.bind(undefined, 'bdi');\n    h.bdo = h.bind(undefined, 'bdo');\n    h.blockquote = h.bind(undefined, 'blockquote');\n    h.br = h.bind(undefined, 'br');\n    h.button = h.bind(undefined, 'button');\n    h.canvas = h.bind(undefined, 'canvas');\n    h.caption = h.bind(undefined, 'caption');\n    h.cite = h.bind(undefined, 'cite');\n    h.code = h.bind(undefined, 'code');\n    h.col = h.bind(undefined, 'col');\n    h.colgroup = h.bind(undefined, 'colgroup');\n    h.data = h.bind(undefined, 'data');\n    h.datalist = h.bind(undefined, 'datalist');\n    h.dd = h.bind(undefined, 'dd');\n    h.del = h.bind(undefined, 'del');\n    h.dfn = h.bind(undefined, 'dfn');\n    h.div = h.bind(undefined, 'div');\n    h.dl = h.bind(undefined, 'dl');\n    h.dt = h.bind(undefined, 'dt');\n    h.em = h.bind(undefined, 'em');\n    h.embed = h.bind(undefined, 'embed');\n    h.fieldset = h.bind(undefined, 'fieldset');\n    h.figcaption = h.bind(undefined, 'figcaption');\n    h.figure = h.bind(undefined, 'figure');\n    h.footer = h.bind(undefined, 'footer');\n    h.form = h.bind(undefined, 'form');\n    h.h1 = h.bind(undefined, 'h1');\n    h.h2 = h.bind(undefined, 'h2');\n    h.h3 = h.bind(undefined, 'h3');\n    h.h4 = h.bind(undefined, 'h4');\n    h.h5 = h.bind(undefined, 'h5');\n    h.h6 = h.bind(undefined, 'h6');\n    h.header = h.bind(undefined, 'header');\n    h.hr = h.bind(undefined, 'hr');\n    h.i = h.bind(undefined, 'i');\n    h.iframe = h.bind(undefined, 'iframe');\n    h.img = h.bind(undefined, 'img');\n    h.input = h.bind(undefined, 'input');\n    h.ins = h.bind(undefined, 'ins');\n    h.kbd = h.bind(undefined, 'kbd');\n    h.label = h.bind(undefined, 'label');\n    h.legend = h.bind(undefined, 'legend');\n    h.li = h.bind(undefined, 'li');\n    h.main = h.bind(undefined, 'main');\n    h.map = h.bind(undefined, 'map');\n    h.mark = h.bind(undefined, 'mark');\n    h.meter = h.bind(undefined, 'meter');\n    h.nav = h.bind(undefined, 'nav');\n    h.noscript = h.bind(undefined, 'noscript');\n    h.object = h.bind(undefined, 'object');\n    h.ol = h.bind(undefined, 'ol');\n    h.optgroup = h.bind(undefined, 'optgroup');\n    h.option = h.bind(undefined, 'option');\n    h.output = h.bind(undefined, 'output');\n    h.p = h.bind(undefined, 'p');\n    h.param = h.bind(undefined, 'param');\n    h.pre = h.bind(undefined, 'pre');\n    h.progress = h.bind(undefined, 'progress');\n    h.q = h.bind(undefined, 'q');\n    h.rp = h.bind(undefined, 'rp');\n    h.rt = h.bind(undefined, 'rt');\n    h.ruby = h.bind(undefined, 'ruby');\n    h.s = h.bind(undefined, 's');\n    h.samp = h.bind(undefined, 'samp');\n    h.section = h.bind(undefined, 'section');\n    h.select = h.bind(undefined, 'select');\n    h.small = h.bind(undefined, 'small');\n    h.source = h.bind(undefined, 'source');\n    h.span = h.bind(undefined, 'span');\n    h.strong = h.bind(undefined, 'strong');\n    h.sub = h.bind(undefined, 'sub');\n    h.summary = h.bind(undefined, 'summary');\n    h.sup = h.bind(undefined, 'sup');\n    h.table = h.bind(undefined, 'table');\n    h.tbody = h.bind(undefined, 'tbody');\n    h.td = h.bind(undefined, 'td');\n    h.textarea = h.bind(undefined, 'textarea');\n    h.tfoot = h.bind(undefined, 'tfoot');\n    h.th = h.bind(undefined, 'th');\n    h.thead = h.bind(undefined, 'thead');\n    h.time = h.bind(undefined, 'time');\n    h.title = h.bind(undefined, 'title');\n    h.tr = h.bind(undefined, 'tr');\n    h.track = h.bind(undefined, 'track');\n    h.u = h.bind(undefined, 'u');\n    h.ul = h.bind(undefined, 'ul');\n    h.var_ = h.bind(undefined, 'var');\n    h.video = h.bind(undefined, 'video');\n    h.wbr = h.bind(undefined, 'wbr');\n})(h || (h = {}));\nfunction hpass(tag) {\n    var attrs = {};\n    var renderer = null;\n    if (arguments.length === 2) {\n        var arg = arguments[1];\n        if (\"render\" in arg) {\n            renderer = arg;\n        }\n        else {\n            attrs = arg;\n        }\n    }\n    else if (arguments.length === 3) {\n        attrs = arguments[1];\n        renderer = arguments[2];\n    }\n    else if (arguments.length > 3) {\n        throw new Error(\"hpass() should be called with 1, 2, or 3 arguments\");\n    }\n    return new VirtualElementPass(tag, attrs, renderer);\n}\n/**\n * The namespace for the virtual DOM rendering functions.\n */\nvar VirtualDOM;\n(function (VirtualDOM) {\n    function realize(node) {\n        return Private.createDOMNode(node);\n    }\n    VirtualDOM.realize = realize;\n    /**\n     * Render virtual DOM content into a host element.\n     *\n     * @param content - The virtual DOM content to render.\n     *\n     * @param host - The host element for the rendered content.\n     *\n     * #### Notes\n     * This renders the delta from the previous rendering. It assumes that\n     * the content of the host element is not manipulated by external code.\n     *\n     * Providing `null` content will clear the rendering.\n     *\n     * Externally modifying the provided content or the host element will\n     * result in undefined rendering behavior.\n     */\n    function render(content, host) {\n        var oldContent = Private.hostMap.get(host) || [];\n        var newContent = Private.asContentArray(content);\n        Private.hostMap.set(host, newContent);\n        Private.updateContent(host, oldContent, newContent);\n    }\n    VirtualDOM.render = render;\n})(VirtualDOM || (VirtualDOM = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A weak mapping of host element to virtual DOM content.\n     */\n    Private.hostMap = new WeakMap();\n    /**\n     * Cast a content value to a content array.\n     */\n    function asContentArray(value) {\n        if (!value) {\n            return [];\n        }\n        if (value instanceof Array) {\n            return value;\n        }\n        return [value];\n    }\n    Private.asContentArray = asContentArray;\n    function createDOMNode(node) {\n        var host = arguments[1] || null;\n        var before = arguments[2] || null;\n        if (host) {\n            host.insertBefore(createDOMNode(node), before);\n        }\n        else {\n            // Create a text node for a virtual text node.\n            if (node.type === 'text') {\n                return document.createTextNode(node.content);\n            }\n            // Create the HTML element with the specified tag.\n            host = document.createElement(node.tag);\n            // Add the attributes for the new element.\n            addAttrs(host, node.attrs);\n            if (node.renderer) {\n                node.renderer.render(host, { attrs: node.attrs, children: node.children });\n                return host;\n            }\n            // Recursively populate the element with child content.\n            for (var i = 0, n = node.children.length; i < n; ++i) {\n                createDOMNode(node.children[i], host);\n            }\n        }\n        return host;\n    }\n    Private.createDOMNode = createDOMNode;\n    /**\n     * Update a host element with the delta of the virtual content.\n     *\n     * This is the core \"diff\" algorithm. There is no explicit \"patch\"\n     * phase. The host is patched at each step as the diff progresses.\n     */\n    function updateContent(host, oldContent, newContent) {\n        // Bail early if the content is identical.\n        if (oldContent === newContent) {\n            return;\n        }\n        // Collect the old keyed elems into a mapping.\n        var oldKeyed = collectKeys(host, oldContent);\n        // Create a copy of the old content which can be modified in-place.\n        var oldCopy = oldContent.slice();\n        // Update the host with the new content. The diff always proceeds\n        // forward and never modifies a previously visited index. The old\n        // copy array is modified in-place to reflect the changes made to\n        // the host children. This causes the stale nodes to be pushed to\n        // the end of the host node and removed at the end of the loop.\n        var currElem = host.firstChild;\n        var newCount = newContent.length;\n        for (var i = 0; i < newCount; ++i) {\n            // If the old content is exhausted, create a new node.\n            if (i >= oldCopy.length) {\n                createDOMNode(newContent[i], host);\n                continue;\n            }\n            // Lookup the old and new virtual nodes.\n            var oldVNode = oldCopy[i];\n            var newVNode = newContent[i];\n            // If both elements are identical, there is nothing to do.\n            if (oldVNode === newVNode) {\n                currElem = currElem.nextSibling;\n                continue;\n            }\n            // Handle the simplest case of in-place text update first.\n            if (oldVNode.type === 'text' && newVNode.type === 'text') {\n                currElem.textContent = newVNode.content;\n                currElem = currElem.nextSibling;\n                continue;\n            }\n            // If the old or new node is a text node, the other node is now\n            // known to be an element node, so create and insert a new node.\n            if (oldVNode.type === 'text' || newVNode.type === 'text') {\n                ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // If the old XOR new node has a custom renderer,\n            // create and insert a new node.\n            if (!(oldVNode.renderer) != !(newVNode.renderer)) {\n                ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // At this point, both nodes are known to be element nodes.\n            // If the new elem is keyed, move an old keyed elem to the proper\n            // location before proceeding with the diff. The search can start\n            // at the current index, since the unmatched old keyed elems are\n            // pushed forward in the old copy array.\n            var newKey = newVNode.attrs.key;\n            if (newKey && newKey in oldKeyed) {\n                var pair = oldKeyed[newKey];\n                if (pair.vNode !== oldVNode) {\n                    ArrayExt.move(oldCopy, oldCopy.indexOf(pair.vNode, i + 1), i);\n                    host.insertBefore(pair.element, currElem);\n                    oldVNode = pair.vNode;\n                    currElem = pair.element;\n                }\n            }\n            // If both elements are identical, there is nothing to do.\n            if (oldVNode === newVNode) {\n                currElem = currElem.nextSibling;\n                continue;\n            }\n            // If the old elem is keyed and does not match the new elem key,\n            // create a new node. This is necessary since the old keyed elem\n            // may be matched at a later point in the diff.\n            var oldKey = oldVNode.attrs.key;\n            if (oldKey && oldKey !== newKey) {\n                ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // If the tags are different, create a new node.\n            if (oldVNode.tag !== newVNode.tag) {\n                ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // At this point, the element can be updated in-place.\n            // Update the element attributes.\n            updateAttrs(currElem, oldVNode.attrs, newVNode.attrs);\n            // Update the element content.\n            if (newVNode.renderer) {\n                newVNode.renderer.render(currElem, { attrs: newVNode.attrs, children: newVNode.children });\n            }\n            else {\n                updateContent(currElem, oldVNode.children, newVNode.children);\n            }\n            // Step to the next sibling element.\n            currElem = currElem.nextSibling;\n        }\n        // Cleanup stale DOM\n        removeContent(host, oldCopy, newCount, true);\n    }\n    Private.updateContent = updateContent;\n    /**\n     * Handle cleanup of stale vdom and its associated DOM. The host node is\n     * traversed recursively (in depth-first order), and any explicit cleanup\n     * required by a child node is carried out when it is visited (eg if a node\n     * has a custom renderer, the renderer.unrender function will be called).\n     * Once the subtree beneath each child of host has been completely visited,\n     * that child will be removed via a call to host.removeChild.\n     */\n    function removeContent(host, oldContent, newCount, _sentinel) {\n        // Dispose of the old nodes pushed to the end of the host.\n        for (var i = oldContent.length - 1; i >= newCount; --i) {\n            var oldNode = oldContent[i];\n            var child = (_sentinel ? host.lastChild : host.childNodes[i]);\n            // recursively clean up host children\n            if (oldNode.type === 'text') ;\n            else if (oldNode.renderer && oldNode.renderer.unrender) {\n                oldNode.renderer.unrender(child, { attrs: oldNode.attrs, children: oldNode.children });\n            }\n            else {\n                removeContent(child, oldNode.children, 0, false);\n            }\n            if (_sentinel) {\n                host.removeChild(child);\n            }\n        }\n    }\n    /**\n     * A set of special-cased attribute names.\n     */\n    var specialAttrs = {\n        'key': true,\n        'className': true,\n        'htmlFor': true,\n        'dataset': true,\n        'style': true,\n    };\n    /**\n     * Add element attributes to a newly created HTML element.\n     */\n    function addAttrs(element, attrs) {\n        // Add the inline event listeners and node attributes.\n        for (var name_1 in attrs) {\n            if (name_1 in specialAttrs) {\n                continue;\n            }\n            if (name_1.substr(0, 2) === 'on') {\n                element[name_1] = attrs[name_1];\n            }\n            else {\n                element.setAttribute(name_1, attrs[name_1]);\n            }\n        }\n        // Add the element `class` attribute.\n        if (attrs.className !== undefined) {\n            element.setAttribute('class', attrs.className);\n        }\n        // Add the element `for` attribute.\n        if (attrs.htmlFor !== undefined) {\n            element.setAttribute('for', attrs.htmlFor);\n        }\n        // Add the dataset values.\n        if (attrs.dataset) {\n            addDataset(element, attrs.dataset);\n        }\n        // Add the inline styles.\n        if (attrs.style) {\n            addStyle(element, attrs.style);\n        }\n    }\n    /**\n     * Update the element attributes of an HTML element.\n     */\n    function updateAttrs(element, oldAttrs, newAttrs) {\n        // Do nothing if the attrs are the same object.\n        if (oldAttrs === newAttrs) {\n            return;\n        }\n        // Setup the strongly typed loop variable.\n        var name;\n        // Remove attributes and listeners which no longer exist.\n        for (name in oldAttrs) {\n            if (name in specialAttrs || name in newAttrs) {\n                continue;\n            }\n            if (name.substr(0, 2) === 'on') {\n                element[name] = null;\n            }\n            else {\n                element.removeAttribute(name);\n            }\n        }\n        // Add and update new and existing attributes and listeners.\n        for (name in newAttrs) {\n            if (name in specialAttrs || oldAttrs[name] === newAttrs[name]) {\n                continue;\n            }\n            if (name.substr(0, 2) === 'on') {\n                element[name] = newAttrs[name];\n            }\n            else {\n                element.setAttribute(name, newAttrs[name]);\n            }\n        }\n        // Update the element `class` attribute.\n        if (oldAttrs.className !== newAttrs.className) {\n            if (newAttrs.className !== undefined) {\n                element.setAttribute('class', newAttrs.className);\n            }\n            else {\n                element.removeAttribute('class');\n            }\n        }\n        // Add the element `for` attribute.\n        if (oldAttrs.htmlFor !== newAttrs.htmlFor) {\n            if (newAttrs.htmlFor !== undefined) {\n                element.setAttribute('for', newAttrs.htmlFor);\n            }\n            else {\n                element.removeAttribute('for');\n            }\n        }\n        // Update the dataset values.\n        if (oldAttrs.dataset !== newAttrs.dataset) {\n            updateDataset(element, oldAttrs.dataset || {}, newAttrs.dataset || {});\n        }\n        // Update the inline styles.\n        if (oldAttrs.style !== newAttrs.style) {\n            updateStyle(element, oldAttrs.style || {}, newAttrs.style || {});\n        }\n    }\n    /**\n     * Add dataset values to a newly created HTML element.\n     */\n    function addDataset(element, dataset) {\n        for (var name_2 in dataset) {\n            element.setAttribute(\"data-\" + name_2, dataset[name_2]);\n        }\n    }\n    /**\n     * Update the dataset values of an HTML element.\n     */\n    function updateDataset(element, oldDataset, newDataset) {\n        for (var name_3 in oldDataset) {\n            if (!(name_3 in newDataset)) {\n                element.removeAttribute(\"data-\" + name_3);\n            }\n        }\n        for (var name_4 in newDataset) {\n            if (oldDataset[name_4] !== newDataset[name_4]) {\n                element.setAttribute(\"data-\" + name_4, newDataset[name_4]);\n            }\n        }\n    }\n    /**\n     * Add inline style values to a newly created HTML element.\n     */\n    function addStyle(element, style) {\n        var elemStyle = element.style;\n        var name;\n        for (name in style) {\n            elemStyle[name] = style[name];\n        }\n    }\n    /**\n     * Update the inline style values of an HTML element.\n     */\n    function updateStyle(element, oldStyle, newStyle) {\n        var elemStyle = element.style;\n        var name;\n        for (name in oldStyle) {\n            if (!(name in newStyle)) {\n                elemStyle[name] = '';\n            }\n        }\n        for (name in newStyle) {\n            if (oldStyle[name] !== newStyle[name]) {\n                elemStyle[name] = newStyle[name];\n            }\n        }\n    }\n    /**\n     * Collect a mapping of keyed elements for the host content.\n     */\n    function collectKeys(host, content) {\n        var node = host.firstChild;\n        var keyMap = Object.create(null);\n        for (var _i = 0, content_1 = content; _i < content_1.length; _i++) {\n            var vNode = content_1[_i];\n            if (vNode.type === 'element' && vNode.attrs.key) {\n                keyMap[vNode.attrs.key] = { vNode: vNode, element: node };\n            }\n            node = node.nextSibling;\n        }\n        return keyMap;\n    }\n})(Private || (Private = {}));\n\nexport { VirtualDOM, VirtualElement, VirtualElementPass, VirtualText, h, hpass };\n//# sourceMappingURL=index.es6.js.map\n"],"sourceRoot":""}