(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_notebook-extension_lib_index_js"],{

/***/ 57528:
/*!**********************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook-extension/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "commandEditItem": () => (/* binding */ commandEditItem),
/* harmony export */   "exportPlugin": () => (/* binding */ exportPlugin),
/* harmony export */   "notebookTrustItem": () => (/* binding */ notebookTrustItem),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ 67599);
/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ 18477);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/cells */ 96462);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/codeeditor */ 6256);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/coreutils */ 78548);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/docmanager */ 60626);
/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/filebrowser */ 59310);
/* harmony import */ var _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/launcher */ 18571);
/* harmony import */ var _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jupyterlab/mainmenu */ 86942);
/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @jupyterlab/notebook */ 86944);
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @jupyterlab/property-inspector */ 41434);
/* harmony import */ var _jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @jupyterlab/rendermime */ 34410);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @jupyterlab/settingregistry */ 2832);
/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @jupyterlab/statedb */ 44011);
/* harmony import */ var _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @jupyterlab/statusbar */ 76150);
/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @jupyterlab/translation */ 57630);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @jupyterlab/ui-components */ 65995);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lumino/algorithm */ 79028);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @lumino/coreutils */ 66065);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @lumino/disposable */ 98669);
/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @lumino/messaging */ 91884);
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_lumino_messaging__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @lumino/widgets */ 77031);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _nboutput__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./nboutput */ 90805);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module notebook-extension
 */























/**
 * The command IDs used by the notebook plugin.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.createNew = 'notebook:create-new';
    CommandIDs.interrupt = 'notebook:interrupt-kernel';
    CommandIDs.restart = 'notebook:restart-kernel';
    CommandIDs.restartClear = 'notebook:restart-clear-output';
    CommandIDs.restartAndRunToSelected = 'notebook:restart-and-run-to-selected';
    CommandIDs.restartRunAll = 'notebook:restart-run-all';
    CommandIDs.reconnectToKernel = 'notebook:reconnect-to-kernel';
    CommandIDs.changeKernel = 'notebook:change-kernel';
    CommandIDs.createConsole = 'notebook:create-console';
    CommandIDs.createOutputView = 'notebook:create-output-view';
    CommandIDs.clearAllOutputs = 'notebook:clear-all-cell-outputs';
    CommandIDs.closeAndShutdown = 'notebook:close-and-shutdown';
    CommandIDs.trust = 'notebook:trust';
    CommandIDs.exportToFormat = 'notebook:export-to-format';
    CommandIDs.run = 'notebook:run-cell';
    CommandIDs.runAndAdvance = 'notebook:run-cell-and-select-next';
    CommandIDs.runAndInsert = 'notebook:run-cell-and-insert-below';
    CommandIDs.runInConsole = 'notebook:run-in-console';
    CommandIDs.runAll = 'notebook:run-all-cells';
    CommandIDs.runAllAbove = 'notebook:run-all-above';
    CommandIDs.runAllBelow = 'notebook:run-all-below';
    CommandIDs.renderAllMarkdown = 'notebook:render-all-markdown';
    CommandIDs.toCode = 'notebook:change-cell-to-code';
    CommandIDs.toMarkdown = 'notebook:change-cell-to-markdown';
    CommandIDs.toRaw = 'notebook:change-cell-to-raw';
    CommandIDs.cut = 'notebook:cut-cell';
    CommandIDs.copy = 'notebook:copy-cell';
    CommandIDs.pasteAbove = 'notebook:paste-cell-above';
    CommandIDs.pasteBelow = 'notebook:paste-cell-below';
    CommandIDs.pasteAndReplace = 'notebook:paste-and-replace-cell';
    CommandIDs.moveUp = 'notebook:move-cell-up';
    CommandIDs.moveDown = 'notebook:move-cell-down';
    CommandIDs.clearOutputs = 'notebook:clear-cell-output';
    CommandIDs.deleteCell = 'notebook:delete-cell';
    CommandIDs.insertAbove = 'notebook:insert-cell-above';
    CommandIDs.insertBelow = 'notebook:insert-cell-below';
    CommandIDs.selectAbove = 'notebook:move-cursor-up';
    CommandIDs.selectBelow = 'notebook:move-cursor-down';
    CommandIDs.extendAbove = 'notebook:extend-marked-cells-above';
    CommandIDs.extendTop = 'notebook:extend-marked-cells-top';
    CommandIDs.extendBelow = 'notebook:extend-marked-cells-below';
    CommandIDs.extendBottom = 'notebook:extend-marked-cells-bottom';
    CommandIDs.selectAll = 'notebook:select-all';
    CommandIDs.deselectAll = 'notebook:deselect-all';
    CommandIDs.editMode = 'notebook:enter-edit-mode';
    CommandIDs.merge = 'notebook:merge-cells';
    CommandIDs.mergeAbove = 'notebook:merge-cell-above';
    CommandIDs.mergeBelow = 'notebook:merge-cell-below';
    CommandIDs.split = 'notebook:split-cell-at-cursor';
    CommandIDs.commandMode = 'notebook:enter-command-mode';
    CommandIDs.toggleAllLines = 'notebook:toggle-all-cell-line-numbers';
    CommandIDs.undoCellAction = 'notebook:undo-cell-action';
    CommandIDs.redoCellAction = 'notebook:redo-cell-action';
    CommandIDs.markdown1 = 'notebook:change-cell-to-heading-1';
    CommandIDs.markdown2 = 'notebook:change-cell-to-heading-2';
    CommandIDs.markdown3 = 'notebook:change-cell-to-heading-3';
    CommandIDs.markdown4 = 'notebook:change-cell-to-heading-4';
    CommandIDs.markdown5 = 'notebook:change-cell-to-heading-5';
    CommandIDs.markdown6 = 'notebook:change-cell-to-heading-6';
    CommandIDs.hideCode = 'notebook:hide-cell-code';
    CommandIDs.showCode = 'notebook:show-cell-code';
    CommandIDs.hideAllCode = 'notebook:hide-all-cell-code';
    CommandIDs.showAllCode = 'notebook:show-all-cell-code';
    CommandIDs.hideOutput = 'notebook:hide-cell-outputs';
    CommandIDs.showOutput = 'notebook:show-cell-outputs';
    CommandIDs.hideAllOutputs = 'notebook:hide-all-cell-outputs';
    CommandIDs.showAllOutputs = 'notebook:show-all-cell-outputs';
    CommandIDs.enableOutputScrolling = 'notebook:enable-output-scrolling';
    CommandIDs.disableOutputScrolling = 'notebook:disable-output-scrolling';
    CommandIDs.selectLastRunCell = 'notebook:select-last-run-cell';
    CommandIDs.replaceSelection = 'notebook:replace-selection';
    CommandIDs.autoClosingBrackets = 'notebook:toggle-autoclosing-brackets';
    CommandIDs.toggleCollapseCmd = 'Collapsible_Headings:Toggle_Collapse';
    CommandIDs.collapseAllCmd = 'Collapsible_Headings:Collapse_All';
    CommandIDs.expandAllCmd = 'Collapsible_Headings:Expand_All';
    CommandIDs.copyToClipboard = 'notebook:copy-to-clipboard';
})(CommandIDs || (CommandIDs = {}));
/**
 * The name of the factory that creates notebooks.
 */
const FACTORY = 'Notebook';
/**
 * The excluded Export To ...
 * (returned from nbconvert's export list)
 */
const FORMAT_EXCLUDE = ['notebook', 'python', 'custom'];
/**
 * The notebook widget tracker provider.
 */
const trackerPlugin = {
    id: '@jupyterlab/notebook-extension:tracker',
    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker,
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookWidgetFactory, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator],
    optional: [
        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette,
        _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_6__.IFileBrowserFactory,
        _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_7__.ILauncher,
        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILayoutRestorer,
        _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_8__.IMainMenu,
        _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12__.ISettingRegistry,
        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISessionContextDialogs
    ],
    activate: activateNotebookHandler,
    autoStart: true
};
/**
 * The notebook cell factory provider.
 */
const factory = {
    id: '@jupyterlab/notebook-extension:factory',
    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookPanel.IContentFactory,
    requires: [_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices],
    autoStart: true,
    activate: (app, editorServices) => {
        const editorFactory = editorServices.factoryService.newInlineEditor;
        return new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookPanel.ContentFactory({ editorFactory });
    }
};
/**
 * The notebook tools extension.
 */
const tools = {
    activate: activateNotebookTools,
    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTools,
    id: '@jupyterlab/notebook-extension:tools',
    autoStart: true,
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices, _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_13__.IStateDB, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator],
    optional: [_jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_10__.IPropertyInspectorProvider]
};
/**
 * A plugin providing a CommandEdit status item.
 */
const commandEditItem = {
    id: '@jupyterlab/notebook-extension:mode-status',
    autoStart: true,
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator],
    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_14__.IStatusBar],
    activate: (app, tracker, translator, statusBar) => {
        if (!statusBar) {
            // Automatically disable if statusbar missing
            return;
        }
        const { shell } = app;
        const item = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.CommandEditStatus(translator);
        // Keep the status item up-to-date with the current notebook.
        tracker.currentChanged.connect(() => {
            const current = tracker.currentWidget;
            item.model.notebook = current && current.content;
        });
        statusBar.registerStatusItem('@jupyterlab/notebook-extension:mode-status', {
            item,
            align: 'right',
            rank: 4,
            isActive: () => !!shell.currentWidget &&
                !!tracker.currentWidget &&
                shell.currentWidget === tracker.currentWidget
        });
    }
};
/**
 * A plugin providing export commands in the main menu and command palette
 */
const exportPlugin = {
    id: '@jupyterlab/notebook-extension:export',
    autoStart: true,
    requires: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker],
    optional: [_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_8__.IMainMenu, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette],
    activate: (app, translator, tracker, mainMenu, palette) => {
        var _a;
        const trans = translator.load('jupyterlab');
        const { commands, shell } = app;
        const services = app.serviceManager;
        const isEnabled = () => {
            return Private.isEnabled(shell, tracker);
        };
        commands.addCommand(CommandIDs.exportToFormat, {
            label: args => {
                const formatLabel = args['label'];
                return args['isPalette']
                    ? trans.__('Export Notebook: %1', formatLabel)
                    : formatLabel;
            },
            execute: args => {
                const current = getCurrent(tracker, shell, args);
                if (!current) {
                    return;
                }
                const url = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__.PageConfig.getNBConvertURL({
                    format: args['format'],
                    download: true,
                    path: current.context.path
                });
                const child = window.open('', '_blank');
                const { context } = current;
                if (child) {
                    child.opener = null;
                }
                if (context.model.dirty && !context.model.readOnly) {
                    return context.save().then(() => {
                        child === null || child === void 0 ? void 0 : child.location.assign(url);
                    });
                }
                return new Promise(resolve => {
                    child === null || child === void 0 ? void 0 : child.location.assign(url);
                    resolve(undefined);
                });
            },
            isEnabled
        });
        // Add a notebook group to the File menu.
        let exportTo;
        if (mainMenu) {
            exportTo = (_a = mainMenu.fileMenu.items.find(item => {
                var _a;
                return item.type === 'submenu' &&
                    ((_a = item.submenu) === null || _a === void 0 ? void 0 : _a.id) === 'jp-mainmenu-file-notebookexport';
            })) === null || _a === void 0 ? void 0 : _a.submenu;
        }
        void services.nbconvert.getExportFormats().then(response => {
            if (response) {
                const formatLabels = Private.getFormatLabels(translator);
                // Convert export list to palette and menu items.
                const formatList = Object.keys(response);
                formatList.forEach(function (key) {
                    const capCaseKey = trans.__(key[0].toUpperCase() + key.substr(1));
                    const labelStr = formatLabels[key] ? formatLabels[key] : capCaseKey;
                    let args = {
                        format: key,
                        label: labelStr,
                        isPalette: false
                    };
                    if (FORMAT_EXCLUDE.indexOf(key) === -1) {
                        if (exportTo) {
                            exportTo.addItem({
                                command: CommandIDs.exportToFormat,
                                args: args
                            });
                        }
                        if (palette) {
                            args = {
                                format: key,
                                label: labelStr,
                                isPalette: true
                            };
                            const category = trans.__('Notebook Operations');
                            palette.addItem({
                                command: CommandIDs.exportToFormat,
                                category,
                                args
                            });
                        }
                    }
                });
            }
        });
    }
};
/**
 * A plugin that adds a notebook trust status item to the status bar.
 */
const notebookTrustItem = {
    id: '@jupyterlab/notebook-extension:trust-status',
    autoStart: true,
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator],
    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_14__.IStatusBar],
    activate: (app, tracker, tranlator, statusBar) => {
        if (!statusBar) {
            // Automatically disable if statusbar missing
            return;
        }
        const { shell } = app;
        const item = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTrustStatus(tranlator);
        // Keep the status item up-to-date with the current notebook.
        tracker.currentChanged.connect(() => {
            const current = tracker.currentWidget;
            item.model.notebook = current && current.content;
        });
        statusBar.registerStatusItem('@jupyterlab/notebook-extension:trust-status', {
            item,
            align: 'right',
            rank: 3,
            isActive: () => !!shell.currentWidget &&
                !!tracker.currentWidget &&
                shell.currentWidget === tracker.currentWidget
        });
    }
};
/**
 * The notebook widget factory provider.
 */
const widgetFactoryPlugin = {
    id: '@jupyterlab/notebook-extension:widget-factory',
    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookWidgetFactory,
    requires: [
        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookPanel.IContentFactory,
        _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices,
        _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__.IRenderMimeRegistry,
        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISessionContextDialogs,
        _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator
    ],
    activate: activateWidgetFactory,
    autoStart: true
};
/**
 * The cloned output provider.
 */
const clonedOutputsPlugin = {
    id: '@jupyterlab/notebook-extension:cloned-outputs',
    requires: [_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_5__.IDocumentManager, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator],
    optional: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILayoutRestorer],
    activate: activateClonedOutputs,
    autoStart: true
};
/**
 * A plugin for code consoles functionalities.
 */
const codeConsolePlugin = {
    id: '@jupyterlab/notebook-extension:code-console',
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator],
    activate: activateCodeConsole,
    autoStart: true
};
/**
 * A plugin to copy CodeCell outputs.
 */
const copyOutputPlugin = {
    id: '@jupyterlab/notebook-extensions:copy-output',
    activate: activateCopyOutput,
    requires: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.ITranslator, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.INotebookTracker],
    autoStart: true
};
/**
 * Export the plugins as default.
 */
const plugins = [
    factory,
    trackerPlugin,
    exportPlugin,
    tools,
    commandEditItem,
    notebookTrustItem,
    widgetFactoryPlugin,
    _nboutput__WEBPACK_IMPORTED_MODULE_22__.logNotebookOutput,
    clonedOutputsPlugin,
    codeConsolePlugin,
    copyOutputPlugin
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugins);
/**
 * Activate the notebook tools extension.
 */
function activateNotebookTools(app, tracker, editorServices, state, translator, inspectorProvider) {
    const trans = translator.load('jupyterlab');
    const id = 'notebook-tools';
    const notebookTools = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTools({ tracker, translator });
    const activeCellTool = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTools.ActiveCellTool();
    const slideShow = _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTools.createSlideShowSelector(translator);
    const editorFactory = editorServices.factoryService.newInlineEditor;
    const cellMetadataEditor = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTools.CellMetadataEditorTool({
        editorFactory,
        collapsed: false,
        translator
    });
    const notebookMetadataEditor = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTools.NotebookMetadataEditorTool({
        editorFactory,
        translator
    });
    const services = app.serviceManager;
    // Create message hook for triggers to save to the database.
    const hook = (sender, message) => {
        switch (message.type) {
            case 'activate-request':
                void state.save(id, { open: true });
                break;
            case 'after-hide':
            case 'close-request':
                void state.remove(id);
                break;
            default:
                break;
        }
        return true;
    };
    const optionsMap = {};
    optionsMap.None = null;
    void services.nbconvert.getExportFormats().then(response => {
        if (response) {
            /**
             * The excluded Cell Inspector Raw NbConvert Formats
             * (returned from nbconvert's export list)
             */
            const rawFormatExclude = [
                'pdf',
                'slides',
                'script',
                'notebook',
                'custom'
            ];
            let optionValueArray = [
                [trans.__('PDF'), 'pdf'],
                [trans.__('Slides'), 'slides'],
                [trans.__('Script'), 'script'],
                [trans.__('Notebook'), 'notebook'],
                [trans.__('Custom'), 'custom']
            ];
            // convert exportList to palette and menu items
            const formatList = Object.keys(response);
            const formatLabels = Private.getFormatLabels(translator);
            formatList.forEach(function (key) {
                if (rawFormatExclude.indexOf(key) === -1) {
                    const altOption = trans.__(key[0].toUpperCase() + key.substr(1));
                    const option = formatLabels[key] ? formatLabels[key] : altOption;
                    const mimeTypeValue = response[key].output_mimetype;
                    optionValueArray.push([option, mimeTypeValue]);
                }
            });
            const nbConvert = _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTools.createNBConvertSelector(optionValueArray, translator);
            notebookTools.addItem({ tool: nbConvert, section: 'common', rank: 3 });
        }
    });
    notebookTools.title.icon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_16__.buildIcon;
    notebookTools.title.caption = trans.__('Notebook Tools');
    notebookTools.id = id;
    notebookTools.addItem({ tool: activeCellTool, section: 'common', rank: 1 });
    notebookTools.addItem({ tool: slideShow, section: 'common', rank: 2 });
    notebookTools.addItem({
        tool: cellMetadataEditor,
        section: 'advanced',
        rank: 1
    });
    notebookTools.addItem({
        tool: notebookMetadataEditor,
        section: 'advanced',
        rank: 2
    });
    _lumino_messaging__WEBPACK_IMPORTED_MODULE_20__.MessageLoop.installMessageHook(notebookTools, hook);
    if (inspectorProvider) {
        tracker.widgetAdded.connect((sender, panel) => {
            const inspector = inspectorProvider.register(panel);
            inspector.render(notebookTools);
        });
    }
    return notebookTools;
}
/**
 * Activate the notebook widget factory.
 */
function activateWidgetFactory(app, contentFactory, editorServices, rendermime, sessionContextDialogs, translator) {
    const factory = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookWidgetFactory({
        name: FACTORY,
        fileTypes: ['notebook'],
        modelName: 'notebook',
        defaultFor: ['notebook'],
        preferKernel: true,
        canStartKernel: true,
        rendermime: rendermime,
        contentFactory,
        editorConfig: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.StaticNotebook.defaultEditorConfig,
        notebookConfig: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.StaticNotebook.defaultNotebookConfig,
        mimeTypeService: editorServices.mimeTypeService,
        sessionDialogs: sessionContextDialogs,
        translator: translator
    });
    app.docRegistry.addWidgetFactory(factory);
    return factory;
}
/**
 * Activate the plugin to create and track cloned outputs.
 */
function activateClonedOutputs(app, docManager, notebookTracker, translator, restorer) {
    const trans = translator.load('jupyterlab');
    const clonedOutputs = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.WidgetTracker({
        namespace: 'cloned-outputs'
    });
    if (restorer) {
        void restorer.restore(clonedOutputs, {
            command: CommandIDs.createOutputView,
            args: widget => ({
                path: widget.content.path,
                index: widget.content.index
            }),
            name: widget => `${widget.content.path}:${widget.content.index}`,
            when: notebookTracker.restored // After the notebook widgets (but not contents).
        });
    }
    const { commands, shell } = app;
    const isEnabledAndSingleSelected = () => {
        return Private.isEnabledAndSingleSelected(shell, notebookTracker);
    };
    commands.addCommand(CommandIDs.createOutputView, {
        label: trans.__('Create New View for Output'),
        execute: async (args) => {
            var _a;
            let cell;
            let current;
            // If we are given a notebook path and cell index, then
            // use that, otherwise use the current active cell.
            const path = args.path;
            let index = args.index;
            if (path && index !== undefined && index !== null) {
                current = docManager.findWidget(path, FACTORY);
                if (!current) {
                    return;
                }
            }
            else {
                current = notebookTracker.currentWidget;
                if (!current) {
                    return;
                }
                cell = current.content.activeCell;
                index = current.content.activeCellIndex;
            }
            // Create a MainAreaWidget
            const content = new Private.ClonedOutputArea({
                notebook: current,
                cell,
                index,
                translator
            });
            const widget = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.MainAreaWidget({ content });
            current.context.addSibling(widget, {
                ref: current.id,
                mode: 'split-bottom'
            });
            const updateCloned = () => {
                void clonedOutputs.save(widget);
            };
            current.context.pathChanged.connect(updateCloned);
            (_a = current.context.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(updateCloned);
            // Add the cloned output to the output widget tracker.
            void clonedOutputs.add(widget);
            // Remove the output view if the parent notebook is closed.
            current.content.disposed.connect(() => {
                var _a;
                current.context.pathChanged.disconnect(updateCloned);
                (_a = current.context.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(updateCloned);
                widget.dispose();
            });
        },
        isEnabled: isEnabledAndSingleSelected
    });
}
/**
 * Activate the plugin to add code console functionalities
 */
function activateCodeConsole(app, tracker, translator) {
    const trans = translator.load('jupyterlab');
    const { commands, shell } = app;
    const isEnabled = () => Private.isEnabled(shell, tracker);
    commands.addCommand(CommandIDs.createConsole, {
        label: trans.__('New Console for Notebook'),
        execute: args => {
            const current = tracker.currentWidget;
            if (!current) {
                return;
            }
            return Private.createConsole(commands, current, args['activate']);
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.runInConsole, {
        label: trans.__('Run Selected Text or Current Line in Console'),
        execute: async (args) => {
            var _a, _b;
            // Default to not activating the notebook (thereby putting the notebook
            // into command mode)
            const current = tracker.currentWidget;
            if (!current) {
                return;
            }
            const { context, content } = current;
            const cell = content.activeCell;
            const metadata = cell === null || cell === void 0 ? void 0 : cell.model.metadata.toJSON();
            const path = context.path;
            // ignore action in non-code cell
            if (!cell || cell.model.type !== 'code') {
                return;
            }
            let code;
            const editor = cell.editor;
            const selection = editor.getSelection();
            const { start, end } = selection;
            const selected = start.column !== end.column || start.line !== end.line;
            if (selected) {
                // Get the selected code from the editor.
                const start = editor.getOffsetAt(selection.start);
                const end = editor.getOffsetAt(selection.end);
                code = editor.model.value.text.substring(start, end);
            }
            else {
                // no selection, find the complete statement around the current line
                const cursor = editor.getCursorPosition();
                const srcLines = editor.model.value.text.split('\n');
                let curLine = selection.start.line;
                while (curLine < editor.lineCount &&
                    !srcLines[curLine].replace(/\s/g, '').length) {
                    curLine += 1;
                }
                // if curLine > 0, we first do a search from beginning
                let fromFirst = curLine > 0;
                let firstLine = 0;
                let lastLine = firstLine + 1;
                // eslint-disable-next-line
                while (true) {
                    code = srcLines.slice(firstLine, lastLine).join('\n');
                    const reply = await ((_b = (_a = current.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.requestIsComplete({
                        // ipython needs an empty line at the end to correctly identify completeness of indented code
                        code: code + '\n\n'
                    }));
                    if ((reply === null || reply === void 0 ? void 0 : reply.content.status) === 'complete') {
                        if (curLine < lastLine) {
                            // we find a block of complete statement containing the current line, great!
                            while (lastLine < editor.lineCount &&
                                !srcLines[lastLine].replace(/\s/g, '').length) {
                                lastLine += 1;
                            }
                            editor.setCursorPosition({
                                line: lastLine,
                                column: cursor.column
                            });
                            break;
                        }
                        else {
                            // discard the complete statement before the current line and continue
                            firstLine = lastLine;
                            lastLine = firstLine + 1;
                        }
                    }
                    else if (lastLine < editor.lineCount) {
                        // if incomplete and there are more lines, add the line and check again
                        lastLine += 1;
                    }
                    else if (fromFirst) {
                        // we search from the first line and failed, we search again from current line
                        firstLine = curLine;
                        lastLine = curLine + 1;
                        fromFirst = false;
                    }
                    else {
                        // if we have searched both from first line and from current line and we
                        // cannot find anything, we submit the current line.
                        code = srcLines[curLine];
                        while (curLine + 1 < editor.lineCount &&
                            !srcLines[curLine + 1].replace(/\s/g, '').length) {
                            curLine += 1;
                        }
                        editor.setCursorPosition({
                            line: curLine + 1,
                            column: cursor.column
                        });
                        break;
                    }
                }
            }
            if (!code) {
                return;
            }
            await commands.execute('console:open', {
                activate: false,
                insertMode: 'split-bottom',
                path
            });
            await commands.execute('console:inject', {
                activate: false,
                code,
                path,
                metadata
            });
        },
        isEnabled
    });
}
/**
 * Activate the output copying extension
 */
function activateCopyOutput(app, translator, tracker) {
    const trans = translator.load('jupyterlab');
    /**
     * Copy the contents of an HTMLElement to the system clipboard
     */
    function copyElement(e) {
        const sel = window.getSelection();
        if (sel == null) {
            return;
        }
        // Save the current selection.
        const savedRanges = [];
        for (let i = 0; i < sel.rangeCount; ++i) {
            savedRanges[i] = sel.getRangeAt(i).cloneRange();
        }
        const range = document.createRange();
        range.selectNodeContents(e);
        sel.removeAllRanges();
        sel.addRange(range);
        document.execCommand('copy');
        // Restore the saved selection.
        sel.removeAllRanges();
        savedRanges.forEach(r => sel.addRange(r));
    }
    app.commands.addCommand(CommandIDs.copyToClipboard, {
        label: trans.__('Copy Output to Clipboard'),
        execute: args => {
            var _a;
            const cell = (_a = tracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content.activeCell;
            if (cell == null) {
                return;
            }
            const output = cell.outputArea.outputTracker.currentWidget;
            if (output == null) {
                return;
            }
            const outputAreaAreas = output.node.getElementsByClassName('jp-OutputArea-output');
            if (outputAreaAreas.length > 0) {
                const area = outputAreaAreas[0];
                copyElement(area);
            }
        }
    });
    app.contextMenu.addItem({
        command: CommandIDs.copyToClipboard,
        selector: '.jp-OutputArea-child',
        rank: 0
    });
}
/**
 * Activate the notebook handler extension.
 */
function activateNotebookHandler(app, factory, translator, palette, browserFactory, launcher, restorer, mainMenu, settingRegistry, sessionDialogs) {
    const trans = translator.load('jupyterlab');
    const services = app.serviceManager;
    const { commands } = app;
    const tracker = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookTracker({ namespace: 'notebook' });
    // Fetch settings if possible.
    const fetchSettings = settingRegistry
        ? settingRegistry.load(trackerPlugin.id)
        : Promise.reject(new Error(`No setting registry for ${trackerPlugin.id}`));
    // Handle state restoration.
    if (restorer) {
        fetchSettings
            .then(settings => {
            updateConfig(settings);
            settings.changed.connect(() => {
                updateConfig(settings);
            });
            commands.addCommand(CommandIDs.autoClosingBrackets, {
                execute: args => {
                    var _a;
                    const codeConfig = settings.get('codeCellConfig')
                        .composite;
                    const markdownConfig = settings.get('markdownCellConfig')
                        .composite;
                    const rawConfig = settings.get('rawCellConfig')
                        .composite;
                    const anyToggled = codeConfig.autoClosingBrackets ||
                        markdownConfig.autoClosingBrackets ||
                        rawConfig.autoClosingBrackets;
                    const toggled = !!((_a = args['force']) !== null && _a !== void 0 ? _a : !anyToggled);
                    [
                        codeConfig.autoClosingBrackets,
                        markdownConfig.autoClosingBrackets,
                        rawConfig.autoClosingBrackets
                    ] = [toggled, toggled, toggled];
                    void settings.set('codeCellConfig', codeConfig);
                    void settings.set('markdownCellConfig', markdownConfig);
                    void settings.set('rawCellConfig', rawConfig);
                },
                label: trans.__('Auto Close Brackets for All Notebook Cell Types'),
                isToggled: () => ['codeCellConfig', 'markdownCellConfig', 'rawCellConfig'].some(x => settings.get(x).composite.autoClosingBrackets)
            });
        })
            .catch((reason) => {
            console.warn(reason.message);
            updateTracker({
                editorConfig: factory.editorConfig,
                notebookConfig: factory.notebookConfig,
                kernelShutdown: factory.shutdownOnClose
            });
        });
        void restorer.restore(tracker, {
            command: 'docmanager:open',
            args: panel => ({ path: panel.context.path, factory: FACTORY }),
            name: panel => panel.context.path,
            when: services.ready
        });
    }
    const registry = app.docRegistry;
    registry.addModelFactory(new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookModelFactory({}));
    addCommands(app, tracker, translator, sessionDialogs);
    if (palette) {
        populatePalette(palette, translator);
    }
    let id = 0; // The ID counter for notebook panels.
    const ft = app.docRegistry.getFileType('notebook');
    factory.widgetCreated.connect((sender, widget) => {
        var _a, _b;
        // If the notebook panel does not have an ID, assign it one.
        widget.id = widget.id || `notebook-${++id}`;
        // Set up the title icon
        widget.title.icon = ft === null || ft === void 0 ? void 0 : ft.icon;
        widget.title.iconClass = (_a = ft === null || ft === void 0 ? void 0 : ft.iconClass) !== null && _a !== void 0 ? _a : '';
        widget.title.iconLabel = (_b = ft === null || ft === void 0 ? void 0 : ft.iconLabel) !== null && _b !== void 0 ? _b : '';
        // Notify the widget tracker if restore data needs to update.
        widget.context.pathChanged.connect(() => {
            void tracker.save(widget);
        });
        // Add the notebook panel to the tracker.
        void tracker.add(widget);
    });
    /**
     * Update the settings of the current tracker.
     */
    function updateTracker(options) {
        tracker.forEach(widget => {
            widget.setConfig(options);
        });
    }
    /**
     * Update the setting values.
     */
    function updateConfig(settings) {
        const code = Object.assign(Object.assign({}, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.StaticNotebook.defaultEditorConfig.code), settings.get('codeCellConfig').composite);
        const markdown = Object.assign(Object.assign({}, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.StaticNotebook.defaultEditorConfig.markdown), settings.get('markdownCellConfig').composite);
        const raw = Object.assign(Object.assign({}, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.StaticNotebook.defaultEditorConfig.raw), settings.get('rawCellConfig').composite);
        factory.editorConfig = { code, markdown, raw };
        factory.notebookConfig = {
            scrollPastEnd: settings.get('scrollPastEnd').composite,
            defaultCell: settings.get('defaultCell').composite,
            recordTiming: settings.get('recordTiming').composite,
            numberCellsToRenderDirectly: settings.get('numberCellsToRenderDirectly')
                .composite,
            renderCellOnIdle: settings.get('renderCellOnIdle').composite,
            observedTopMargin: settings.get('observedTopMargin').composite,
            observedBottomMargin: settings.get('observedBottomMargin')
                .composite,
            maxNumberOutputs: settings.get('maxNumberOutputs').composite
        };
        factory.shutdownOnClose = settings.get('kernelShutdown')
            .composite;
        updateTracker({
            editorConfig: factory.editorConfig,
            notebookConfig: factory.notebookConfig,
            kernelShutdown: factory.shutdownOnClose
        });
    }
    // Add main menu notebook menu.
    if (mainMenu) {
        populateMenus(app, mainMenu, tracker, translator, sessionDialogs);
    }
    // Utility function to create a new notebook.
    const createNew = (cwd, kernelName) => {
        return commands
            .execute('docmanager:new-untitled', { path: cwd, type: 'notebook' })
            .then(model => {
            if (model != undefined) {
                return commands.execute('docmanager:open', {
                    path: model.path,
                    factory: FACTORY,
                    kernel: { name: kernelName }
                });
            }
        });
    };
    // Add a command for creating a new notebook.
    commands.addCommand(CommandIDs.createNew, {
        label: args => {
            var _a, _b, _c;
            const kernelName = args['kernelName'] || '';
            if (args['isLauncher'] && args['kernelName'] && services.kernelspecs) {
                return ((_c = (_b = (_a = services.kernelspecs.specs) === null || _a === void 0 ? void 0 : _a.kernelspecs[kernelName]) === null || _b === void 0 ? void 0 : _b.display_name) !== null && _c !== void 0 ? _c : '');
            }
            if (args['isPalette']) {
                return trans.__('New Notebook');
            }
            return trans.__('Notebook');
        },
        caption: trans.__('Create a new notebook'),
        icon: args => (args['isPalette'] ? undefined : _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_16__.notebookIcon),
        execute: args => {
            const cwd = args['cwd'] ||
                (browserFactory ? browserFactory.defaultBrowser.model.path : '');
            const kernelName = args['kernelName'] || '';
            return createNew(cwd, kernelName);
        }
    });
    // Add a launcher item if the launcher is available.
    if (launcher) {
        void services.ready.then(() => {
            let disposables = null;
            const onSpecsChanged = () => {
                if (disposables) {
                    disposables.dispose();
                    disposables = null;
                }
                const specs = services.kernelspecs.specs;
                if (!specs) {
                    return;
                }
                disposables = new _lumino_disposable__WEBPACK_IMPORTED_MODULE_19__.DisposableSet();
                const baseUrl = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__.PageConfig.getBaseUrl();
                for (const name in specs.kernelspecs) {
                    const rank = name === specs.default ? 0 : Infinity;
                    const spec = specs.kernelspecs[name];
                    let kernelIconUrl = spec.resources['logo-64x64'];
                    if (kernelIconUrl) {
                        const index = kernelIconUrl.indexOf('kernelspecs');
                        kernelIconUrl = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__.URLExt.join(baseUrl, kernelIconUrl.slice(index));
                    }
                    disposables.add(launcher.add({
                        command: CommandIDs.createNew,
                        args: { isLauncher: true, kernelName: name },
                        category: trans.__('Notebook'),
                        rank,
                        kernelIconUrl,
                        metadata: {
                            kernel: _lumino_coreutils__WEBPACK_IMPORTED_MODULE_18__.JSONExt.deepCopy(spec.metadata || {})
                        }
                    }));
                }
            };
            onSpecsChanged();
            services.kernelspecs.specsChanged.connect(onSpecsChanged);
        });
    }
    return tracker;
}
// Get the current widget and activate unless the args specify otherwise.
function getCurrent(tracker, shell, args) {
    const widget = tracker.currentWidget;
    const activate = args['activate'] !== false;
    if (activate && widget) {
        shell.activateById(widget.id);
    }
    return widget;
}
/**
 * Add the notebook commands to the application's command registry.
 */
function addCommands(app, tracker, translator, sessionDialogs) {
    const trans = translator.load('jupyterlab');
    const { commands, shell } = app;
    sessionDialogs = sessionDialogs !== null && sessionDialogs !== void 0 ? sessionDialogs : _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.sessionContextDialogs;
    const isEnabled = () => {
        return Private.isEnabled(shell, tracker);
    };
    const isEnabledAndSingleSelected = () => {
        return Private.isEnabledAndSingleSelected(shell, tracker);
    };
    const refreshCellCollapsed = (notebook) => {
        var _a, _b;
        for (const cell of notebook.widgets) {
            if (cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.MarkdownCell && cell.headingCollapsed) {
                _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setHeadingCollapse(cell, true, notebook);
            }
            if (cell.model.id === ((_b = (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.id)) {
                _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.expandParent(cell, notebook);
            }
        }
    };
    const isEnabledAndHeadingSelected = () => {
        return Private.isEnabledAndHeadingSelected(shell, tracker);
    };
    // Set up collapse signal for each header cell in a notebook
    tracker.currentChanged.connect((sender, panel) => {
        var _a, _b;
        if (!((_b = (_a = panel === null || panel === void 0 ? void 0 : panel.content) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.cells)) {
            return;
        }
        panel.content.model.cells.changed.connect((list, args) => {
            const cell = panel.content.widgets[args.newIndex];
            if (cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.MarkdownCell &&
                (args.type === 'add' || args.type === 'set')) {
                cell.toggleCollapsedSignal.connect((newCell, collapsing) => {
                    _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setHeadingCollapse(newCell, collapsing, panel.content);
                });
            }
            // Might be overkill to refresh this every time, but
            // it helps to keep the collapse state consistent.
            refreshCellCollapsed(panel.content);
        });
        panel.content.activeCellChanged.connect((notebook, cell) => {
            _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.expandParent(cell, notebook);
        });
    });
    commands.addCommand(CommandIDs.runAndAdvance, {
        label: trans.__('Run Selected Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAndAdvance(content, context.sessionContext);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.run, {
        label: trans.__("Run Selected Cells and Don't Advance"),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.run(content, context.sessionContext);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.runAndInsert, {
        label: trans.__('Run Selected Cells and Insert Below'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAndInsert(content, context.sessionContext);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.runAll, {
        label: trans.__('Run All Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAll(content, context.sessionContext);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.runAllAbove, {
        label: trans.__('Run All Above Selected Cell'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAllAbove(content, context.sessionContext);
            }
        },
        isEnabled: () => {
            // Can't run above if there are multiple cells selected,
            // or if we are at the top of the notebook.
            return (isEnabledAndSingleSelected() &&
                tracker.currentWidget.content.activeCellIndex !== 0);
        }
    });
    commands.addCommand(CommandIDs.runAllBelow, {
        label: trans.__('Run Selected Cell and All Below'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAllBelow(content, context.sessionContext);
            }
        },
        isEnabled: () => {
            // Can't run below if there are multiple cells selected,
            // or if we are at the bottom of the notebook.
            return (isEnabledAndSingleSelected() &&
                tracker.currentWidget.content.activeCellIndex !==
                    tracker.currentWidget.content.widgets.length - 1);
        }
    });
    commands.addCommand(CommandIDs.renderAllMarkdown, {
        label: trans.__('Render All Markdown Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.renderAllMarkdown(content, context.sessionContext);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.restart, {
        label: trans.__('Restart Kernel'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return sessionDialogs.restart(current.sessionContext, translator);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.closeAndShutdown, {
        label: trans.__('Close and Shut Down'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (!current) {
                return;
            }
            const fileName = current.title.label;
            return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({
                title: trans.__('Shut down the notebook?'),
                body: trans.__('Are you sure you want to close "%1"?', fileName),
                buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton(), _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.warnButton()]
            }).then(result => {
                if (result.button.accept) {
                    return current.context.sessionContext.shutdown().then(() => {
                        current.dispose();
                    });
                }
            });
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.trust, {
        label: () => trans.__('Trust Notebook'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.trust(content).then(() => context.save());
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.restartClear, {
        label: trans.__('Restart Kernel and Clear All Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { content, sessionContext } = current;
                return sessionDialogs.restart(sessionContext, translator).then(() => {
                    _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.clearAllOutputs(content);
                });
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.restartAndRunToSelected, {
        label: trans.__('Restart Kernel and Run up to Selected Cell'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content } = current;
                return sessionDialogs
                    .restart(current.sessionContext, translator)
                    .then(restarted => {
                    if (restarted) {
                        void _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAllAbove(content, context.sessionContext).then(executed => {
                            if (executed || content.activeCellIndex === 0) {
                                void _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.run(content, context.sessionContext);
                            }
                        });
                    }
                });
            }
        },
        isEnabled: isEnabledAndSingleSelected
    });
    commands.addCommand(CommandIDs.restartRunAll, {
        label: trans.__('Restart Kernel and Run All Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                const { context, content, sessionContext } = current;
                return sessionDialogs
                    .restart(sessionContext, translator)
                    .then(restarted => {
                    if (restarted) {
                        void _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAll(content, context.sessionContext);
                    }
                    return restarted;
                });
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.clearAllOutputs, {
        label: trans.__('Clear All Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.clearAllOutputs(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.clearOutputs, {
        label: trans.__('Clear Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.clearOutputs(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.interrupt, {
        label: trans.__('Interrupt Kernel'),
        execute: args => {
            var _a;
            const current = getCurrent(tracker, shell, args);
            if (!current) {
                return;
            }
            const kernel = (_a = current.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
            if (kernel) {
                return kernel.interrupt();
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.toCode, {
        label: trans.__('Change to Code Cell Type'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.changeCellType(current.content, 'code');
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.toMarkdown, {
        label: trans.__('Change to Markdown Cell Type'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.changeCellType(current.content, 'markdown');
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.toRaw, {
        label: trans.__('Change to Raw Cell Type'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.changeCellType(current.content, 'raw');
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.cut, {
        label: trans.__('Cut Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.cut(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.copy, {
        label: trans.__('Copy Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.copy(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.pasteBelow, {
        label: trans.__('Paste Cells Below'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.paste(current.content, 'below');
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.pasteAbove, {
        label: trans.__('Paste Cells Above'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.paste(current.content, 'above');
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.pasteAndReplace, {
        label: trans.__('Paste Cells and Replace'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.paste(current.content, 'replace');
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.deleteCell, {
        label: trans.__('Delete Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.deleteCells(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.split, {
        label: trans.__('Split Cell'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.splitCell(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.merge, {
        label: trans.__('Merge Selected Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.mergeCells(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.mergeAbove, {
        label: trans.__('Merge Cell Above'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.mergeCells(current.content, true);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.mergeBelow, {
        label: trans.__('Merge Cell Below'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.mergeCells(current.content, false);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.insertAbove, {
        label: trans.__('Insert Cell Above'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.insertAbove(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.insertBelow, {
        label: trans.__('Insert Cell Below'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.insertBelow(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.selectAbove, {
        label: trans.__('Select Cell Above'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.selectAbove(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.selectBelow, {
        label: trans.__('Select Cell Below'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.selectBelow(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.extendAbove, {
        label: trans.__('Extend Selection Above'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.extendSelectionAbove(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.extendTop, {
        label: trans.__('Extend Selection to Top'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.extendSelectionAbove(current.content, true);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.extendBelow, {
        label: trans.__('Extend Selection Below'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.extendSelectionBelow(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.extendBottom, {
        label: trans.__('Extend Selection to Bottom'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.extendSelectionBelow(current.content, true);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.selectAll, {
        label: trans.__('Select All Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.selectAll(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.deselectAll, {
        label: trans.__('Deselect All Cells'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.deselectAll(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.moveUp, {
        label: trans.__('Move Cells Up'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.moveUp(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.moveDown, {
        label: trans.__('Move Cells Down'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.moveDown(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.toggleAllLines, {
        label: trans.__('Toggle All Line Numbers'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.toggleAllLineNumbers(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.commandMode, {
        label: trans.__('Enter Command Mode'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                current.content.mode = 'command';
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.editMode, {
        label: trans.__('Enter Edit Mode'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                current.content.mode = 'edit';
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.undoCellAction, {
        label: trans.__('Undo Cell Operation'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.undo(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.redoCellAction, {
        label: trans.__('Redo Cell Operation'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.redo(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.changeKernel, {
        label: trans.__('Change Kernel'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return sessionDialogs.selectKernel(current.context.sessionContext, translator);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.reconnectToKernel, {
        label: trans.__('Reconnect To Kernel'),
        execute: args => {
            var _a;
            const current = getCurrent(tracker, shell, args);
            if (!current) {
                return;
            }
            const kernel = (_a = current.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
            if (kernel) {
                return kernel.reconnect();
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.markdown1, {
        label: trans.__('Change to Heading 1'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setMarkdownHeader(current.content, 1);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.markdown2, {
        label: trans.__('Change to Heading 2'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setMarkdownHeader(current.content, 2);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.markdown3, {
        label: trans.__('Change to Heading 3'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setMarkdownHeader(current.content, 3);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.markdown4, {
        label: trans.__('Change to Heading 4'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setMarkdownHeader(current.content, 4);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.markdown5, {
        label: trans.__('Change to Heading 5'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setMarkdownHeader(current.content, 5);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.markdown6, {
        label: trans.__('Change to Heading 6'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.setMarkdownHeader(current.content, 6);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.hideCode, {
        label: trans.__('Collapse Selected Code'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.hideCode(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.showCode, {
        label: trans.__('Expand Selected Code'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.showCode(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.hideAllCode, {
        label: trans.__('Collapse All Code'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.hideAllCode(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.showAllCode, {
        label: trans.__('Expand All Code'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.showAllCode(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.hideOutput, {
        label: trans.__('Collapse Selected Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.hideOutput(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.showOutput, {
        label: trans.__('Expand Selected Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.showOutput(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.hideAllOutputs, {
        label: trans.__('Collapse All Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.hideAllOutputs(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.showAllOutputs, {
        label: trans.__('Expand All Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.showAllOutputs(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.enableOutputScrolling, {
        label: trans.__('Enable Scrolling for Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.enableOutputScrolling(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.disableOutputScrolling, {
        label: trans.__('Disable Scrolling for Outputs'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.disableOutputScrolling(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.selectLastRunCell, {
        label: trans.__('Select current running or last run cell'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.selectLastRunCell(current.content);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.replaceSelection, {
        label: trans.__('Replace Selection in Notebook Cell'),
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            const text = args['text'] || '';
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.replaceSelection(current.content, text);
            }
        },
        isEnabled
    });
    commands.addCommand(CommandIDs.toggleCollapseCmd, {
        label: 'Toggle Collapse Notebook Heading',
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.toggleCurrentHeadingCollapse(current.content);
            }
        },
        isEnabled: isEnabledAndHeadingSelected
    });
    commands.addCommand(CommandIDs.collapseAllCmd, {
        label: 'Collapse All Cells',
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.collapseAll(current.content);
            }
        }
    });
    commands.addCommand(CommandIDs.expandAllCmd, {
        label: 'Expand All Headings',
        execute: args => {
            const current = getCurrent(tracker, shell, args);
            if (current) {
                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.expandAllHeadings(current.content);
            }
        }
    });
}
/**
 * Populate the application's command palette with notebook commands.
 */
function populatePalette(palette, translator) {
    const trans = translator.load('jupyterlab');
    let category = trans.__('Notebook Operations');
    [
        CommandIDs.interrupt,
        CommandIDs.restart,
        CommandIDs.restartClear,
        CommandIDs.restartRunAll,
        CommandIDs.runAll,
        CommandIDs.renderAllMarkdown,
        CommandIDs.runAllAbove,
        CommandIDs.runAllBelow,
        CommandIDs.restartAndRunToSelected,
        CommandIDs.selectAll,
        CommandIDs.deselectAll,
        CommandIDs.clearAllOutputs,
        CommandIDs.toggleAllLines,
        CommandIDs.editMode,
        CommandIDs.commandMode,
        CommandIDs.changeKernel,
        CommandIDs.reconnectToKernel,
        CommandIDs.createConsole,
        CommandIDs.closeAndShutdown,
        CommandIDs.trust,
        CommandIDs.toggleCollapseCmd,
        CommandIDs.collapseAllCmd,
        CommandIDs.expandAllCmd
    ].forEach(command => {
        palette.addItem({ command, category });
    });
    palette.addItem({
        command: CommandIDs.createNew,
        category,
        args: { isPalette: true }
    });
    category = trans.__('Notebook Cell Operations');
    [
        CommandIDs.run,
        CommandIDs.runAndAdvance,
        CommandIDs.runAndInsert,
        CommandIDs.runInConsole,
        CommandIDs.clearOutputs,
        CommandIDs.toCode,
        CommandIDs.toMarkdown,
        CommandIDs.toRaw,
        CommandIDs.cut,
        CommandIDs.copy,
        CommandIDs.pasteBelow,
        CommandIDs.pasteAbove,
        CommandIDs.pasteAndReplace,
        CommandIDs.deleteCell,
        CommandIDs.split,
        CommandIDs.merge,
        CommandIDs.mergeAbove,
        CommandIDs.mergeBelow,
        CommandIDs.insertAbove,
        CommandIDs.insertBelow,
        CommandIDs.selectAbove,
        CommandIDs.selectBelow,
        CommandIDs.extendAbove,
        CommandIDs.extendTop,
        CommandIDs.extendBelow,
        CommandIDs.extendBottom,
        CommandIDs.moveDown,
        CommandIDs.moveUp,
        CommandIDs.undoCellAction,
        CommandIDs.redoCellAction,
        CommandIDs.markdown1,
        CommandIDs.markdown2,
        CommandIDs.markdown3,
        CommandIDs.markdown4,
        CommandIDs.markdown5,
        CommandIDs.markdown6,
        CommandIDs.hideCode,
        CommandIDs.showCode,
        CommandIDs.hideAllCode,
        CommandIDs.showAllCode,
        CommandIDs.hideOutput,
        CommandIDs.showOutput,
        CommandIDs.hideAllOutputs,
        CommandIDs.showAllOutputs,
        CommandIDs.enableOutputScrolling,
        CommandIDs.disableOutputScrolling
    ].forEach(command => {
        palette.addItem({ command, category });
    });
}
/**
 * Populates the application menus for the notebook.
 */
function populateMenus(app, mainMenu, tracker, translator, sessionDialogs) {
    const trans = translator.load('jupyterlab');
    const { commands } = app;
    sessionDialogs = sessionDialogs || _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.sessionContextDialogs;
    // Add undo/redo hooks to the edit menu.
    mainMenu.editMenu.undoers.add({
        tracker,
        undo: widget => {
            var _a;
            (_a = widget.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor.undo();
        },
        redo: widget => {
            var _a;
            (_a = widget.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor.redo();
        }
    });
    // Add a clearer to the edit menu
    mainMenu.editMenu.clearers.add({
        tracker,
        clearCurrentLabel: (n) => trans.__('Clear Output'),
        clearAllLabel: (n) => {
            return trans.__('Clear All Outputs');
        },
        clearCurrent: (current) => {
            return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.clearOutputs(current.content);
        },
        clearAll: (current) => {
            return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.clearAllOutputs(current.content);
        }
    });
    // Add a close and shutdown command to the file menu.
    mainMenu.fileMenu.closeAndCleaners.add({
        tracker,
        closeAndCleanupLabel: (n) => trans.__('Close and Shutdown Notebook'),
        closeAndCleanup: (current) => {
            const fileName = current.title.label;
            return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({
                title: trans.__('Shut down the Notebook?'),
                body: trans.__('Are you sure you want to close "%1"?', fileName),
                buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton(), _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.warnButton()]
            }).then(result => {
                if (result.button.accept) {
                    return current.context.sessionContext.shutdown().then(() => {
                        current.dispose();
                    });
                }
            });
        }
    });
    // Add a kernel user to the Kernel menu
    mainMenu.kernelMenu.kernelUsers.add({
        tracker,
        interruptKernel: current => {
            var _a;
            const kernel = (_a = current.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
            if (kernel) {
                return kernel.interrupt();
            }
            return Promise.resolve(void 0);
        },
        reconnectToKernel: current => {
            var _a;
            const kernel = (_a = current.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
            if (kernel) {
                return kernel.reconnect();
            }
            return Promise.resolve(void 0);
        },
        restartKernelAndClearLabel: (n) => trans.__('Restart Kernel and Clear All Outputs'),
        restartKernel: current => sessionDialogs.restart(current.sessionContext, translator),
        restartKernelAndClear: current => {
            return sessionDialogs
                .restart(current.sessionContext, translator)
                .then(restarted => {
                if (restarted) {
                    _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.clearAllOutputs(current.content);
                }
                return restarted;
            });
        },
        changeKernel: current => sessionDialogs.selectKernel(current.sessionContext, translator),
        shutdownKernel: current => current.sessionContext.shutdown()
    });
    // Add a console creator the the Kernel menu
    mainMenu.fileMenu.consoleCreators.add({
        tracker,
        createConsoleLabel: (n) => trans.__('New Console for Notebook'),
        createConsole: current => Private.createConsole(commands, current, true)
    });
    // Add an IEditorViewer to the application view menu
    mainMenu.viewMenu.editorViewers.add({
        tracker,
        toggleLineNumbers: widget => {
            _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.toggleAllLineNumbers(widget.content);
        },
        lineNumbersToggled: widget => {
            const config = widget.content.editorConfig;
            return !!(config.code.lineNumbers &&
                config.markdown.lineNumbers &&
                config.raw.lineNumbers);
        }
    });
    // Add an ICodeRunner to the application run menu
    mainMenu.runMenu.codeRunners.add({
        tracker,
        runLabel: (n) => trans.__('Run Selected Cells'),
        runAllLabel: (n) => trans.__('Run All Cells'),
        restartAndRunAllLabel: (n) => trans.__('Restart Kernel and Run All Cells'),
        run: current => {
            const { context, content } = current;
            return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAndAdvance(content, context.sessionContext).then(() => void 0);
        },
        runAll: current => {
            const { context, content } = current;
            return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAll(content, context.sessionContext).then(() => void 0);
        },
        restartAndRunAll: current => {
            const { context, content } = current;
            return sessionDialogs
                .restart(context.sessionContext, translator)
                .then(restarted => {
                if (restarted) {
                    void _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_9__.NotebookActions.runAll(content, context.sessionContext);
                }
                return restarted;
            });
        }
    });
    // Add kernel information to the application help menu.
    mainMenu.helpMenu.kernelUsers.add({
        tracker,
        getKernel: current => { var _a; return (_a = current.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel; }
    });
}
/**
 * A namespace for module private functionality.
 */
var Private;
(function (Private) {
    /**
     * Create a console connected with a notebook kernel
     *
     * @param commands Commands registry
     * @param widget Notebook panel
     * @param activate Should the console be activated
     */
    function createConsole(commands, widget, activate) {
        const options = {
            path: widget.context.path,
            preferredLanguage: widget.context.model.defaultKernelLanguage,
            activate: activate,
            ref: widget.id,
            insertMode: 'split-bottom'
        };
        return commands.execute('console:create', options);
    }
    Private.createConsole = createConsole;
    /**
     * Whether there is an active notebook.
     */
    function isEnabled(shell, tracker) {
        return (tracker.currentWidget !== null &&
            tracker.currentWidget === shell.currentWidget);
    }
    Private.isEnabled = isEnabled;
    /**
     * Whether there is an notebook active, with a single selected cell.
     */
    function isEnabledAndSingleSelected(shell, tracker) {
        if (!Private.isEnabled(shell, tracker)) {
            return false;
        }
        const { content } = tracker.currentWidget;
        const index = content.activeCellIndex;
        // If there are selections that are not the active cell,
        // this command is confusing, so disable it.
        for (let i = 0; i < content.widgets.length; ++i) {
            if (content.isSelected(content.widgets[i]) && i !== index) {
                return false;
            }
        }
        return true;
    }
    Private.isEnabledAndSingleSelected = isEnabledAndSingleSelected;
    /**
     * Whether there is an notebook active, with a single selected cell.
     */
    function isEnabledAndHeadingSelected(shell, tracker) {
        if (!Private.isEnabled(shell, tracker)) {
            return false;
        }
        const { content } = tracker.currentWidget;
        const index = content.activeCellIndex;
        if (!(content.activeCell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.MarkdownCell)) {
            return false;
        }
        // If there are selections that are not the active cell,
        // this command is confusing, so disable it.
        for (let i = 0; i < content.widgets.length; ++i) {
            if (content.isSelected(content.widgets[i]) && i !== index) {
                return false;
            }
        }
        return true;
    }
    Private.isEnabledAndHeadingSelected = isEnabledAndHeadingSelected;
    /**
     * The default Export To ... formats and their human readable labels.
     */
    function getFormatLabels(translator) {
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.nullTranslator;
        const trans = translator.load('jupyterlab');
        return {
            html: trans.__('HTML'),
            latex: trans.__('LaTeX'),
            markdown: trans.__('Markdown'),
            pdf: trans.__('PDF'),
            rst: trans.__('ReStructured Text'),
            script: trans.__('Executable Script'),
            slides: trans.__('Reveal.js Slides')
        };
    }
    Private.getFormatLabels = getFormatLabels;
    /**
     * A widget hosting a cloned output area.
     */
    class ClonedOutputArea extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_21__.Panel {
        constructor(options) {
            super();
            this._cell = null;
            const trans = (options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_15__.nullTranslator).load('jupyterlab');
            this._notebook = options.notebook;
            this._index = options.index !== undefined ? options.index : -1;
            this._cell = options.cell || null;
            this.id = `LinkedOutputView-${_lumino_coreutils__WEBPACK_IMPORTED_MODULE_18__.UUID.uuid4()}`;
            this.title.label = 'Output View';
            this.title.icon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_16__.notebookIcon;
            this.title.caption = this._notebook.title.label
                ? trans.__('For Notebook: %1', this._notebook.title.label)
                : trans.__('For Notebook:');
            this.addClass('jp-LinkedOutputView');
            // Wait for the notebook to be loaded before
            // cloning the output area.
            void this._notebook.context.ready.then(() => {
                if (!this._cell) {
                    this._cell = this._notebook.content.widgets[this._index];
                }
                if (!this._cell || this._cell.model.type !== 'code') {
                    this.dispose();
                    return;
                }
                const clone = this._cell.cloneOutputArea();
                this.addWidget(clone);
            });
        }
        /**
         * The index of the cell in the notebook.
         */
        get index() {
            return this._cell
                ? _lumino_algorithm__WEBPACK_IMPORTED_MODULE_17__.ArrayExt.findFirstIndex(this._notebook.content.widgets, c => c === this._cell)
                : this._index;
        }
        /**
         * The path of the notebook for the cloned output area.
         */
        get path() {
            return this._notebook.context.path;
        }
    }
    Private.ClonedOutputArea = ClonedOutputArea;
})(Private || (Private = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 90805:
/*!*************************************************************************!*\
  !*** ../../node_modules/@jupyterlab/notebook-extension/lib/nboutput.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logNotebookOutput": () => (/* binding */ logNotebookOutput)
/* harmony export */ });
/* harmony import */ var _jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/logconsole */ 90880);
/* harmony import */ var _jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/notebook */ 86944);
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/services */ 13240);
/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The Log Console extension.
 */
const logNotebookOutput = {
    activate: activateNBOutput,
    id: '@jupyterlab/notebook-extension:log-output',
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__.INotebookTracker],
    optional: [_jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0__.ILoggerRegistry],
    autoStart: true
};
function activateNBOutput(app, nbtracker, loggerRegistry) {
    if (!loggerRegistry) {
        // Automatically disable if logconsole is missing
        return;
    }
    function registerNB(nb) {
        function logOutput(msg, levelNormal, levelError) {
            if (_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isDisplayDataMsg(msg) ||
                _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isStreamMsg(msg) ||
                _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isErrorMsg(msg) ||
                _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isExecuteResultMsg(msg)) {
                const logger = loggerRegistry.getLogger(nb.context.path);
                logger.rendermime = nb.content.rendermime;
                const data = Object.assign(Object.assign({}, msg.content), { output_type: msg.header.msg_type });
                let level = levelNormal;
                if (_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isErrorMsg(msg) ||
                    (_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isStreamMsg(msg) && msg.content.name === 'stderr')) {
                    level = levelError;
                }
                logger.log({ type: 'output', data, level });
            }
        }
        // There is overlap here since unhandled messages are also emitted in the
        // iopubMessage signal. However, unhandled messages warrant a higher log
        // severity, so we'll accept that they are logged twice.
        nb.context.sessionContext.iopubMessage.connect((_, msg) => logOutput(msg, 'info', 'info'));
        nb.context.sessionContext.unhandledMessage.connect((_, msg) => logOutput(msg, 'warning', 'error'));
    }
    nbtracker.forEach(nb => registerNB(nb));
    nbtracker.widgetAdded.connect((_, nb) => registerNB(nb));
}
//# sourceMappingURL=nboutput.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jupyterlab_notebook-extension_lib_index_js.765829882a3bf011b525.js.map